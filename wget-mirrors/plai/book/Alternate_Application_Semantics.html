<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>17&nbsp;Alternate Application Semantics</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Introduction.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Everything__We_Will_Say__About_Parsing.html" class="tocviewlink" data-pltdoc="x">Everything (We Will Say) About Parsing</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="first-interp.html" class="tocviewlink" data-pltdoc="x">A First Look at Interpretation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="first-desugar.html" class="tocviewlink" data-pltdoc="x">A First Taste of Desugaring</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="adding-functions.html" class="tocviewlink" data-pltdoc="x">Adding Functions to the Language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="From_Substitution_to_Environments.html" class="tocviewlink" data-pltdoc="x">From Substitution to Environments</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="higher-order-functions.html" class="tocviewlink" data-pltdoc="x">Functions Anywhere</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="mut-struct-vs-var.html" class="tocviewlink" data-pltdoc="x">Mutation:<span class="mywbr"> &nbsp;</span> Structures and Variables</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="recursion.html" class="tocviewlink" data-pltdoc="x">Recursion and Cycles:<span class="mywbr"> &nbsp;</span> Procedures and Data</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Objects.html" class="tocviewlink" data-pltdoc="x">Objects</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Memory_Management.html" class="tocviewlink" data-pltdoc="x">Memory Management</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Representation_Decisions.html" class="tocviewlink" data-pltdoc="x">Representation Decisions</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Desugaring_as_a_Language_Feature.html" class="tocviewlink" data-pltdoc="x">Desugaring as a Language Feature</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Control_Operations.html" class="tocviewlink" data-pltdoc="x">Control Operations</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="types.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Statically:<span class="mywbr"> &nbsp;</span> Types</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="contracts.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Dynamically:<span class="mywbr"> &nbsp;</span> Contracts</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Alternate Application Semantics</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>17&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Alternate Application Semantics</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">17.1&nbsp;</td><td><a href="#%28part._.Lazy_.Application%29" class="tocviewlink" data-pltdoc="x">Lazy Application</a></td></tr><tr><td align="right">17.2&nbsp;</td><td><a href="#%28part._.Reactive_.Application%29" class="tocviewlink" data-pltdoc="x">Reactive Application</a></td></tr><tr><td align="right">17.3&nbsp;</td><td><a href="#%28part._.Backtracking_.Application%29" class="tocviewlink" data-pltdoc="x">Backtracking Application</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">17.1<tt>&nbsp;</tt></span><a href="#%28part._.Lazy_.Application%29" class="tocsubseclink" data-pltdoc="x">Lazy Application</a></td></tr><tr><td><span class="tocsublinknumber">17.1.1<tt>&nbsp;</tt></span><a href="#%28part._.A_.Lazy_.Application_.Example%29" class="tocsubseclink" data-pltdoc="x">A Lazy Application Example</a></td></tr><tr><td><span class="tocsublinknumber">17.1.2<tt>&nbsp;</tt></span><a href="#%28part._.What_.Are_.Values_%29" class="tocsubseclink" data-pltdoc="x">What Are Values?</a></td></tr><tr><td><span class="tocsublinknumber">17.1.3<tt>&nbsp;</tt></span><a href="#%28part._.What_.Causes_.Evaluation_%29" class="tocsubseclink" data-pltdoc="x">What Causes Evaluation?</a></td></tr><tr><td><span class="tocsublinknumber">17.1.4<tt>&nbsp;</tt></span><a href="#%28part._.An_.Interpreter%29" class="tocsubseclink" data-pltdoc="x">An Interpreter</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3clazy-interp~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-interp&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3clazy-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-numC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3clazy-lam.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-lamC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3clazy-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-idC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3clazy-plus.C%2Fmult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-plusC/multC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3clazy-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-appC-case&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">17.1.5<tt>&nbsp;</tt></span><a href="#%28part._.Laziness_and_.Mutation%29" class="tocsubseclink" data-pltdoc="x">Laziness and Mutation</a></td></tr><tr><td><span class="tocsublinknumber">17.1.6<tt>&nbsp;</tt></span><a href="#%28part._.Caching_.Computation%29" class="tocsubseclink" data-pltdoc="x">Caching Computation</a></td></tr><tr><td><span class="tocsublinknumber">17.2<tt>&nbsp;</tt></span><a href="#%28part._.Reactive_.Application%29" class="tocsubseclink" data-pltdoc="x">Reactive Application</a></td></tr><tr><td><span class="tocsublinknumber">17.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Motivating_.Example__.A_.Timer%29" class="tocsubseclink" data-pltdoc="x">Motivating Example:<span class="mywbr"> &nbsp;</span> A Timer</a></td></tr><tr><td><span class="tocsublinknumber">17.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Callback_.Types_are_.Four-.Letter_.Words%29" class="tocsubseclink" data-pltdoc="x">Callback Types are Four-<wbr></wbr>Letter Words</a></td></tr><tr><td><span class="tocsublinknumber">17.2.3<tt>&nbsp;</tt></span><a href="#%28part._.The_.Alternative__.Reactive_.Languages%29" class="tocsubseclink" data-pltdoc="x">The Alternative:<span class="mywbr"> &nbsp;</span> Reactive Languages</a></td></tr><tr><td><span class="tocsublinknumber">17.2.4<tt>&nbsp;</tt></span><a href="#%28part._.Implementing_.Transparent_.Reactivity%29" class="tocsubseclink" data-pltdoc="x">Implementing Transparent Reactivity</a></td></tr><tr><td><span class="tocsublinknumber">17.2.4.1<tt>&nbsp;</tt></span><a href="#%28part._.Dataflow_.Graph_.Construction%29" class="tocsubseclink" data-pltdoc="x">Dataflow Graph Construction</a></td></tr><tr><td><span class="tocsublinknumber">17.2.4.2<tt>&nbsp;</tt></span><a href="#%28part._.Dataflow_.Graph_.Update%29" class="tocsubseclink" data-pltdoc="x">Dataflow Graph Update</a></td></tr><tr><td><span class="tocsublinknumber">17.2.4.3<tt>&nbsp;</tt></span><a href="#%28part._.Evaluation_.Order%29" class="tocsubseclink" data-pltdoc="x">Evaluation Order</a></td></tr><tr><td><span class="tocsublinknumber">17.3<tt>&nbsp;</tt></span><a href="#%28part._.Backtracking_.Application%29" class="tocsubseclink" data-pltdoc="x">Backtracking Application</a></td></tr><tr><td><span class="tocsublinknumber">17.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Searching_for_.Satisfaction%29" class="tocsubseclink" data-pltdoc="x">Searching for Satisfaction</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctry-or-bt~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;try-or-bt&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctry-or-bt-body~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;try-or-bt-body&gt;</a></span></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="contracts.html" title="backward to &quot;16 Checking Program Invariants Dynamically: Contracts&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h3>17<tt>&nbsp;</tt><a name="(part._.Alternate_.Application_.Semantics)"></a>Alternate Application Semantics</h3><p>Long ago [REF], we considered the question of what to substitute when
performing application.  Now we are ready to consider some
alternatives.  At the time, we suggested just one alternative; in fact
there are many more.  To understand this, see whether you can answer
this question:</p><p><div class="SIntrapara"><span style="font-weight: bold">Which of these is the same?</span></div><div class="SIntrapara"><blockquote><ul><li><p><span class="stt">(f x (current-seconds))</span></p></li><li><p><span class="stt">(f x (current-seconds))</span></p></li><li><p><span class="stt">(f x (current-seconds))</span></p></li><li><p><span class="stt">(f x (current-seconds))</span></p></li></ul></blockquote></div></p><p>What we&rsquo;re about to find is that this fragment of syntax can have
wildly different run-time behaviors.  For instance, there is the
distinction we have already mentioned: variation in when
<span class="stt">(current-seconds)</span> is evaluated.  There is variation in
<span style="font-style: italic">how many times</span> it is evaluated (and hence <span class="stt">f</span> is run).
There is even variation even in whether values for <span class="stt">x</span> flow
strictly from the caller to the callee, or can even flow in the
opposite direction!</p><h4>17.1<tt>&nbsp;</tt><a name="(part._.Lazy_.Application)"></a>Lazy Application</h4><p><div class="SIntrapara">Let&rsquo;s start by considering when parameters are reduced to values.
That is, do we substitute formal parameters with the
<span style="font-style: italic">value</span> of the actual parameter, or with the actual parameter
<span style="font-style: italic">expression</span> itself?  If we define
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">sq</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and invoke it as
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">sq</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">does that reduce to
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">or to
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">?  The former is called <span style="font-style: italic">eager</span> application, while the latter is
<span style="font-style: italic">lazy</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">Some people also use the term <span style="font-style: italic">strict</span>
for the former.  A more arcane terminology is
<span style="font-style: italic">applicative-order evaluation</span> for the former and
<span style="font-style: italic">normal-order evaluation</span> for the
latter.  Or, <span style="font-style: italic">call-by-value</span> for the former and <span style="font-style: italic">call-by-name</span>
or <span style="font-style: italic">call-by-need</span> for the latter.  The last two terms&#8212;<wbr></wbr>by-name
versus by-need&#8212;<wbr></wbr>actually represent a technical distinction we will
see below.  This concludes our name-dump.</span></span></span>  Of course we don&rsquo;t want to
return to defining interpreters by substitution, but it is always
useful to think of substitution as a design principle.</div></p><h5>17.1.1<tt>&nbsp;</tt><a name="(part._.A_.Lazy_.Application_.Example)"></a>A Lazy Application Example</h5><p><div class="SIntrapara">The lazy alternative has a distinguished history (for instance, this
is what the true &#955;-calculus uses), but returned to the fore from
programming experiments considering what might happen if certain
operators did not evaluate the arguments at application but only when
the value was needed.  For instance, consider the definition
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">ones</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">cons</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">ones</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In ordinary Racket, this is clearly ill-defined: <span class="stt">ones</span> has not
yet been defined (on the left) when we try to evaluate it (on the
right), so this results in an error.  If, however, we do not try to
evaluate it until we actually need it, by that time the definition is
well-formed.  Because each <span class="stt">rest</span> obtains another <span class="stt">ones</span>,
this produces an infinite list.</div></p><p>We&rsquo;ve glossed over a lot that needs explaining.  Does the <span class="stt">ones</span>
in the <span class="stt">rest</span> position of the <span class="stt">cons</span> evaluate to a
<span style="font-style: italic">copy</span> of that expression, or to the result of the very same
expression itself?  In other words, have we simply created an
infinitely unfolding list, or have we created an actually
<span style="font-style: italic">cyclic</span> one?</p><p>This depends in good part on whether or not our language has
mutation.  If it does, then perhaps we can modify each of the cells of
the resulting list, which means we can observe the difference between
the two implementations above: in the unfolded version mutating one
<span class="stt">first</span> will not affect another, but in the cyclic one, changing
one will affect them all.  Therefore, in a language with mutation, we
might argue that this should represent a lazy unfolding, but not an
actual cyclic datum.</p><p>Keep this discussion in mind.  We cannot resolve it right now; rather,
let us examine lazy evaluation a little more, then return to this
question [REF].</p><h5>17.1.2<tt>&nbsp;</tt><a name="(part._.What_.Are_.Values_)"></a>What Are Values?</h5><p>If we return to our core higher-order function interpreter [REF], we
recall that we have two kinds of values: numbers and closures.  If we
want to support lazy evaluation instead, we need to ask what happens
at function application.  What exactly are we passing?</p><p>This seems obvious enough: in a lazy application semantics, we need to
pass <span style="font-style: italic">expressions</span>.  But a moment&rsquo;s thought shows that this can
be problematic.  Expressions contain identifier names,<span class="refelem"><span class="refcolumn"><span class="refcontent">And
now these truly will be <span style="font-style: italic">identifiers</span>, not <span style="font-style: italic">variables</span>, as
we will see [REF].</span></span></span> and we don&rsquo;t want them to be accidentally bound.</p><p><div class="SIntrapara">For instance, suppose we have
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and apply it as follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>What should this produce?</p></blockquote></div><div class="SIntrapara">Clearly, we should get an error reporting <span class="stt">x</span> as not being bound.</div></p><p>Now let&rsquo;s trace it.  The first application creates a closure where
<span class="stt">x</span> is bound to <span class="stt">3</span>.  If we now bind <span class="stt">y</span> to
<span class="stt">(+ x 4)</span>, this results in the expression <span class="stt">(+ x (+ x 4))</span>
in an environment where <span class="stt">x</span> is bound.  As a result we get the
answer <span class="stt">10</span>, not an error.</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Have we made a subtle assumption above?</p></blockquote></div></p><p>Yes we have: we&rsquo;ve assumed that <span class="stt">+</span> evaluates arguments and
returns numeric answers.  Perhaps <span class="stt">+</span> also behaves lazily; we
will study this issue in a moment.  Nevertheless, the central point
remains: if we are not careful, this erroneous expression will produce
some kind of valid answer, not an error.</p><p><div class="SIntrapara">In case you think this is entirely a problem with erroneous programs,
and can hence be treated specially (e.g., first scan the program
source for free identifiers), here is another use of the same
<span class="stt">f</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>What should this produce?</p></blockquote></div><div class="SIntrapara">We would expect this to produce the result of <span class="stt">(+ 3 5)</span> (probably
<span class="stt">8</span>).  However, if we substitute <span class="stt">x</span> inside the arithmetic
expression, we would get <span class="stt">(+ 3 3)</span> instead.</div></p><p>This latter example holds the key to our solution.  In the latter
example, the problem ostensibly arises only when we use environments;
if instead we use substitution, <span class="stt">x</span> in the application is
substituted as soon as we encounter the <span class="stt">let</span>, and the result is
what we expect.  In fact, note that the same argument holds earlier:
if we had used substitution, the very occurrence of <span class="stt">x</span> would
have signaled an error.  In short, we have to make sure our
environment-based implementation matches what substitution would have
done.  Doesn&rsquo;t that sound familiar!</p><p>In other words, the solution is to bundle the argument expression
<span style="font-style: italic">with its environment</span>: i.e., create a closure.  This closure has
no parameters, so it is effectively a
<span style="font-style: italic">thunk</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">Indeed, this demonstrates that functions
have two uses: to substitute names with values, and also to defer
substitution.  <span class="stt">let</span> is the former without the latter; thunks are
the latter without the former.  We have already established that the
former is valuable in its own right; this section shows that the same
is true of the latter.</span></span></span>  We could use existing functions to represent
these thunks, but our instinct should tell us that it is better to use
different data representations for logically different purposes:
<span class="stt">closV</span> for user-created closures, and something else for
internally-created ones.  Indeed, as we will see, it will have been
wise to keep them separate because there is one place where it is
critical we can tell them apart.</p><p><div class="SIntrapara">To conclude this discussion, here is our new set of values:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Value</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">numV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">closV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">body</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Env</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">suspendV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">body</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Env</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">The first two variants are exactly the same; the third is new, and as
we discussed, is effectively a parameter-less procedure, as its type
suggests.</div></p><h5>17.1.3<tt>&nbsp;</tt><a name="(part._.What_.Causes_.Evaluation_)"></a>What Causes Evaluation?</h5><p>Let us now return to discussing arithmetic expressions.  On evaluating
<span class="stt">(+ 1 2)</span>, a lazy application interpreter could return any number
of things, including <span class="stt">(suspendV (+ 1 2) mt-env)</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">It
is legitimate to write <span class="stt">mt-env</span> here because even if the
<span class="stt">(+ 1 2)</span> expression was written in a non-empty environment, it
has no free identifiers, so it doesn&rsquo;t need any of the environment&rsquo;s
bindings.</span></span></span>  In this way suspended computation could cascade on
suspended computation, and in the limiting case every program would
return immediately with an &ldquo;answer&rdquo;: the thunk representing the
suspension of its computation.</p><p><div class="SIntrapara">Clearly, <span style="font-style: italic">something</span> must force a suspension to be lifted.
(Lifting a suspension means, of course, evaluating its body in the
stored environment.)  Those expression positions that undo suspensions
are called <span style="font-style: italic">strictness points</span>.  The most obvious strictness point
is the interactive environment&rsquo;s printer, because a user clearly would
not use such an environment if they did not wish to see answers.  We
will embody the act of lifting suspension in the procedure
<span class="stt">strict</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">strict</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Value</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Value</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">type-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">Value</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">numV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">closV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta">e</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">suspendV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta">e</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">strict</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">interp</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">where the returned <span class="stt">Value</span> is guaranteed to not be a
<span class="stt">suspendV</span>.  We can imagine the printer as wrapping <span class="stt">strict</span>
around the result of evaluating the program, to obtain a value to
print.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>What impact would using closures to represent suspended computation
have had?</p></blockquote></div></p><p>The definition of <span class="stt">strict</span> above depends crucially on being able
to distinguish deferred computations&#8212;<wbr></wbr>which are
internally-constructed closures&#8212;<wbr></wbr>from user-defined closures.  Had we
conflated the two, then we would have to guess what to do with
zero-argument closures.  If we fail to further process them, we might
incorrectly get an error (e.g., <span class="stt">+</span> might get a thunk rather than
the numeric value residing inside it).  If we do process it further,
we might accidentally force a user-defined thunk prematurely.  In
short, we need a flag on thunks telling us whether they are internal
or user-defined.  For clarity, our interpreter uses a separate
variant.</p><p>Let us now return to the interaction between <span class="stt">strict</span> and the
interpreter.  Unfortunately, as we have defined things, this will
cause an infinite loop.  The act of trying to interpret an addition
creates a suspension, which <span class="stt">strict</span> tries to undo by forcing the
interpreter to interpret an addition, which....  Clearly, therefore,
we cannot have every expression simply suspend its computation;
instead, we will limit suspension to applications.  This suffices to
give us the rich power of laziness, without making the language
absurd.</p><h5>17.1.4<tt>&nbsp;</tt><a name="(part._.An_.Interpreter)"></a>An Interpreter</h5><p>As usual, we will define the interpreter in cases.</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3clazy-interp~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3clazy-interp~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-interp&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">expr</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Env</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Value</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="hspace">&nbsp;</span><span class="RktSym">expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3clazy-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-numC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3clazy-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-idC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3clazy-plus.C%2Fmult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-plusC/multC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3clazy-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-appC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3clazy-lam.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-lamC-case&gt;</a><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Numbers are easy: they are already values, so there is no point
needlessly suspending them:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3clazy-num.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3clazy-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-numC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">numC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numV</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>Closures, similarly, remain the same:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3clazy-lam.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3clazy-lam.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-lamC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">lamC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closV</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>Identifiers should just return whatever they are bound to:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3clazy-id.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3clazy-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-idC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">idC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lookup</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>The arguments of arithmetic expressions are usually defined as
strictness points, because otherwise we would simply have to implement
the actual arithmetic elsewhere:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3clazy-plus.C/mult.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3clazy-plus.C%2Fmult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-plusC/multC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">plusC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">strict</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">strict</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="RktPn">[</span><span class="RktSym">multC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">strict</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">strict</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>Finally, we have application.  Here, instead of evaluating the
argument position, we suspend it.  The function position has to be a
strictness point, however, otherwise we wouldn&rsquo;t know what function to
apply and hence how to continue the computation:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3clazy-app.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3clazy-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;lazy-appC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">appC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">local</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">f-value</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">strict</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closV-body</span><span class="hspace">&nbsp;</span><span class="RktSym">f-value</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-env</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bind</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closV-arg</span><span class="hspace">&nbsp;</span><span class="RktSym">f-value</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">suspendV</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closV-env</span><span class="hspace">&nbsp;</span><span class="RktSym">f-value</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>And that&rsquo;s it!  By adding a new kind of answer, inserting a few calls
to <span class="stt">strict</span>, and replacing <span class="stt">interp</span> with <span class="stt">suspendV</span> in
the argument position of application, we have turned our eager
application interpreter into one with lazy application.  Yet this
small change has such enormous impact on the programs we write!  For a
more thorough examination of this impact, study Haskell or the
<span class="stt">#lang lazy</span> language in Racket.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>If we instead replace the identifier case with
<span class="stt">(strict (lookup n env))</span> (i.e., wrapped <span class="stt">strict</span> around the
result of looking up an identifier), what impact would it have on the
language?  Consider richer languages with data structures, etc.</p></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Construct programs that produce different results in a lazy evaluation
than an eager evaluation (i.e., the same program text with different
answers in the two cases).  Try to make the differences interesting,
i.e., beyond whether one returns a <span class="stt">suspendV</span> while the other
doesn&rsquo;t.  For instance, does one terminate or produce an error while
the other one doesn&rsquo;t?</p></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Instrument both interpreters to count the number of steps they take to
return answers.  For programs that produce the same answer under both
evaluation strategies, does one strategy always take more steps than
the other?</p></blockquote></div></p><h5>17.1.5<tt>&nbsp;</tt><a name="(part._.Laziness_and_.Mutation)"></a>Laziness and Mutation</h5><p>One of the virtues of lazy evaluation is that it defers execution.
Usually this is a good thing: it enables us to build infinite data
structures and avoids computation until necessary.  Unfortunately, it
also changes when computations occur, and in particular, changes the
order of when computations evaluate relative to each other, depending
on what strictness points are encountered when.  As a result,
programmers greatly lose predictability of ordering.  This is of
course a problem when expressions perform mutation operations, because
now it becomes extremely difficult to predict what value a program
will compute (relative to the eager version).</p><p>As a result, the core of every lazy language is free of mutation.  In
Haskell, mutation and other state operations are introduced through a
variety of mechanisms such as <span style="font-style: italic">monads</span> and <span style="font-style: italic">arrows</span> that
ultimately introduce the ability to (strictly) sequentialize code;
this sequentiality is essential to being able to predict the order of
execution and thus the result of operations.  If programs are
structured well the number of these dependencies should be small;
furthermore, the Haskell type system attempts to reflect these
operations in the types themselves, so programmers can more easily
reason about their effects.</p><h5>17.1.6<tt>&nbsp;</tt><a name="(part._.Caching_.Computation)"></a>Caching Computation</h5><p>Now that we&rsquo;ve concluded that lazy computation has to have no
mutations, we observe a pleasant consequence (dare we say,
side-effect?): given a fixed environment, an expression always
produces the same answer.  As a result, the run-time system can cache
the value of an expression when it is first forced to an answer by
strictness, and return this cached value on subsequent attempts to
compute it.  Of course, this caching&#8212;<wbr></wbr>which is a form of
<span style="font-style: italic">memoization</span>&#8212;<wbr></wbr>is only sound when the expression returns the same
value every time, which we have assumed.  In fact, the compiler and
run-time system can aggressively hunt for uses of the same expression
in different parts of the program and, if the relevant parts of their
environment are the same, conflate their evaluation.  The strategy of
evaluating the suspended computation every time it is needed is called
<span style="font-style: italic">call-by-name</span>; that of caching its result, <span style="font-style: italic">call-by-need</span>.</p><h4>17.2<tt>&nbsp;</tt><a name="(part._.Reactive_.Application)"></a>Reactive Application</h4><p><div class="SIntrapara">Now consider an expression like <span class="stt">(current-seconds)</span>.  When we
evaluate it, it returns a single number representing the current
time.  For instance,
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (current-seconds)</span></p></td></tr><tr><td><p><span class="stt">1353030630</span></p></td></tr></table></div><div class="SIntrapara">However, even as we stare at this value, it is already out-of-date!
It represents the time when the function application occurred, but
does not stay current.</div></p><h5>17.2.1<tt>&nbsp;</tt><a name="(part._.Motivating_.Example__.A_.Timer)"></a>Motivating Example: A Timer</h5><p><div class="SIntrapara">Suppose we were trying to implement a timer that measures elapsed
time.  Ideally, we would like to write a program such as this:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">let</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">start</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">current-seconds</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">current-seconds</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">start</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In JavaScript, we might write:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">d = new Date();</span></p></td></tr><tr><td><p><span class="stt">start = d.getTime();</span></p></td></tr><tr><td><p><span class="stt">current = d.getTime();</span></p></td></tr><tr><td><p><span class="stt">elapsed = current - start;</span></p></td></tr></table></div><div class="SIntrapara">On most machines this Racket expression, or the value of
<span class="stt">elapsed</span> in JavaScript, will evaluate to <span class="stt">0</span> or some
other very small number.  This is because these programs
represent <span style="font-style: italic">one</span> measure of the elapsed time: that at the
second invocation of the procedure that gets the current time.  This
gives us an instanteous time split, but not an actual timer.</div></p><p><div class="SIntrapara">In most languages, to build an actual timer, we would have to create
an instance of some sort of timer object, and install a callback.
Every time the clock ticks, the timer object&#8212;<wbr></wbr>representing the
operating system&#8212;<wbr></wbr>invokes the callback.  The callback is then
responsible for updating values in the rest of the system, and
hopefully doing so globally and consistently.  However, it cannot do
so by returning values, because it would return to the operating
system, which is agnostic to and does not care about our application;
therefore, the callback is forced to perform its action through
mutation.  In JavaScript, for instance:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">var timerID = null;</span></p></td></tr><tr><td><p><span class="stt">var elapsedTime = 0;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">function doEverySecond() {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">elapsedTime += 1;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">document.getElementById('curTime').innerHTML = elapsedTime; }</span></p></td></tr><tr><td><p><span class="stt">function startTimer() {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">timerId = setInterval(doEverySecond, 1000); }</span></p></td></tr></table></div><div class="SIntrapara">assuming we have an <span class="Smaller">HTML</span> page with an id named <span class="stt">curTime</span>, and
that the <span class="stt">onload</span> or other callback invokes <span class="stt">startTimer</span>.</div></p><p><div class="SIntrapara">One alternative to this spaghetti code is for the application program
to repeatedly poll the operating system for the current time.
However:
</div><div class="SIntrapara"><ul><li><p>Calling too frequently wastes resources, while calling too
infrequently results in incorrect answers.  However, to call at just
the right resolution, we would need a timer signal in the first
place!</p></li><li><p>While it may be possible to create such a polling loop for
regular events such as timers, it is impossible to do so accurately
for unpredictable behaviors such as user input (whose frequency
cannot, in general, be predicted).</p></li><li><p>On top of all this, writing this loop pollutes the program&rsquo;s
structure and forces the developer to sustain this extra burden.</p></li></ul></div></p><p>The callback-based solution, however, demonstrates an
<span style="font-style: italic">inversion of control</span>.  Instead of the application program
calling the operating system, the operating system has now been
charged with calling (into) the application program.  The reactive
behavior that should have been deeply nested, inside the display
expression, has instead been brought to the top-level, and its value
drives the other computations.  The fundamental cause for this is that
the world is in control, not the program, so external stimuli
determine when and how the program should next run, not intrinsic
program expressions.</p><h5>17.2.2<tt>&nbsp;</tt><a name="(part._.Callback_.Types_are_.Four-.Letter_.Words)"></a>Callback Types are Four-Letter Words</h5><p><div class="SIntrapara">The characteristic signature (so to speak) of this pattern is manifest
in the types.  Because the operating system is agnostic to the
program&rsquo;s values, the callback usually has no return type at all, or
it is a generic status indicator, not an application-specific value.
Therefore, in typed languages, the type is usually some
<span style="font-style: italic">four-letter word</span>.  For instance, here is a fragment of a <span class="Smaller">GUI</span>
library in Java:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">interface ChangeListener extends EventListener {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">void stateChanged(ChangeEvent e) { ... } }</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">interface ActionListener extends EventListener {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">void actionPerformed(ActionEvent e) { ... } }</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">interface MouseListener extends EventListener {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">void mouseClicked(MouseEvent e) { ... }</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">void mouseEntered(MouseEvent e) { ... } }</span></p></td></tr></table></div><div class="SIntrapara">And here&rsquo;s one in OCaml:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">mainLoop : unit -&gt; unit</span></p></td></tr><tr><td><p><span class="stt">closeTk : unit -&gt; unit</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">destroy : 'a Widget.widget -&gt; unit</span></p></td></tr><tr><td><p><span class="stt">update : unit -&gt; unit</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">pack : ... -&gt; 'd Widget.widget list -&gt; unit</span></p></td></tr><tr><td><p><span class="stt">grid : ... -&gt; 'b Widget.widget list -&gt; unit</span></p></td></tr></table></div><div class="SIntrapara">In Haskell, the four letters have an extra space in them:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">select :: Selecting w =&gt; Event w (IO ())</span></p></td></tr><tr><td><p><span class="stt">mouse :: Reactive w =&gt; Event w (EventMouse -&gt; IO ())</span></p></td></tr><tr><td><p><span class="stt">keyboard :: Reactive w =&gt; Event w (EventKey -&gt; IO ())</span></p></td></tr><tr><td><p><span class="stt">resize :: Reactive w =&gt; Event w (IO ())</span></p></td></tr><tr><td><p><span class="stt">focus :: Reactive w =&gt; Event w (Bool -&gt; IO ())</span></p></td></tr><tr><td><p><span class="stt">activate :: Reactive w =&gt; Event w (Bool -&gt; IO ())</span></p></td></tr></table></div><div class="SIntrapara">and so on.  In all these cases, the presence of a &ldquo;void&rdquo;-like type
clearly indicates that the functions do not return any interesting
value, so their only purpose must be to mutate the store or have some
other side-effect.  This also means that no rich means of
composition&#8212;<wbr></wbr>such as the nesting of expressions&#8212;<wbr></wbr>is possible: the
only composition operator for void-typed statements is sequencing.
Thus the types reveal that we will be forced away from being able to
write nested expressions.</div></p><p>Readers will, of course, be familiar with this problem from our
earlier discussion of Web programming.  This problem occurs on the
server due to statelessness [REF], and also on the client due to
single-threading [REF].  On the server, at least, we were able to use
continuations to address this problem.  However, continuations are not
available in all languages, and implementing them can be onerous.
Furthermore, it can be tricky to set up just the right continuation to
pass as a callback.  Instead, we will explore an alternate solution.</p><h5>17.2.3<tt>&nbsp;</tt><a name="(part._.The_.Alternative__.Reactive_.Languages)"></a>The Alternative: Reactive Languages</h5><p><div class="SIntrapara">Consider the FrTime (pronounced &ldquo;Father Time&rdquo;) language
in DrRacket.<span class="refelem"><span class="refcolumn"><span class="refcontent">In DrRacket v5.3, you must select the
language from the Language menu; writing <span class="stt">#lang frtime</span> will not
provide the interesting interactions window behavior.</span></span></span>  If we run this
expression at the interactions window, we still get <span class="stt">0</span> or some
other very small non-negative number:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">let</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">start</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">current-seconds</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">current-seconds</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">start</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In fact, we can try several other expressions and see that FrTime
seems to have exactly like traditional Racket.</div></p><p>However, it also binds a few additional identifiers.  For instance, it
provides a value bound to <span class="stt">seconds</span>.  If we type this into the
interaction prompt, we get something very interesting!  First we see
<span class="stt">1353030630</span>, then a second later <span class="stt">1353030631</span>, another
second later <span class="stt">1353030632</span>, and so on.  This kind of value is
called a <span style="font-style: italic">behavior</span>: a value that changes over time.  Except we
haven&rsquo;t written any callbacks or other code to keep it current.</p><p><div class="SIntrapara">A behavior can be used in computations.  For instance, we can write
<span class="stt">(- seconds seconds)</span>, and this always evaluates to <span class="stt">0</span>.
Here are some more expressions to try at the interaction prompt:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">add1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">seconds</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">modulo</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">seconds</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">build-list</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">modulo</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">seconds</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">identity</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">build-list</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">add1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">modulo</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">seconds</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">identity</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">As you can see, being a behavior is &ldquo;sticky&rdquo;: if any sub-expression
is a behavior, so is its enclosing expression.</div></p><p>Thanks to this evaluation model, every time <span class="stt">seconds</span> updates the
entire application happens afresh: as a result, even though we have
written seemingly simple expressions without any explicit loop-like
control, the program still &ldquo;loops&rdquo;.  In other words, having explored
an application semantics where arguments are evaluated once, then
another where they may be evaluated zero times, now we have one where
they are evaluated as many times as necessary, and the entire
corresponding function with them.  As a consequence, reactive values
that are &ldquo;inside&rdquo; an expression no longer need to be brought &ldquo;outside&rdquo;;
rather, they can reside nested inside expressions, giving programmers
a more natural means of expression.  This style of evaluation is
called <span style="font-style: italic">dataflow</span> or <span style="font-style: italic">functional reactive</span>
programming.<span class="refelem"><span class="refcolumn"><span class="refcontent">Historically, <span style="font-style: italic">dataflow</span>
has tended to refer to languages with first-order functions, whereas
<span style="font-style: italic">functional reactive</span> languages support higher-order functions
too.</span></span></span></p><p>FrTime implements what we call <span style="font-style: italic">transparent reactivity</span>, whereby
the programmer can inject a reactive behavior anywhere in a program&rsquo;s
evaluation without needing to make any syntactic changes to its
context.  This has the virtue of making it easy to inject reactivity
into existing programs, but it can make the evaluation and cost model
more complex for programmers.  In other languages, programmers can
instead explicitly introduce behavior through appropriate primitives,
trading convenience for greater predictability.  FrTime&rsquo;s sister
language, Flapjax, an extension of JavaScript, provides both
modes.<span class="refelem"><span class="refcolumn"><span class="refcontent">See the
<a href="http://www.flapjax-lang.org/">Flapjax Web site</a>.</span></span></span></p><h5>17.2.4<tt>&nbsp;</tt><a name="(part._.Implementing_.Transparent_.Reactivity)"></a>Implementing Transparent Reactivity</h5><p>To make an existing language implement transparent reactivity, we have
to (naturally) alter the semantics of function application.  We will
do this in two steps.  First we will rewrite reactive function
applications into a more complex form, then we will show how this more
complex form enables reactive updates.</p><h5>17.2.4.1<tt>&nbsp;</tt><a name="(part._.Dataflow_.Graph_.Construction)"></a>Dataflow Graph Construction</h5><p><div class="SIntrapara">The essence of making an application reactive is simple to explain
through desugaring.  Assume we have defined a new constructor
<span class="stt">behavior</span>.  The constructor takes a thunk that represents what
computation to perform every time an argument updates, and all the
values that the expression depends on.  The value it produces stores
the current value of the behavior.  Then an expression
like <span class="stt">(f x y)</span> turns into
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">if</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">or</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">behavior?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">behavior?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">behavior</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">f</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">current-value</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">current-value</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">f</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">where we assume, given a non-behavior constant, <span class="stt">current-value</span>
behaves as the identity function.</div></p><p><div class="SIntrapara">Let us look at two examples of using the above definition.  Consider
the trivial case where neither parameter is a behavior, e.g.,
<span class="stt">(+ 3 4)</span>.  This desugars to
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">if</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">or</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">behavior?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">behavior?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">behavior</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">current-value</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">current-value</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Since both <span class="stt">3</span> and <span class="stt">4</span> are numbers, not behaviors, this
reduces to <span class="stt">(+ 3 4)</span>, which is precisely what we would like.
This reflects an important principle: when no behaviors are present,
programs behave exactly as they did in the non-reactive version of the
language.</div></p><p><div class="SIntrapara">If we compute <span class="stt">(+ 1 seconds)</span>, this expands to
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">if</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">or</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">behavior?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">behavior?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">seconds</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">behavior</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">current-value</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">current-value</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">seconds</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">seconds</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">seconds</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Because <span class="stt">seconds</span> is a behavior, this reduces to
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">behavior</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">current-value</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">current-value</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">seconds</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">seconds</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Any expression that depends on this now sees its argument also become
a behavior, making the property &ldquo;sticky&rdquo; as we argued before.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>In what way, if any, did the above desugaring depend on eager evaluation?</p></blockquote></div></p><h5>17.2.4.2<tt>&nbsp;</tt><a name="(part._.Dataflow_.Graph_.Update)"></a>Dataflow Graph Update</h5><p>Of course, simply constructing behavior values is not enough.  The key
additional information is in the extra arguments to <span class="stt">behavior</span>.
The language filters out those arguments that are themselves behaviors
(e.g., <span class="stt">seconds</span>, above) and registers this new behavior as one
of that depends on those existing ones.  This registration process
creates a graph of behavior expression dependencies,   known as a
<span style="font-style: italic">dataflow graph</span> (since it reflects the paths along which data
need to flow).</p><p>If the program did not evaluate to any behaviors, then evaluation
simply produces an answer, and there are no graphs created.  If,
however, there are behavior dependencies, then evaluation produces not
a traditional answer but a behavior value, with dependencies already
recorded.  (In practice, it is useful to also track which primitive
behaviors are actually necessary, to avoid unnecessarily evaluating
primitives that no other behavior in the program refers to.)  In
short, <span style="font-style: italic">program execution generates a dataflow graph</span>.  Thus, we
do not need a special, new evaluator for the language; we instead
embed the graph-construction semantics in traditional evaluation.</p><p>Now a dataflow propagation algorithm begins to execute.  Every time a
primitive behavior changes, the algorithm applies its stored thunk,
obtains its new value, stores it, and then signals each behavior
dependent on it.  For instance, if <span class="stt">seconds</span> updates, it notifies
the <span class="stt">(+ 1 seconds)</span> expression&rsquo;s behavior.  The latter behavior
now evaluates its thunk,
<span class="stt">(&#955; () (+ (current-value 1) (current-value seconds)))</span>.  This adds
<span class="stt">1</span> to the newest value of <span class="stt">seconds</span>, making that the new
value of this behavior&#8212;<wbr></wbr>just as we would expect.</p><h5>17.2.4.3<tt>&nbsp;</tt><a name="(part._.Evaluation_.Order)"></a>Evaluation Order</h5><p><div class="SIntrapara">The discussion above presents too simple a view of graph update.
Consider the following program:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">&gt;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">add1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">seconds</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">seconds</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This program has one primitive behavior, <span class="stt">seconds</span>, and
constructs two more: one for <span class="stt">(add1 seconds)</span> and one more
for the entire expression.</div></p><p>We would expect this expression to always be true.  However, when
<span class="stt">seconds</span> updates, depending on the order in which it handles
updates, it might update the whole expression before it does
<span class="stt">(add1 seconds)</span>.  Suppose the old value of <span class="stt">seconds</span> was
<span class="stt">100</span>, so the new one is <span class="stt">101</span>.  However, the node for
<span class="stt">(add1 seconds)</span> is still storing its old value (because it has
not yet been updated), so it holds <span class="stt">(add1 100)</span> or <span class="stt">101</span>.
That means the <span class="stt">&gt;</span> compares <span class="stt">101</span> with <span class="stt">1</span>, which is
false, making this expression return a value that should simply
never have ensued from its static description.  This situation is
called a <span style="font-style: italic">glitch</span>.</p><p>There is an easy solution to avoiding glitches, which the above
example illustrates (and that a theorem can show is sufficient).
This is to <span style="font-style: italic">topologically sort</span> the nodes.  Then, every node is
only processed after those it depends on have updated, so there is no danger
of seeing outdated or inconsistent values.</p><p>The problem becomes more difficult in the presence of cycles in the
graph.  In those cases, we need special recursion operators that can
take an initial value for the cyclic behavior.  This makes it possible
to break the cyclic dependency, reducing evaluation to the process that
has already been defined.</p><p>There is much more to say about the evaluation of dataflow languages,
such as the treatment of conditionals and a dual notion to behaviors
that is discrete and stream-like.  I hope you will read the literature
on reactive languages to learn more about these topics.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Earlier we picked on a Haskell library.  To be fair, however, the
reactive solution we have shown was enunciated in Haskell, whose lazy
evaluation makes this form of evaluation relatively easy to support.</p><p>Implement reactive evaluation using laziness.</p></blockquote></div></p><h4>17.3<tt>&nbsp;</tt><a name="(part._.Backtracking_.Application)"></a>Backtracking Application</h4><p>Another reason an application can occur multiple times is because it
is part of a <span style="font-style: italic">search tree</span>.  The language&rsquo;s application semantics
attempts to satisfy a search; if it succeeds it returns information
about the success, but if it fails, it retries applications in the
hope of succeeding.  This, of course, assumes that the program has
been written in terms of choices that can be tried until the search
succeeds.  Thus the central operation in a language with a
backtracking application semantics is <span style="font-style: italic">disjunction</span> (&ldquo;or&rdquo;).  For
a variety of reasons, such languages also include <span style="font-style: italic">conjunction</span>
(&ldquo;and&rdquo;), not least because negation can be problematic so the usual
rules of Boolean algebra don&rsquo;t apply.</p><h5>17.3.1<tt>&nbsp;</tt><a name="(part._.Searching_for_.Satisfaction)"></a>Searching for Satisfaction</h5><p>It is easiest to describe the problem of backtracking search in terms
of simple binary-valued goals.  With boolean variables, finding
satisfying assignments even for propositional formulas is
computationally challenging from a performance perspective, and
extremely important in a variety of real-world
problems.<span class="refelem"><span class="refcolumn"><span class="refcontent">Look for the numerous uses for &ldquo;SAT
solvers&rdquo;.</span></span></span>  We will, however, consider a restricted version of this
problem, where we given boolean constants, not variables, so all we
need to determine is truth of the formula.  This is only mildly
interesting, but it helps set up the actually interesting general
case.<span class="refelem"><span class="refcolumn"><span class="refcontent">For this special case we might as well just draw up
a truth table, but that won&rsquo;t work in the general case.</span></span></span></p><p>Suppose, therefore, that we are given a formula with conjunction,
disjunction, and constants representing truth and falsity.  Our goal
is to determine whether the formula itself evaluates to truth or
falsity.  We want to minimize computation, so that when we discover an
answer&#8212;<wbr></wbr>either one&#8212;<wbr></wbr>we want to return it as quickly as possible to
a context that depends on it.  For instance, if we are evaluating a
conjunction and discover that a term is false, we would like the
entire term to be false right away&#8212;<wbr></wbr>the familiar notion of
<span style="font-style: italic">short-circuit</span> evaluation of conditionals.  However, we want this
to generalize to the call-stack as well: if a sub-expression discovers
a truth or falsehood, and it matters to the enclosing expression, then
it should be reported &ldquo;up the stack&rdquo; quickly, as well.</p><p>In general, then, every computation should be parameterized by two
receptacles: one to which report truth of the current term (if it is
discovered) and the other to report falsity (if it is discovered).  To
avoid complications with pending function calls, etc., we will
furthermore expect that the values supplied for these two parameters
are both <span style="font-style: italic">continuations</span>, so that the value returns to the right
context as quickly as possible, instead of being scrutinized by
intermediate levels of evaluation that don&rsquo;t care about the result.</p><p>These continuations do not currently have any interesting values to
communicate: which continuation is invoked supplies all the
information there is (one bit, representing truth or falsehood).
Because by default continuations expect one argument, we will supply a
symbol that indicates what we already know.</p><p><div class="SIntrapara">The easiest values to see are truth and falsity itself.  Recall that
all expressions consume two continuations, called <span style="font-style: italic">success</span> and
<span style="font-style: italic">failure</span> continuations, and invoke one if they have a definitive
value.  The value for truth therefore invokes the success continuation
and that for falsity the failure one:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">truth</span><span class="hspace">&nbsp;</span><span class="RktMeta">t1</span><span class="hspace">&nbsp;</span><span class="RktMeta">t2</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">t1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">yes</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">falsity</span><span class="hspace">&nbsp;</span><span class="RktMeta">t1</span><span class="hspace">&nbsp;</span><span class="RktMeta">t2</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">t2</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">no</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>Let us now examine disjunction.  For simplicity, we will assume a
two-armed version of it.  Like all computations, the disjunction of
two backtracking searches must consume a success and a failure
continuation.</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctry-or-bt~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctry-or-bt~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;try-or-bt&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">try-or</span><span class="hspace">&nbsp;</span><span class="RktSym">t1</span><span class="hspace">&nbsp;</span><span class="RktSym">t2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lambda</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">success</span><span class="hspace">&nbsp;</span><span class="RktSym">failure</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3ctry-or-bt-body~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;try-or-bt-body&gt;</a><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>It is simplest, conceptually, to think of setting up two local
continuations, call them <span class="stt">pass</span> and <span class="stt">fail</span> to supply to the
evaluation of <span class="stt">t1</span>.  If <span class="stt">t1</span> (or, recursively, one of its
descendents) succeeds, control will return to the context of the
creation of <span class="stt">pass</span>; on failure, it will return to <span class="stt">fail</span>.</p><p>If it returns to <span class="stt">pass</span>, we now know that the first
sub-expression has already succeeded.  But because this is all that
matters for the disjunction to hold, we can now return control to the
continuation <span class="stt">success</span>.  Thus any invocation of <span class="stt">pass</span>
should immediately trigger <span class="stt">success</span>.</p><p>In contrast, suppose <span class="stt">t1</span> fails.  Then we should try <span class="stt">t2</span>.
Thus <span class="stt">fail</span> should be defined in a sequence that next tries
<span class="stt">t2</span>, on the expectation that had <span class="stt">t1</span> succeeded, control
would simply not return this way.  Now when trying <span class="stt">t2</span>, there is
no need to worry about <span class="stt">pass</span> and <span class="stt">fail</span>: after the failure
of <span class="stt">t1</span> the success and failure of the entire disjunction are the
same as those of <span class="stt">t2</span> (a form of tail position), so its success
and failure continuations are the same as that of the whole
expression.  As a result, we obtain:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctry-or-bt-body~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctry-or-bt-body~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;try-or-bt-body&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">success</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let/cc</span><span class="hspace">&nbsp;</span><span class="RktSym">pass</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">begin</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let/cc</span><span class="hspace">&nbsp;</span><span class="RktSym">fail</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">t1</span><span class="hspace">&nbsp;</span><span class="RktSym">pass</span><span class="hspace">&nbsp;</span><span class="RktSym">fail</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">t2</span><span class="hspace">&nbsp;</span><span class="RktSym">success</span><span class="hspace">&nbsp;</span><span class="RktSym">failure</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Thus if <span class="stt">t1</span> succeeds, control returns to the context of creating
<span class="stt">pass</span>, i.e., it invokes <span class="stt">success</span>.  If <span class="stt">t1</span> succeeds
control returns to the continuation of creating <span class="stt">fail</span>, which is
the next statement in the sequencing, which is <span class="stt">t2</span>.</p><p>By symmetric reasoning, we get the dual program for <span class="stt">try-and</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">try-and</span><span class="hspace">&nbsp;</span><span class="RktMeta">t1</span><span class="hspace">&nbsp;</span><span class="RktMeta">t2</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">success</span><span class="hspace">&nbsp;</span><span class="RktMeta">failure</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">failure</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let/cc</span><span class="hspace">&nbsp;</span><span class="RktMeta">fail</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let/cc</span><span class="hspace">&nbsp;</span><span class="RktMeta">pass</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">t1</span><span class="hspace">&nbsp;</span><span class="RktMeta">pass</span><span class="hspace">&nbsp;</span><span class="RktMeta">fail</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">t2</span><span class="hspace">&nbsp;</span><span class="RktMeta">success</span><span class="hspace">&nbsp;</span><span class="RktMeta">failure</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara">To convert these continuation-fed responses to simple, testable
values, we can write a convenient little wrapper:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">run</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let/cc</span><span class="hspace">&nbsp;</span><span class="RktMeta">escape</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">t</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">escape</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">yes</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">escape</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">no</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and with it construct test cases, from
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">run</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">try-or</span><span class="hspace">&nbsp;</span><span class="RktMeta">falsity</span><span class="hspace">&nbsp;</span><span class="RktMeta">falsity</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">no</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">to
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">run</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">try-or</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">try-and</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">try-or</span><span class="hspace">&nbsp;</span><span class="RktMeta">falsity</span><span class="hspace">&nbsp;</span><span class="RktMeta">truth</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">try-or</span><span class="hspace">&nbsp;</span><span class="RktMeta">truth</span><span class="hspace">&nbsp;</span><span class="RktMeta">falsity</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">try-and</span><span class="hspace">&nbsp;</span><span class="RktMeta">truth</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">try-and</span><span class="hspace">&nbsp;</span><span class="RktMeta">falsity</span><span class="hspace">&nbsp;</span><span class="RktMeta">truth</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">yes</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="contracts.html" title="backward to &quot;16 Checking Program Invariants Dynamically: Contracts&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>