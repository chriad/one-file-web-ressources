<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>13&nbsp;Desugaring as a Language Feature</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Introduction.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Everything__We_Will_Say__About_Parsing.html" class="tocviewlink" data-pltdoc="x">Everything (We Will Say) About Parsing</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="first-interp.html" class="tocviewlink" data-pltdoc="x">A First Look at Interpretation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="first-desugar.html" class="tocviewlink" data-pltdoc="x">A First Taste of Desugaring</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="adding-functions.html" class="tocviewlink" data-pltdoc="x">Adding Functions to the Language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="From_Substitution_to_Environments.html" class="tocviewlink" data-pltdoc="x">From Substitution to Environments</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="higher-order-functions.html" class="tocviewlink" data-pltdoc="x">Functions Anywhere</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="mut-struct-vs-var.html" class="tocviewlink" data-pltdoc="x">Mutation:<span class="mywbr"> &nbsp;</span> Structures and Variables</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="recursion.html" class="tocviewlink" data-pltdoc="x">Recursion and Cycles:<span class="mywbr"> &nbsp;</span> Procedures and Data</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Objects.html" class="tocviewlink" data-pltdoc="x">Objects</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Memory_Management.html" class="tocviewlink" data-pltdoc="x">Memory Management</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Representation_Decisions.html" class="tocviewlink" data-pltdoc="x">Representation Decisions</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Desugaring as a Language Feature</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Control_Operations.html" class="tocviewlink" data-pltdoc="x">Control Operations</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="types.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Statically:<span class="mywbr"> &nbsp;</span> Types</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="contracts.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Dynamically:<span class="mywbr"> &nbsp;</span> Contracts</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Alternate_Application_Semantics.html" class="tocviewlink" data-pltdoc="x">Alternate Application Semantics</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>13&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Desugaring as a Language Feature</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">13.1&nbsp;</td><td><a href="#%28part._.A_.First_.Example%29" class="tocviewlink" data-pltdoc="x">A First Example</a></td></tr><tr><td align="right">13.2&nbsp;</td><td><a href="#%28part._.Syntax_.Transformers_as_.Functions%29" class="tocviewlink" data-pltdoc="x">Syntax Transformers as Functions</a></td></tr><tr><td align="right">13.3&nbsp;</td><td><a href="#%28part._.Guards%29" class="tocviewlink" data-pltdoc="x">Guards</a></td></tr><tr><td align="right">13.4&nbsp;</td><td><a href="#%28part._.Or__.A_.Simple_.Macro_with_.Many_.Features%29" class="tocviewlink" data-pltdoc="x">Or:<span class="mywbr"> &nbsp;</span> A Simple Macro with Many Features</a></td></tr><tr><td align="right">13.5&nbsp;</td><td><a href="#%28part._.Identifier_.Capture%29" class="tocviewlink" data-pltdoc="x">Identifier Capture</a></td></tr><tr><td align="right">13.6&nbsp;</td><td><a href="#%28part._.Influence_on_.Compiler_.Design%29" class="tocviewlink" data-pltdoc="x">Influence on Compiler Design</a></td></tr><tr><td align="right">13.7&nbsp;</td><td><a href="#%28part._.Desugaring_in_.Other_.Languages%29" class="tocviewlink" data-pltdoc="x">Desugaring in Other Languages</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">13.1<tt>&nbsp;</tt></span><a href="#%28part._.A_.First_.Example%29" class="tocsubseclink" data-pltdoc="x">A First Example</a></td></tr><tr><td><span class="tocsublinknumber">13.2<tt>&nbsp;</tt></span><a href="#%28part._.Syntax_.Transformers_as_.Functions%29" class="tocsubseclink" data-pltdoc="x">Syntax Transformers as Functions</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3csc-macro-eg~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;sc-macro-eg&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3csc-macro-eg-body~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;sc-macro-eg-body&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3csc-macro-eg-rule~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;sc-macro-eg-rule&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">13.3<tt>&nbsp;</tt></span><a href="#%28part._.Guards%29" class="tocsubseclink" data-pltdoc="x">Guards</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3csc-macro-eg-guarded-rule~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;sc-macro-eg-guarded-rule&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">13.4<tt>&nbsp;</tt></span><a href="#%28part._.Or__.A_.Simple_.Macro_with_.Many_.Features%29" class="tocsubseclink" data-pltdoc="x">Or:<span class="mywbr"> &nbsp;</span> A Simple Macro with Many Features</a></td></tr><tr><td><span class="tocsublinknumber">13.4.1<tt>&nbsp;</tt></span><a href="#%28part._.A_.First_.Attempt%29" class="tocsubseclink" data-pltdoc="x">A First Attempt</a></td></tr><tr><td><span class="tocsublinknumber">13.4.2<tt>&nbsp;</tt></span><a href="#%28part._.Guarding_.Evaluation%29" class="tocsubseclink" data-pltdoc="x">Guarding Evaluation</a></td></tr><tr><td><span class="tocsublinknumber">13.4.3<tt>&nbsp;</tt></span><a href="#%28part._.Hygiene%29" class="tocsubseclink" data-pltdoc="x">Hygiene</a></td></tr><tr><td><span class="tocsublinknumber">13.5<tt>&nbsp;</tt></span><a href="#%28part._.Identifier_.Capture%29" class="tocsubseclink" data-pltdoc="x">Identifier Capture</a></td></tr><tr><td><span class="tocsublinknumber">13.6<tt>&nbsp;</tt></span><a href="#%28part._.Influence_on_.Compiler_.Design%29" class="tocsubseclink" data-pltdoc="x">Influence on Compiler Design</a></td></tr><tr><td><span class="tocsublinknumber">13.7<tt>&nbsp;</tt></span><a href="#%28part._.Desugaring_in_.Other_.Languages%29" class="tocsubseclink" data-pltdoc="x">Desugaring in Other Languages</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Representation_Decisions.html" title="backward to &quot;12 Representation Decisions&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Control_Operations.html" title="forward to &quot;14 Control Operations&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>13<tt>&nbsp;</tt><a name="(part._.Desugaring_as_a_.Language_.Feature)"></a>Desugaring as a Language Feature</h3><p><div class="SIntrapara">We have thus far extensively discussed and relied upon desugaring, but
our current desugaring mechanism have been weak.  We have actually
used desugaring in two different ways.  One, we have used it to
<span style="font-style: italic">shrink</span> the language: to take a large language and distill it
down to its core [REF].  But we have also used it to <span style="font-style: italic">grow</span> the
language: to take an existing language and add new features to it
[REF].  This just shows that desugaring is a tremendously useful
feature to have.  Indeed, it is so useful that we might ask two
questions:
</div><div class="SIntrapara"><ul><li><p>Because we create languages to simplify the creation of common
tasks, what would a language designed to support desugaring look
like?  Note that by &ldquo;look&rdquo; we don&rsquo;t mean only syntax but also its
key behavioral properties.</p></li><li><p>Given that general-purpose languages are often used as a
target for desugaring, why don&rsquo;t they offer desugaring capabilities
<span style="font-style: italic">in the language itself</span>?  For instance, this might mean
extending a base language with the additional language that is the
response to the previous question.</p></li></ul></div><div class="SIntrapara">We are going to explore the answer to both questions simultaneously,
by studying the facilities provided for this by Racket.</div></p><h4>13.1<tt>&nbsp;</tt><a name="(part._.A_.First_.Example)"></a>A First Example</h4><p><span class="refelem"><span class="refcolumn"><span class="refcontent">DrRacket has a very useful tool
called the Macro Stepper, which shows the step-by-step expansion of
programs.  You should try all the examples in this chapter using the
Macro Stepper.  For now, however, you should run them in
<span class="stt">#lang plai</span> rather than <span class="stt">#lang plai-typed</span>.</span></span></span></p><p><div class="SIntrapara">Remember that in [REF] we added <span class="stt">let</span> as syntactic sugar over
<span class="stt">lambda</span>.  The pattern we followed was this:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">body</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">is transformed into
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">body</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>If this doesn&rsquo;t sound familiar, now would be a good time to refresh
your memory of why this works.</p></blockquote></div></p><p><div class="SIntrapara">The simplest way of describing this transformation would be to state
it directly: to write, somehow,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">body</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">-&gt;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">body</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">In fact, this is almost precisely what Racket enables you to do.
<span class="refelem"><span class="refcolumn"><span class="refcontent">We&rsquo;ll use the name <span class="stt">my-let</span> instead of <span class="stt">let</span>
Because the latter is already defined in Racket.</span></span></span>
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta">my-let-1</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">syntax-rules</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">my-let-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">body</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">body</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara"><span class="stt">syntax-rules</span> tells Racket that whenever it sees an expression
with <span class="stt">my-let-1</span> immediately after the opening parenthesis, it
should check that it follows the pattern <span class="stt">(my-let-1 (var val)
body)</span>.
The <span class="stt">var</span>, <span class="stt">val</span> and <span class="stt">body</span> are
<span style="font-style: italic">syntactic variables</span>: they are variables that stand for bodies of
code.  In particular, they match whatever s-expression is in that
position.  If the expression matches the pattern, then the syntactic
variables are bound to the corresponding parts of the expression, and
become available for use in the right-hand side.<span class="refelem"><span class="refcolumn"><span class="refcontent">You may
have noticed some additional syntax, such as <span class="stt">()</span>.  We&rsquo;ll explain
this later.</span></span></span></div></p><p><div class="SIntrapara">The right-hand side&#8212;<wbr></wbr>in this case,
<span class="stt">((lambda (var) body) val)</span>&#8212;<wbr></wbr>is the output generated.  Each of
the syntactic variables are replaced with the corresponding parts of
the input using our old friend, substitution.  This substitution is
utterly simplistic: it makes no attempt to.  Thus, if we were to try
using it with
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">my-let-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Racket would not initially complain that <span class="stt">3</span> is provided in an
identifier position; rather, it would let the identifier percolate
through, desugaring this into
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">which in turn produces an error:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">lambda: expected either &lt;id&gt; or `[&lt;id&gt; : &lt;type&gt;]'</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">for function argument in: 3</span></p></td></tr></table></div></p><p>This immediately tells us that the desugaring process is
straightforward in its function: it doesn&rsquo;t attempt to guess or be
clever, but instead simply rewrites while substituting.  The output is
an expression that is again subject to desugaring.</p><p>As a matter of terminology, this simple form of expression-rewriting
is often called a <span style="font-style: italic">macro</span>, as we mentioned earlier in [REF].
Traditionally this form of desugaring is called macro <span style="font-style: italic">expansion</span>,
though this term is misleading because the output of desugaring can be
smaller than the input (though it is usually larger).</p><p><div class="SIntrapara">Of course, in Racket, a <span class="stt">let</span> can bind multiple identifiers, not
just one.  If we were to write this informally, say on a board, we
might write something like
<span class="stt">(let ([var val] ...) body)
-&gt;
((lambda (var ...) body) val ...)</span>
with the <span class="stt">...</span> meaning &ldquo;zero or more&rdquo;, and the intent being
that the <span class="stt">var ...</span> in the output should correspond to the
sequence of <span class="stt">var</span>s in the input.  Again, this is almost precisely
Racket syntax:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta">my-let-2</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">syntax-rules</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">my-let-2</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">var</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">body</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">body</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Observe the power of the <span class="stt">...</span> notation: the sequence of
&ldquo;pairs&rdquo; in the input is turned into a pair of sequences in the
output; put differently, Racket &ldquo;unzips&rdquo; the input sequence.
Conversely, this same notation can be used to zip together sequences.</div></p><h4>13.2<tt>&nbsp;</tt><a name="(part._.Syntax_.Transformers_as_.Functions)"></a>Syntax Transformers as Functions</h4><p>Earlier we saw that <span class="stt">my-let-1</span> does not even attempt to ensure
that the syntax in the identifier position is truly (i.e.,
syntactically) an identifier.  We cannot remedy that with the
<span class="stt">syntax-rules</span> mechanism, but we can with a much more powerful
mechanism called <span class="stt">syntax-case</span>.  Because <span class="stt">syntax-case</span>
exhibits many other useful features as well, we&rsquo;ll introduce it and
then grow it gradually.</p><p><div class="SIntrapara">The first thing to understand is that a macro is actually a
<span style="font-style: italic">function</span>.  It is not, however, a function from regular run-time
values to other run-time values, but rather a function
<span style="font-style: italic">from syntax to syntax</span>.  These functions execute in a world
whose purpose is to <span style="font-style: italic">create the program to execute</span>.
Observe that we&rsquo;re talking about the program <span style="font-style: italic">to</span> execute: the
actual execution of the program may only occur much later (or never at
all).  This point is actually extremely clear when we examine
desugaring, which is very explicitly a function from (one kind of)
syntax to (another kind of) syntax.  This is perhaps obscured above in
two ways:
</div><div class="SIntrapara"><ul><li><p>The notation of <span class="stt">syntax-rules</span>, with no explicit
parameter name or other &ldquo;function header&rdquo;, may not make clear that
it is a functional transformation (though the rewriting rule format
does allude to this fact).</p></li><li><p>In desugaring, we specify one atomic function for the entire
process.  Here, we are actually writing several little functions,
one for each kind of new syntactic construct (such as
<span class="stt">my-let-1</span>), and these pieces are woven together by an
invisible function that controls the overall rewriting process.  (As
a concrete example, it is not inherently clear that the output of a
macro is expanded further&#8212;<wbr></wbr>though a simple example immediately
demonstrates that this is indeed the case.)</p></li></ul></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Write one or more macros to confirm that the output of a macro is
expanded further.</p></blockquote></div></p><p>There is one more subtlety.  Because the form of a macro looks rather
like Racket code, it is not immediately clear that it &ldquo;lives in
another world&rdquo;.  In the abstract, it may be helpful to imagine that
the macro definitions are actually written in an entirely different
language that processes only syntax.  This simplicity is, however,
misleading.  In practice, program transformers&#8212;<wbr></wbr>also called
<span style="font-style: italic">compilers</span>&#8212;<wbr></wbr>are full-blown programs, too, and need all the power
of ordinary programs.  This would have necessitated the creation of a
parallel language purely for processing programs.  This would be
wasteful and pointless; therefore, Racket instead endows
syntax-transforming programs with the full power of Racket itself.</p><p>With that prelude, let&rsquo;s now introduce <span class="stt">syntax-case</span>.  We&rsquo;ll
begin by simply rewriting <span class="stt">my-let-1</span> (under the name
<span class="stt">my-let-3</span>) using this new notation.  First, we have to write a
header for the definition; notice already the explicit parameter:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3csc-macro-eg~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3csc-macro-eg~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;sc-macro-eg&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define-syntax</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">my-let-3</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3csc-macro-eg-body~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;sc-macro-eg-body&gt;</a><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>This binds <span class="stt">x</span> to the entire <span class="stt">(my-let-3 ...)</span> expression.</p><p>As you might imagine, <span class="stt">define-syntax</span> simply tells Racket you&rsquo;re
about to define a new macro.  It does not pick precisely how you want
to implement it, leaving you free to use any mechanism that&rsquo;s
convenient.  Earlier we used <span class="stt">syntax-rules</span>; now we&rsquo;re going to
use <span class="stt">syntax-case</span>.  In particular, <span class="stt">syntax-case</span> needs to
explicitly be given access to the expression to pattern-match:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3csc-macro-eg-body~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3csc-macro-eg-body~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;sc-macro-eg-body&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">syntax-case</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3csc-macro-eg-rule~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;sc-macro-eg-rule&gt;</a><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Now we&rsquo;re ready to express the rewrite we wanted.  Previously a
rewriting rule had two parts: the structure of the input and the
corresponding output.  The same holds here.  The first (matching the
input) is the same as before, but the second (the output) is a little
different:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3csc-macro-eg-rule~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3csc-macro-eg-rule~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;sc-macro-eg-rule&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">my-let-3</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">lambda</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">var</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>Observe the crucial extra characters: <span class="stt">#</span><span class="stt">&rsquo;</span><span class="stt"></span>.  Let&rsquo;s examine what
that means.</p><p>In <span class="stt">syntax-rules</span>, the entire output part simply specifies the
structure of the output.  In contrast, because <span class="stt">syntax-case</span> is
laying bare the functional nature of transformation, the output part
is in fact an arbitrary expression that may perform any computations
it wishes.  It must simply evaluate to a piece of syntax.</p><p>Syntax is actually a distinct datatype.  As with any distinct dataype,
it has its own rules for construction.  Concretely, we construct
syntax values by writing <span class="stt">#</span><span class="stt">&rsquo;</span><span class="stt"></span>; the following s-expression is
treated as a syntax value.  (In case you were wondering, the <span class="stt">x</span>
bound in the macro definition above is also of this datatype.)</p><p>The syntax constructor, <span class="stt">#</span><span class="stt">&rsquo;</span><span class="stt"></span>, enjoys a special property.  Inside
the output part of the macro, all syntax variables in the input are
automatically bound, and replaced on occurrence.  As a result, when
the expander encounters <span class="stt">var</span> in the output, say, it replaces
<span class="stt">var</span> with the corresponding part of the input expression.</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Remove the <span class="stt">#</span><span class="stt">&rsquo;</span><span class="stt"></span> and try using the above macro definition.  What
happens?</p></blockquote></div></p><p>So far, <span class="stt">syntax-case</span> merely appears to be a more complicated
form of <span class="stt">syntax-rules</span>: perhaps slightly better in that it more
cleanly delineates the functional nature of expansion, and the type of
output, but otherwise simply more unwieldy.  As we will see, however,
it also offers significant power.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p><span class="stt">syntax-rules</span> can actually be expressed as a <span style="font-style: italic">macro</span> over
<span class="stt">syntax-case</span>.  Define it.</p></blockquote></div></p><h4>13.3<tt>&nbsp;</tt><a name="(part._.Guards)"></a>Guards</h4><p>Now we can return to the problem that originally motivated the
introduction of <span class="stt">syntax-case</span>: ensuring that the binding
position of a <span class="stt">my-let-3</span> is syntactically an identifier.  For
this, you need to know one new feature of <span class="stt">syntax-case</span>: each
rewriting rule can have two parts (as above), or three.  If there are
three present, the <span style="font-style: italic">middle</span> one is treated as a <span style="font-style: italic">guard</span>: a
predicate that must evaluate to true for expansion to proceed rather
than signal a syntax error.  Especially useful in this context is the
predicate <span class="stt">identifier?</span>, which determines whether a syntax object
is syntactically an identifier (or variable).</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Write the guard and rewrite the rule to incorporate it.</p></blockquote></div></p><p><div class="SIntrapara">Hopefully you stumbled on a subtlety: the argument to
<span class="stt">identifier?</span> is of type <span style="font-style: italic">syntax</span>.  It needs to refer to the
actual fragment of syntax bound to <span class="stt">var</span>.  Recall that <span class="stt">var</span>
is bound in the syntax space, and <span class="stt">#</span><span class="stt">&rsquo;</span><span class="stt"></span> substitutes identifiers
bound there.  Therefore, the correct way to write the guard is:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">identifier?</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktMeta">var</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">With this information, we can now write the entire rule:</div></p><p><div class="SIntrapara"><a name="(elem._(chunk._~3csc-macro-eg-guarded-rule~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3csc-macro-eg-guarded-rule~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;sc-macro-eg-guarded-rule&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">my-let-3</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">identifier?</span><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktSym">var</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">lambda</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">var</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Now that you have a guarded rule definition, try to use the macro with
a non-identifier in the binding position and see what happens.</p></blockquote></div></p><h4>13.4<tt>&nbsp;</tt><a name="(part._.Or__.A_.Simple_.Macro_with_.Many_.Features)"></a>Or: A Simple Macro with Many Features</h4><p>Consider <span class="stt">or</span>, which implements disjunction.  It is natural, with
prefix syntax, to allow <span class="stt">or</span> to have an arbitrary number of
sub-terms.  We expand <span class="stt">or</span> into nested conditionals that
determine the truth of the expression.</p><h5>13.4.1<tt>&nbsp;</tt><a name="(part._.A_.First_.Attempt)"></a>A First Attempt</h5><p><div class="SIntrapara">Let&rsquo;s try a first version of <span class="stt">or</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">my-or-1</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">syntax-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">my-or-1</span><span class="hspace">&nbsp;</span><span class="RktMeta">e0</span><span class="hspace">&nbsp;</span><span class="RktMeta">e1</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta">e0</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">e0</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">my-or-1</span><span class="hspace">&nbsp;</span><span class="RktMeta">e1</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">It says that we can provide any number of sub-terms (more on this in a
moment).  Expansion rewrites this into a conditional that tests the
first sub-term; if this is a true value it returns that value (more on
<span style="font-style: italic">this</span> in a moment!), otherwise it is the disjunction of the
remaining terms.</div></p><p><div class="SIntrapara">Let&rsquo;s try this on a simple example.  We would expect this to evaluate
to <span class="stt">true</span>, but instead:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (my-or-1 #f #t)</span></p></td></tr><tr><td><p><span class="stt">my-or-1: bad syntax in: (my-or-1)</span></p></td></tr></table></div><div class="SIntrapara">What happened?  This expression turned into
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">my-or-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">which in turn expanded into
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">my-or-1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">for which there is no definition.  That&rsquo;s because the pattern
<span class="stt">e0 e1 ...</span> means <span style="font-style: italic">one or more</span> sub-terms, but we ignored the
case when there are zero.</div></p><p>What <span style="font-style: italic">should</span> happen when there are no sub-terms?
The identity for disjunction is falsehood.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Why is <span class="stt">#f</span> the right default?</p></blockquote></div></p><p><div class="SIntrapara">By filling it in below, we illustrate a macro that has more than one
rule.  Macro rules are matched sequentially, so we should be sure to
put the most specific rules first, lest they get overridden by more
general ones (though in this particular case, the two rules are
non-overlapping).  This yields our improved macro:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">my-or-2</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">syntax-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">my-or-2</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktVal">#f</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">my-or-2</span><span class="hspace">&nbsp;</span><span class="RktMeta">e0</span><span class="hspace">&nbsp;</span><span class="RktMeta">e1</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta">e0</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">e0</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">my-or-2</span><span class="hspace">&nbsp;</span><span class="RktMeta">e1</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">which now expands as we expect.  Though it isn&rsquo;t necessary, we will
add a rule for the case when there is only a single sub-term:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">my-or-3</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">syntax-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">my-or-3</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktVal">#f</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">my-or-3</span><span class="hspace">&nbsp;</span><span class="RktMeta">e</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktMeta">e</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">my-or-3</span><span class="hspace">&nbsp;</span><span class="RktMeta">e0</span><span class="hspace">&nbsp;</span><span class="RktMeta">e1</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta">e0</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">e0</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">my-or-3</span><span class="hspace">&nbsp;</span><span class="RktMeta">e1</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This keeps the output of expansion more concise, which we will find
useful below.<span class="refelem"><span class="refcolumn"><span class="refcontent">Observe that in this version of the macro, the
patterns are <span style="font-style: italic">not</span> disjoint: the third (one-or-more sub-terms)
subsumes the second (one sub-term).  Therefore, it is essential that
the second rule not swap with the third.</span></span></span></div></p><h5>13.4.2<tt>&nbsp;</tt><a name="(part._.Guarding_.Evaluation)"></a>Guarding Evaluation</h5><p><div class="SIntrapara">We said above that this expands as we expect.
Or does it?  Let&rsquo;s try the following example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">init</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">my-or-3</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">init</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">not</span><span class="hspace">&nbsp;</span><span class="RktMeta">init</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">init</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Observe that <span class="stt">or</span> returns the actual value of the first
&ldquo;truthy&rdquo; value, so the developer can use it in further
computations.  Therefore, this returns the value of <span class="stt">init</span>.  What
do we expect it to be?  Naturally, because we&rsquo;ve negated the value of
<span class="stt">init</span> once, we expect it to be <span class="stt">#t</span>.  But evaluating it
produces <span class="stt">#f</span>!
<span class="refelem"><span class="refcolumn"><span class="refcontent">This problem is not an artifact of <span class="stt">set!</span>.  If
instead of internal mutation we had, say, printed output, the printing
would have occurred twice.</span></span></span></div></p><p><div class="SIntrapara">To understand why, we have to examine the expanded code.  It is this:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">init</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">init</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">not</span><span class="hspace">&nbsp;</span><span class="RktMeta">init</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">init</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">init</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">not</span><span class="hspace">&nbsp;</span><span class="RktMeta">init</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">init</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Aha!  Because we&rsquo;ve written the output pattern as
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktVal">#'</span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta">e0</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">e0</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This looked entirely benign when we first wrote it, but it illustrates
a very important principle when writing macros (or indeed any other
program transformation systems): <span style="font-style: italic">do not copy code</span>!  In our
setting, a syntactic variable should never be repeated; if you need to
repeat it in a way that might cause multiple execution of that code,
make sure you have considered the consequences of this.
Alternatively, if you meant to work with the <span style="font-style: italic">value</span> of the
expression, bind it once and use the bound identifier&rsquo;s name
subsequently.  This is easy to demonstrate:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">my-or-4</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">syntax-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">my-or-4</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktVal">#f</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">my-or-4</span><span class="hspace">&nbsp;</span><span class="RktMeta">e</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktMeta">e</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">my-or-4</span><span class="hspace">&nbsp;</span><span class="RktMeta">e0</span><span class="hspace">&nbsp;</span><span class="RktMeta">e1</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta">e0</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">v</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">my-or-4</span><span class="hspace">&nbsp;</span><span class="RktMeta">e1</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This pattern of introducing a binding creates a new potential problem:
you may end up evaluating expressions that weren&rsquo;t necessary.  In
fact, it creates a second, even more subtle one: even if it going to
be evaluated, you may evaluate it in the wrong context!
Therefore, you have to reason carefully about <span style="font-style: italic">whether</span> an
expression will be evaluated, and if so, evaluate it once in just the
right place, then store that value for subsequent use.</div></p><p>When we repeat our previous example, that contained the <span class="stt">set!</span>,
with <span class="stt">my-or-4</span>, we see that the result is <span class="stt">#t</span>, as we would
have hoped.</p><h5>13.4.3<tt>&nbsp;</tt><a name="(part._.Hygiene)"></a>Hygiene</h5><p>Hopefully now you&rsquo;re nervous about something else.</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>What?</p></blockquote></div></p><p><div class="SIntrapara">Consider the macro <span class="stt">(let ([v #t]) (my-or-4 #f v))</span>.  What would
we expect this to compute?  Naturally, <span class="stt">#t</span>: the first branch is
<span class="stt">#f</span> but the second is <span class="stt">v</span>, which is bound to <span class="stt">#t</span>.
But let&rsquo;s look at the expansion:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">v</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This expression, when run directly, evaluates to <span class="stt">#f</span>.  However,
<span class="stt">(let ([v #t]) (my-or-4 #f v))</span> evaluates to <span class="stt">#t</span>.  In other
words, the macro seems to magically produce the right value: the names
of identifiers chosen in the macro seem to be independent of those
introduced by the macro!  This is unsurprising when it happens in a
<span style="font-style: italic">function</span>; the macro expander enjoys a property called
<span style="font-style: italic">hygiene</span> that gives it the same property.</div></p><p><div class="SIntrapara">One way to think about hygiene is that it effectively automatically
renames all bound identifiers.  That is, it&rsquo;s as if the program
expands as follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">or</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">turns into
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">v1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">or</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">v1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">(notice the <span style="font-style: italic">consistent</span> renaming of <span class="stt">v</span> to <span class="stt">v1</span>),
which turns into
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">v1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">v</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">v1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">which, after renaming, becomes
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">v1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">v2</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">v2</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">v1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">when expansion terminates.  Observe that each of the programs above,
if run directly, will produce the correct answer.</div></p><h4>13.5<tt>&nbsp;</tt><a name="(part._.Identifier_.Capture)"></a>Identifier Capture</h4><p><div class="SIntrapara">Hygienic macros address a routine and important pain that creators of
syntactic sugar confront.  On rare instances, however, a developer
wants to intentionally break hygiene.  Returning to objects, consider
this input program:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">os-1</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">object/self-1</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">second</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">second</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">What does the macro look like?  Here&rsquo;s an obvious candidate:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta">object/self-1</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">syntax-rules</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">object</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">mtd-name</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg-name</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">error</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">object</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"nothing</span><span class="hspace">&nbsp;</span><span class="RktVal">here"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">msg</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">mtd-name</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">self</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Unfortunately, this macro produces the following error:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">self: unbound identifier in module in: self</span></p></td></tr></table></div><div class="SIntrapara">which is referring to the <span class="stt">self</span> in the body of the method bound
to <span class="stt">first</span>.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Work through the hygienic expansion process to understand why error is
the expected outcome.</p></blockquote></div></p><p><div class="SIntrapara">Before we solve this directly, let&rsquo;s consider a variant of the
input term that makes the binding explicit:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">os-2</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">object/self-2</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">second</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">second</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">The corresponding macro is a small variation on what we had before:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta">object/self-2</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">syntax-rules</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">object</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">mtd-name</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg-name</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">error</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">object</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"nothing</span><span class="hspace">&nbsp;</span><span class="RktVal">here"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">msg</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">mtd-name</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">self</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This macro expands without difficulty.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Work through the expansion of this version and see what&rsquo;s different.</p></blockquote></div></p><p><div class="SIntrapara">This offers a critical insight: <span style="font-style: italic">had the identifier that goes in
the binding position been written
by the macro user</span>, there would have been no problem.  Therefore, we
want to be able to <span style="font-style: italic">pretend</span> that the introduced identifier was
written by the user.  The function <span class="stt">datum-&gt;syntax</span> converts
the s-expression in its second argument; its first argument is which
syntax to pretend it was a part of (in our case, the original macro
use, which is bound to <span class="stt">x</span>).  To introduce the result into the
environment used for expansion, we use <span class="stt">with-syntax</span> to bind it
in that environment:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">object/self-3</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">syntax-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">object</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">mtd-name</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">with-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">datum-&gt;syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">self</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg-name</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">error</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">object</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"nothing</span><span class="hspace">&nbsp;</span><span class="RktVal">here"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg-name</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">msg-name</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">mtd-name</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">self</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">With this, we can go back to having <span class="stt">self</span> be implicit:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">os-3</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">object/self-3</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">second</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">second</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><h4>13.6<tt>&nbsp;</tt><a name="(part._.Influence_on_.Compiler_.Design)"></a>Influence on Compiler Design</h4><p>The use of macros in a language&rsquo;s definition has an impact on all
tools, especially compilers.  As a working example, consider
<span class="stt">let</span>.  <span class="stt">let</span> has the virtue that it can be compiled
efficiently, by just extending the current environment.  In contrast,
the expansion of <span class="stt">let</span> into function application results in a
much more expensive operation: the creation of a closure and its
application to the argument, achieving effectively the same result but
at the cost of more time (and often space).</p><p>This would seem to be an argument against using the macro.  However, a
smart compiler recognizes that this pattern occurs often, and instead
internally effectively converts left-left-lambda [REF] back into the
equivalent of <span class="stt">let</span>.  This has two advantages.  First, it means
the language designer can freely use macros to obtain a smaller core
language, rather than having to trade that off against the execution
cost.</p><p>It has a second, much subtler, advantage.  Because the compiler
recognizes this pattern, <span style="font-style: italic">other</span> macros can also exploit it and
obtain the same optimization; they don&rsquo;t need to contort their output
to insert <span class="stt">let</span> terms if the left-left-lambda pattern occurs
naturally, as they would have to do otherwise.  For instance, the
left-left-lambda pattern occurs naturally when writing certain kinds
of pattern-matchers, but it would take an extra step to convert this
into a <span class="stt">let</span> in the expansion&#8212;<wbr></wbr>which is no longer necessary.</p><h4>13.7<tt>&nbsp;</tt><a name="(part._.Desugaring_in_.Other_.Languages)"></a>Desugaring in Other Languages</h4><p><div class="SIntrapara">Many modern languages define operations via desugaring, not only
Racket.  In Python, for instance, iterating using <span class="stt">for</span> is simply
a syntactic pattern.  A developer who writes <span class="stt">for x in o</span> is
</div><div class="SIntrapara"><ul><li><p>introducing a new identifier (call it <span class="stt">i</span>&#8212;<wbr></wbr>but be sure
to not capture any other <span class="stt">i</span> the programmer has already
defined, i.e., bind <span class="stt">i</span> hygienically!),</p></li><li><p>binding it to an iterator obtained from <span class="stt">o</span>, and</p></li><li><p>creating a (potentially) infinite <span class="stt">while</span> loop that
repeatedly invokes the <span class="stt">.next</span> method of <span class="stt">i</span> until the
iterator raises the <span class="stt">StopIteration</span> exception.</p></li></ul></div><div class="SIntrapara">There are many such patterns in modern programming languages.</div></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Representation_Decisions.html" title="backward to &quot;12 Representation Decisions&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Control_Operations.html" title="forward to &quot;14 Control Operations&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>