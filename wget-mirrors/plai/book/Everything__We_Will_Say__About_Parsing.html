<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>2&nbsp;Everything (We Will Say) About Parsing</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Introduction.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Everything (We Will Say) About Parsing</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="first-interp.html" class="tocviewlink" data-pltdoc="x">A First Look at Interpretation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="first-desugar.html" class="tocviewlink" data-pltdoc="x">A First Taste of Desugaring</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="adding-functions.html" class="tocviewlink" data-pltdoc="x">Adding Functions to the Language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="From_Substitution_to_Environments.html" class="tocviewlink" data-pltdoc="x">From Substitution to Environments</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="higher-order-functions.html" class="tocviewlink" data-pltdoc="x">Functions Anywhere</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="mut-struct-vs-var.html" class="tocviewlink" data-pltdoc="x">Mutation:<span class="mywbr"> &nbsp;</span> Structures and Variables</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="recursion.html" class="tocviewlink" data-pltdoc="x">Recursion and Cycles:<span class="mywbr"> &nbsp;</span> Procedures and Data</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Objects.html" class="tocviewlink" data-pltdoc="x">Objects</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Memory_Management.html" class="tocviewlink" data-pltdoc="x">Memory Management</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Representation_Decisions.html" class="tocviewlink" data-pltdoc="x">Representation Decisions</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Desugaring_as_a_Language_Feature.html" class="tocviewlink" data-pltdoc="x">Desugaring as a Language Feature</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Control_Operations.html" class="tocviewlink" data-pltdoc="x">Control Operations</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="types.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Statically:<span class="mywbr"> &nbsp;</span> Types</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="contracts.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Dynamically:<span class="mywbr"> &nbsp;</span> Contracts</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Alternate_Application_Semantics.html" class="tocviewlink" data-pltdoc="x">Alternate Application Semantics</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Everything (We Will Say) About Parsing</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="#%28part._.A_.Lightweight__.Built-.In_.First_.Half_of_a_.Parser%29" class="tocviewlink" data-pltdoc="x">A Lightweight, Built-<wbr></wbr>In First Half of a Parser</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="#%28part._.A_.Convenient_.Shortcut%29" class="tocviewlink" data-pltdoc="x">A Convenient Shortcut</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="#%28part._.Types_for_.Parsing%29" class="tocviewlink" data-pltdoc="x">Types for Parsing</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="#%28part._first-parser%29" class="tocviewlink" data-pltdoc="x">Completing the Parser</a></td></tr><tr><td align="right">2.5&nbsp;</td><td><a href="#%28part._.Coda%29" class="tocviewlink" data-pltdoc="x">Coda</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.A_.Lightweight__.Built-.In_.First_.Half_of_a_.Parser%29" class="tocsubseclink" data-pltdoc="x">A Lightweight, Built-<wbr></wbr>In First Half of a Parser</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.A_.Convenient_.Shortcut%29" class="tocsubseclink" data-pltdoc="x">A Convenient Shortcut</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._.Types_for_.Parsing%29" class="tocsubseclink" data-pltdoc="x">Types for Parsing</a></td></tr><tr><td><span class="tocsublinknumber">2.4<tt>&nbsp;</tt></span><a href="#%28part._first-parser%29" class="tocsubseclink" data-pltdoc="x">Completing the Parser</a></td></tr><tr><td><span class="tocsublinknumber">2.5<tt>&nbsp;</tt></span><a href="#%28part._.Coda%29" class="tocsubseclink" data-pltdoc="x">Coda</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Introduction.html" title="backward to &quot;1 Introduction&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="first-interp.html" title="forward to &quot;3 A First Look at Interpretation&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>2<tt>&nbsp;</tt><a name="(part._.Everything__.We_.Will_.Say__.About_.Parsing)"></a>Everything (We Will Say) About Parsing</h3><p><div class="SIntrapara">Parsing is the act of turning an input character stream into a more
structured, internal representation.  A common internal representation
is as a tree, which programs can recursively process.
For instance, given the stream
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">23 + 5 - 6</span></p></td></tr></table></div><div class="SIntrapara">we might want a tree representing addition whose left node represents
the number <span class="stt">23</span> and whose right node represents subtraction of
<span class="stt">6</span> from <span class="stt">5</span>.  A <span style="font-style: italic">parser</span> is responsible for performing this
transformation.</div></p><p>Parsing is a large, complex problem that is far from solved due to the
difficulties of ambiguity.  For instance, an alternate parse tree for
the above input expression might put subtraction at the top and
addition below it.  We might also want to consider whether this
addition operation is commutative and hence whether the order of
arguments can be switched.  Everything only gets much, much worse when
we get to full-fledged programming languages (to say nothing of
natural languages).</p><h4>2.1<tt>&nbsp;</tt><a name="(part._.A_.Lightweight__.Built-.In_.First_.Half_of_a_.Parser)"></a>A Lightweight, Built-In First Half of a Parser</h4><p><div class="SIntrapara">These problems make parsing a worthy topic in its own right, and
entire books, tools, and courses are devoted to it.  However, from our
perspective parsing is mostly a distraction, because we want to study
the parts of programming languages that are <span style="font-style: italic">not</span> parsing.  We
will therefore exploit a handy feature of Racket to manage the
transformation of input streams into trees: <span class="stt">read</span>.  <span class="stt">read</span>
is tied to the parenthetical form of the language, in that it parses
fully (and hence unambiguously) parenthesized terms into a built-in
tree form.  For instance, running <span class="stt">(read)</span> on the parenthesized
form of the above input&#8212;<wbr></wbr>
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">(+ 23 (- 5 6))</span></p></td></tr></table></div><div class="SIntrapara">&#8212;<wbr></wbr>will produce a list, whose first element is the symbol <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">+</span>,
second element is the number <span class="stt">23</span>, and third element is a list;
this list&rsquo;s first element is the symbol <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">-</span>, second element is
the number <span class="stt">5</span>, and third element is the number <span class="stt">6</span>.</div></p><h4>2.2<tt>&nbsp;</tt><a name="(part._.A_.Convenient_.Shortcut)"></a>A Convenient Shortcut</h4><p>As you know you need to test your programs extensively, which is hard
to do when you must manually type terms in over and over again.
Fortunately, as you might expect, the parenthetical syntax is
integrated deeply into Racket through the mechanism of
<span style="font-style: italic">quotation</span>.  That is, <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">&lt;expr&gt;</span>&#8212;<wbr></wbr>which you saw a moment ago
in the above example&#8212;<wbr></wbr>acts as if you had run
<span class="stt">(read)</span> and typed <span class="stt">&lt;expr&gt;</span> at the prompt (and, of course,
evaluates to the value the <span class="stt">(read)</span> would have).</p><h4>2.3<tt>&nbsp;</tt><a name="(part._.Types_for_.Parsing)"></a>Types for Parsing</h4><p><div class="SIntrapara">Actually, I&rsquo;ve lied a little.  I said that <span class="stt">(read</span>)&#8212;<wbr></wbr>or
equivalently, using quotation&#8212;<wbr></wbr>will produce a list, etc.  That&rsquo;s true
in regular Racket, but in Typed PLAI, the type it
returns a distinct type called an <span style="font-style: italic">s-expression</span>, written in Typed
PLAI as <span class="stt">s-expression</span>:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (read)</span></p></td></tr><tr><td><p><span class="stt">- s-expression</span></p></td></tr><tr><td><p><span class="stt">[type in (+ 23 (- 5 6))]</span></p></td></tr><tr><td><p><span class="stt">'(+ 23 (- 5 6))</span></p></td></tr></table></div><div class="SIntrapara">Racket has a very rich language of s-expressions (it even has notation
to represent cyclic structures), but we will use only the simple
fragment of it.</div></p><p>In the typed language, an s-expression is treated distinctly from the
other types, such as numbers and lists.  Underneath, an s-expression
is a large recursive datatype that consists of all the base printable
values&#8212;<wbr></wbr>numbers, strings, symbols, and so on&#8212;<wbr></wbr>and printable
collections (lists, vectors, etc.) of s-expressions.  As a result,
base types like numbers, symbols, and strings are <span style="font-style: italic">both</span> their
own type and an instance of s-expression.  Typing such data can be
fairly problematic, as we will discuss later [REF].</p><p><div class="SIntrapara">Typed PLAI takes a simple approach.  When written on their own, values
like numbers are of those respective types.  But when
written inside a complex s-expression&#8212;<wbr></wbr>in particular, as created by
<span class="stt">read</span> or quotation&#8212;<wbr></wbr>they have type <span class="stt">s-expression</span>.  You
have to then <span style="font-style: italic">cast</span> them to their native types.  For instance:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; '+</span></p></td></tr><tr><td><p><span class="stt">- symbol</span></p></td></tr><tr><td><p><span class="stt">'+</span></p></td></tr><tr><td><p><span class="stt">&gt; (define l '(+ 1 2))</span></p></td></tr><tr><td><p><span class="stt">&gt; l</span></p></td></tr><tr><td><p><span class="stt">- s-expression</span></p></td></tr><tr><td><p><span class="stt">'(+ 1 2)</span></p></td></tr><tr><td><p><span class="stt">&gt; (first l)</span></p></td></tr><tr><td><p><span class="stt">. typecheck failed: (listof '_a) vs s-expression in:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">first</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(quote (+ 1 2))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">l</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">first</span></p></td></tr><tr><td><p><span class="stt">&gt; (define f (first (s-exp-&gt;list l)))</span></p></td></tr><tr><td><p><span class="stt">&gt; f</span></p></td></tr><tr><td><p><span class="stt">- s-expression</span></p></td></tr><tr><td><p><span class="stt">'+</span></p></td></tr></table></div><div class="SIntrapara">This is similar to the casting that a Java programmer would have
to insert.  We will study casting itself later [REF].</div></p><p><div class="SIntrapara">Observe that the first element of the list is still not treated by the
type checker as a symbol: a list-shaped s-expression is a list of
<span style="font-style: italic">s-expressions</span>.  Thus,
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (symbol-&gt;string f)</span></p></td></tr><tr><td><p><span class="stt">. typecheck failed: symbol vs s-expression in:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">symbol-&gt;string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">f</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">symbol-&gt;string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">f</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">first</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(first (s-exp-&gt;list l))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">s-exp-&gt;list</span></p></td></tr></table></div><div class="SIntrapara">whereas again, casting does the trick:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (symbol-&gt;string (s-exp-&gt;symbol f))</span></p></td></tr><tr><td><p><span class="stt">- string</span></p></td></tr><tr><td><p><span class="stt">"+"</span></p></td></tr></table></div><div class="SIntrapara">The need to cast s-expressions is a bit of a nuisance, but some
complexity is unavoidable because of what we&rsquo;re trying to accomplish:
to convert an <span style="font-style: italic">untyped</span> input stream into a <span style="font-style: italic">typed</span> output
stream through robustly <span style="font-style: italic">typed</span> means.  Somehow we have to make
explicit our assumptions about that input stream.</div></p><p>Fortunately we will use s-expressions only in our parser, and our goal
is to <span style="font-style: italic">get away from parsing as quickly as possible</span>!
Indeed, if anything this should be inducement to get away even
quicker.</p><h4>2.4<tt>&nbsp;</tt><a name="(part._first-parser)"></a>Completing the Parser</h4><p>In principle, we can think of <span class="stt">read</span> as a complete parser.
However, its output is generic: it represents the token structure
without offering any comment on its intent.  We would instead prefer
to have a representation that tells us something about the
<span style="font-style: italic">intended meaning</span> of the terms in our language, just as we wrote
at the very beginning: &ldquo;representing addition&rdquo;, &ldquo;represents a
number&rdquo;, and so on.</p><p><div class="SIntrapara">To do this, we must first introduce a datatype that captures this
representation.  We will separately discuss
(<a href="first-interp.html#%28part._dt-for-arith%29" data-pltdoc="x">Representing Arithmetic</a>)
how and why we obtained this datatype,
but for now let&rsquo;s say it&rsquo;s given to us:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define-type</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ArithC</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">numC</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">plusC</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">l</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ArithC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">r</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ArithC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">multC</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">l</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ArithC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">r</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ArithC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">We now need a function that will convert s-expressions into instances
of this datatype.  This is the other half of our parser:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">s</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">s-expression</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ArithC</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">cond</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">s-exp-number?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">numC</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">s-exp-&gt;number</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">s-exp-list?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">sl</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">s-exp-&gt;list</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">case</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">s-exp-&gt;symbol</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">first</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">sl</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">plusC</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">second</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">sl</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">third</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">sl</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">multC</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">second</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">sl</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">third</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">sl</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">else</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">error</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">parse</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"invalid</span><span class="hspace">&nbsp;</span><span class="RktVal">list</span><span class="hspace">&nbsp;</span><span class="RktVal">input"</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">else</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">error</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">parse</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"invalid</span><span class="hspace">&nbsp;</span><span class="RktVal">input"</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Thus:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (parse '(+ (* 1 2) (+ 2 3)))</span></p></td></tr><tr><td><p><span class="stt">- ArithC</span></p></td></tr><tr><td><p><span class="stt">(plusC</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">(multC (numC 1) (numC 2))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">(plusC (numC 2) (numC 3)))</span></p></td></tr></table></div></p><p>Congratulations!  You have just completed your first
<span style="font-style: italic">representation of a program</span>.  From now on we can focus entirely
on programs represented as recursive trees, ignoring the vagaries of
surface syntax and how to get them into the tree form.  We&rsquo;re finally
ready to start studying programming languages!</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>What happens if you forget to quote the argument to the parser?
Why?</p></blockquote></div></p><h4>2.5<tt>&nbsp;</tt><a name="(part._.Coda)"></a>Coda</h4><p>Racket&rsquo;s syntax, which it inherits from Scheme and Lisp, is
controversial.  Observe, however, something deeply valuable that we
get from it.  While parsing traditional languages can be very complex,
parsing this syntax is virtually trivial.  Given a sequence of tokens
corresponding to the input, it is absolutely straightforward to turn
parenthesized sequences into s-expressions; it is equally
straightforward (as we see above) to turn s-expressions into proper
syntax trees.  I like to call such two-level languages
<span style="font-style: italic">bicameral</span>, in loose analogy to government legislative houses:
the lower-level does rudimentary well-formedness checking, while the
upper-level does deeper validity checking.  (We haven&rsquo;t done any of
the latter yet, but we will [REF].)</p><p>The virtues of this syntax are thus manifold.  The amount of code it
requires is small, and can easily be embedded in many contexts.  By
integrating the syntax into the language, it becomes easy for programs
to manipulate representations of programs (as we will see more of in
[REF]).  It&rsquo;s therefore no surprise that even though many Lisp-based
syntaxes have had wildly different semantics, they all share this
syntactic legacy.</p><p>Of course, we could just use <span class="Smaller">XML</span> instead.  That would be
much better.  Or <span class="Smaller">JSON</span>.  Because that wouldn&rsquo;t be anything
like an s-expression at all.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Introduction.html" title="backward to &quot;1 Introduction&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="first-interp.html" title="forward to &quot;3 A First Look at Interpretation&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>