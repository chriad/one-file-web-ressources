<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>6&nbsp;From Substitution to Environments</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Introduction.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Everything__We_Will_Say__About_Parsing.html" class="tocviewlink" data-pltdoc="x">Everything (We Will Say) About Parsing</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="first-interp.html" class="tocviewlink" data-pltdoc="x">A First Look at Interpretation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="first-desugar.html" class="tocviewlink" data-pltdoc="x">A First Taste of Desugaring</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="adding-functions.html" class="tocviewlink" data-pltdoc="x">Adding Functions to the Language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">From Substitution to Environments</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="higher-order-functions.html" class="tocviewlink" data-pltdoc="x">Functions Anywhere</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="mut-struct-vs-var.html" class="tocviewlink" data-pltdoc="x">Mutation:<span class="mywbr"> &nbsp;</span> Structures and Variables</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="recursion.html" class="tocviewlink" data-pltdoc="x">Recursion and Cycles:<span class="mywbr"> &nbsp;</span> Procedures and Data</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Objects.html" class="tocviewlink" data-pltdoc="x">Objects</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Memory_Management.html" class="tocviewlink" data-pltdoc="x">Memory Management</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Representation_Decisions.html" class="tocviewlink" data-pltdoc="x">Representation Decisions</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Desugaring_as_a_Language_Feature.html" class="tocviewlink" data-pltdoc="x">Desugaring as a Language Feature</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Control_Operations.html" class="tocviewlink" data-pltdoc="x">Control Operations</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="types.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Statically:<span class="mywbr"> &nbsp;</span> Types</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="contracts.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Dynamically:<span class="mywbr"> &nbsp;</span> Contracts</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Alternate_Application_Semantics.html" class="tocviewlink" data-pltdoc="x">Alternate Application Semantics</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>6&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">From Substitution to Environments</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">6.1&nbsp;</td><td><a href="#%28part._.Introducing_the_.Environment%29" class="tocviewlink" data-pltdoc="x">Introducing the Environment</a></td></tr><tr><td align="right">6.2&nbsp;</td><td><a href="#%28part._.Interpreting_with_.Environments%29" class="tocviewlink" data-pltdoc="x">Interpreting with Environments</a></td></tr><tr><td align="right">6.3&nbsp;</td><td><a href="#%28part._.Deferring_.Correctly%29" class="tocviewlink" data-pltdoc="x">Deferring Correctly</a></td></tr><tr><td align="right">6.4&nbsp;</td><td><a href="#%28part._.Scope%29" class="tocviewlink" data-pltdoc="x">Scope</a></td></tr><tr><td align="right">6.5&nbsp;</td><td><a href="#%28part._.Exposing_the_.Environment%29" class="tocviewlink" data-pltdoc="x">Exposing the Environment</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">6.1<tt>&nbsp;</tt></span><a href="#%28part._.Introducing_the_.Environment%29" class="tocsubseclink" data-pltdoc="x">Introducing the Environment</a></td></tr><tr><td><span class="tocsublinknumber">6.2<tt>&nbsp;</tt></span><a href="#%28part._.Interpreting_with_.Environments%29" class="tocsubseclink" data-pltdoc="x">Interpreting with Environments</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3c%2A~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;*&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cplus.C%2Fmult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;plusC/multC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cid.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;idC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3capp.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3capp.C-interp~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-interp&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3capp.C-interp-bind-in-env-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-interp-bind-in-env-take-1&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">6.3<tt>&nbsp;</tt></span><a href="#%28part._.Deferring_.Correctly%29" class="tocsubseclink" data-pltdoc="x">Deferring Correctly</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3capp.C-interp-bind-in-env~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-interp-bind-in-env&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">6.4<tt>&nbsp;</tt></span><a href="#%28part._.Scope%29" class="tocsubseclink" data-pltdoc="x">Scope</a></td></tr><tr><td><span class="tocsublinknumber">6.4.1<tt>&nbsp;</tt></span><a href="#%28part._.How_.Bad_.Is_.It_%29" class="tocsubseclink" data-pltdoc="x">How Bad Is It?</a></td></tr><tr><td><span class="tocsublinknumber">6.4.2<tt>&nbsp;</tt></span><a href="#%28part._.The_.Top-.Level_.Scope%29" class="tocsubseclink" data-pltdoc="x">The Top-<wbr></wbr>Level Scope</a></td></tr><tr><td><span class="tocsublinknumber">6.5<tt>&nbsp;</tt></span><a href="#%28part._.Exposing_the_.Environment%29" class="tocsubseclink" data-pltdoc="x">Exposing the Environment</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="adding-functions.html" title="backward to &quot;5 Adding Functions to the Language&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="higher-order-functions.html" title="forward to &quot;7 Functions Anywhere&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>6<tt>&nbsp;</tt><a name="(part._.From_.Substitution_to_.Environments)"></a>From Substitution to Environments</h3><p>Though we have a working definition of functions, you may feel a
slight unease about it.  When the interpreter sees an identifier, you
might have had a sense that it needs to &ldquo;look it up&rdquo;.  Not only did
it not look up anything, we defined its behavior to be an error!
While absolutely correct, this is also a little surprising.  More
importantly, we write interpreters to <span style="font-style: italic">understand</span> and
<span style="font-style: italic">explain</span> languages, and this implementation might strike you as
not doing that, because it doesn&rsquo;t match our intuition.</p><p>There&rsquo;s another difficulty with using substitution, which is the
number of times we traverse the source program.  It would be nice to
have to traverse only those parts of the program that are actually
evaluated, and then, only when necessary.  But substitution traverses
everything&#8212;<wbr></wbr>unvisited branches of conditionals, for instance&#8212;<wbr></wbr>and
forces the program to be traversed once for substitution and once
again for interpretation.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Does substitution have implications for the time complexity of
evaluation?</p></blockquote></div></p><p>There&rsquo;s yet another problem with substitution, which is that it is
defined in terms of representations of the program source.  Obviously,
our interpreter has and needs access to the source, to interpret it.
However, other implementations&#8212;<wbr></wbr>such as compilers&#8212;<wbr></wbr>have no need to
store it for that purpose.<span class="refelem"><span class="refcolumn"><span class="refcontent">Compilers might store versions
of or information about the source for other reasons, such as
reporting runtime errors, and <span class="Smaller">JIT</span>s may need it to re-compile
on demand.</span></span></span>  It would be nice to employ a mechanism that is more
portable across implementation strategies.</p><h4>6.1<tt>&nbsp;</tt><a name="(part._.Introducing_the_.Environment)"></a>Introducing the Environment</h4><p>The intuition that addresses the first concern is to have the
interpreter &ldquo;look up&rdquo; an identifier in some sort of directory.  The
intuition that addresses the second concern is to <span style="font-style: italic">defer</span> the
substitution.  Fortunately, these converge nicely in a way that also
addresses the third.  The directory records the <span style="font-style: italic">intent to
substitute</span>, without actually rewriting the program source; by
recording the intent, rather than substituting immediately, we can
defer substitution; and the resulting data structure, which is called
an <span style="font-style: italic">environment</span>, avoids the need for source-to-source rewriting
and maps nicely to low-level machine representations.  Each name
association in the environment is called a <span style="font-style: italic">binding</span>.</p><p><div class="SIntrapara">Observe carefully that what we are changing is the
<span style="font-style: italic">implementation strategy</span> for the programming language, <span style="font-style: italic">not
the language itself</span>.  Therefore, none of our datatypes for
representing programs should change, nor even should the answers that
the interpreter provides.  As a result, we should think of the
previous interpreter as a &ldquo;reference implementation&rdquo; that the one
we&rsquo;re about to write should match.  Indeed, we should create a
generator that creates lots of tests, runs them through both
interpreters, and makes sure their answers are the same.  Ideally, we
should <span style="font-style: italic">prove</span> that the two interpreters behave the same, which
is a good topic for advanced study.</div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>One subtlety is in
defining precisely what &ldquo;the same&rdquo; means, especially with regards to
failure.</p></blockquote></blockquote></blockquote></div></p><p>Let&rsquo;s first define our environment data structure.  An environment is
a list of pairs of names associated with...what?</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>A natural question to ask here might be what the environment maps
names to.  But a better, more fundamental, question is: How to
determine the answer to the &ldquo;natural&rdquo; question?</p></blockquote></div></p><p>Remember that our environment was created to defer substitutions.
Therefore, the answer lies in substitution.  We discussed earlier
(<a href="adding-functions.html#%28part._eager-lazy-subst%29" data-pltdoc="x">Oh Wait, There&rsquo;s More!</a>) that we want substitution to map names
to answers, corresponding to an eager function application strategy.
Therefore, the environment should map names to answers.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Binding</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">bind</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">name</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define-type-alias</span><span class="hspace">&nbsp;</span><span class="RktMeta">Env</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">Binding</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">mt-env</span><span class="hspace">&nbsp;</span><span class="RktMeta">empty</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">extend-env</span><span class="hspace">&nbsp;</span><span class="RktMeta">cons</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><h4>6.2<tt>&nbsp;</tt><a name="(part._.Interpreting_with_.Environments)"></a>Interpreting with Environments</h4><p>Now we can tackle the interpreter.  One case is easy, but we should
revisit all the others:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3c*~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3c%2A~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;*&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">expr</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Env</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">fds</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">listof</span><span class="hspace">&nbsp;</span><span class="RktSym">FunDefC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">number</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="hspace">&nbsp;</span><span class="RktSym">expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">numC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cid.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;idC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3capp.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cplus.C%2Fmult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;plusC/multC-case&gt;</a><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>The arithmetic operations are easiest.  Recall that before, the
interpreter recurred without performing any new substitutions.  As a
result, there are no new deferred substitutions to perform either,
which means the environment does not change:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cplus.C/mult.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cplus.C%2Fmult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;plusC/multC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">plusC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="RktPn">[</span><span class="RktSym">multC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>Now let&rsquo;s handle identifiers.  Clearly, encountering an identifier is
no longer an error: this was the very motivation for this change.
Instead, we must look up its value in the directory:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cid.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cid.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;idC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">idC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lookup</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Implement <span class="stt">lookup</span>.</p></blockquote></div></p><p>Finally, application.  Observe that in the substitution interpreter,
the only case that caused new substitutions to occur was application.
Therefore, this should be the case that constructs bindings.  Let&rsquo;s
first extract the function definition, just as before:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3capp.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3capp.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">appC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">local</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">fd</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">get-fundef</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3capp.C-interp~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-interp&gt;</a><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>Previously, we substituted, then interpreted.  Because we have no
substitution step, we can proceed with interpretation, so long as we
record the deferral of substitution.</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3capp.C-interp~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3capp.C-interp~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-interp&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fdC-body</span><span class="hspace">&nbsp;</span><span class="RktSym">fd</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3capp.C-interp-bind-in-env~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-interp-bind-in-env&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>That is, the set of function definitions remains unchanged; we&rsquo;re
interpreting the body of the function, as before; but we have to do it
in an environment that binds the formal parameter.  Let&rsquo;s now define
that binding process:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3capp.C-interp-bind-in-env-take-1~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3capp.C-interp-bind-in-env-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-interp-bind-in-env-take-1&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">extend-env</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bind</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fdC-arg</span><span class="hspace">&nbsp;</span><span class="RktSym">fd</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>the name being bound is the formal parameter (the same name that was
substituted for, before).  It is bound to the result of interpreting
the argument (because we&rsquo;ve decided on an eager application
semantics).  And finally, this extends the environment we already
have.  Type-checking this helps to make sure we got all the little
pieces right.</p><p>Once we have a definition for <span class="stt">lookup</span>, we&rsquo;d have a full
interpreter.  So here&rsquo;s one:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lookup</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">for</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Env</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">cond</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">empty?</span><span class="hspace">&nbsp;</span><span class="RktMeta">env</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">error</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">lookup</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"name</span><span class="hspace">&nbsp;</span><span class="RktVal">not</span><span class="hspace">&nbsp;</span><span class="RktVal">found"</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">else</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">cond</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">symbol=?</span><span class="hspace">&nbsp;</span><span class="RktMeta">for</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">bind-name</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">bind-val</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">else</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lookup</span><span class="hspace">&nbsp;</span><span class="RktMeta">for</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rest</span><span class="hspace">&nbsp;</span><span class="RktMeta">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Observe that looking up a free identifier still produces an error, but
it has moved from the interpreter&#8212;<wbr></wbr>which is by itself unable to
determine whether or not an identifier is free&#8212;<wbr></wbr>to <span class="stt">lookup</span>,
which determines this based on the content of the environment.</p><p>Now we have a full interpreter.  You should of course test it make
sure it works as you&rsquo;d expect.  For instance, these tests pass:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">interp</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">plusC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">appC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">const5</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">mt-env</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">list</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fdC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">const5</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">_</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">15</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">interp</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">plusC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">appC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">double</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">plusC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">mt-env</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">list</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fdC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">double</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">plusC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">idC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">idC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">16</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">interp</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">plusC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">appC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">quadruple</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">plusC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">mt-env</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">list</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fdC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">quadruple</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">appC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">double</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">appC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">double</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">idC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fdC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">double</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">plusC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">idC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">idC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">22</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>So we&rsquo;re done, right?</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Spot the bug.</p></blockquote></div></p><h4>6.3<tt>&nbsp;</tt><a name="(part._.Deferring_.Correctly)"></a>Deferring Correctly</h4><p><div class="SIntrapara">Here&rsquo;s another test:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">interp</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">appC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">f1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">mt-env</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">list</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fdC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">f1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">appC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">f2</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fdC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">f2</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">y</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">plusC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">idC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">idC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>In our interpreter, this evaluates to <span class="stt">7</span>.  Should it?</p><p>Translated into Racket, this test corresponds to the following two
definitions and expression:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f1</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f2</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f2</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>What should this produce?  <span class="stt">(f1 3)</span> substitutes <span class="stt">x</span> with
<span class="stt">3</span> in the body of <span class="stt">f1</span>, which then invokes <span class="stt">(f2 4)</span>.
But notably, in <span class="stt">f2</span>, the identifier <span class="stt">x</span> is <span style="font-style: italic">not
bound</span>!  Sure enough, Racket will produce an error.</p><p>In fact, so will our substitution-based interpreter!</p><p>Why does the substitution process result in an error?  It&rsquo;s because,
when we replace the representation of <span class="stt">x</span> with the representation
of <span class="stt">3</span> in the representation of <span class="stt">f1</span>, we do so in <span class="stt">f1</span>
<span style="font-style: italic">only</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">This &ldquo;the representation of&rdquo; is getting a
little annoying, isn&rsquo;t it?  Therefore, I&rsquo;ll stop saying that, but do
make sure you understand why I had to say it.  It&rsquo;s an important bit
of pedantry.</span></span></span>  (Obviously: <span class="stt">x</span> is <span class="stt">f1</span>&rsquo;s parameter; even if
another function had a parameter named <span class="stt">x</span>, that&rsquo;s a
<span style="font-style: italic">different</span> <span class="stt">x</span>.)  Thus, when we get to evaluating the body
of <span class="stt">f2</span>, its <span class="stt">x</span> hasn&rsquo;t been substituted, resulting in the
error.</p><p>What went wrong when we switched to environments?  Watch carefully:
this is subtle.  We can focus on applications, because only they
affect the environment.  When we substituted the formal for the value
of the actual, we did so by <span style="font-style: italic">extending the current environment</span>.
In terms of our example, we asked the interpreter to substitute not
only <span class="stt">f2</span>&rsquo;s substitution in <span class="stt">f2</span>&rsquo;s body, but also the
current ones (those for the caller, <span class="stt">f1</span>), and indeed all past
ones as well.  That is, the environment only grows; it never shrinks.</p><p>Because we agreed that environments are only an alternate
implementation strategy for substitution&#8212;<wbr></wbr>and in particular, that the
language&rsquo;s meaning should not change&#8212;<wbr></wbr>we have to alter the
interpreter.  Concretely, we should not ask it to carry around all
past deferred substitution requests, but instead make it start afresh
for every new function, just as the substitution-based interpreter
does.  This is an easy change:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3capp.C-interp-bind-in-env~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3capp.C-interp-bind-in-env~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-interp-bind-in-env&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">extend-env</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bind</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fdC-arg</span><span class="hspace">&nbsp;</span><span class="RktSym">fd</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">mt-env</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Now we have truly reproduced the behavior of the substitution
interpreter.<span class="refelem"><span class="refcolumn"><span class="refcontent">In case you&rsquo;re wondering how to write a test
case that catches errors, look up <span class="stt">test/exn</span>.</span></span></span></p><h4>6.4<tt>&nbsp;</tt><a name="(part._.Scope)"></a>Scope</h4><p>The broken environment interpreter above implements what is known as
<span style="font-style: italic">dynamic scope</span>.  This means the environment accumulates bindings
as the program executes.  As a result, whether an identifier is even
bound depends on the history of program execution.  We should regard
this unambiguously as a flaw of programming language design.  It
adversely affects all tools that read and process programs: compilers,
<span class="Smaller">IDE</span>s, and humans.</p><p>In contrast, substitution&#8212;<wbr></wbr>and environments, done correctly&#8212;<wbr></wbr>give us
<span style="font-style: italic">lexical scope</span> or <span style="font-style: italic">static scope</span>.  &ldquo;Lexical&rdquo; in this
context means &ldquo;as determined from the source program&rdquo;, while
&ldquo;static&rdquo; in computer science means &ldquo;without running the program&rdquo;,
so these are appealing to the same intuition.  When we examine an
identifier, we want to know two things: (1) Is it bound?  (2) If so,
where?  By &ldquo;where&rdquo; we mean: if there are multiple bindings for the
same name, which one governs this identifier?  Put differently, which
one&rsquo;s substitution will give a value to this identifier?  In general,
these questions cannot be answered statically in a dynamically-scoped
language: so your <span class="Smaller">IDE</span>, for instance, cannot overlay arrows to
show you this information (as DrRacket does).<span class="refelem"><span class="refcolumn"><span class="refcontent">A different
way to think about it is that in a dynamically-scoped language, the
answer to these questions is the same for <span style="font-style: italic">all</span> identifiers, and
it simply refers to the dynamic environment.  In other words, it
provides no useful information.</span></span></span>  Thus, even though the rules of scope
become more complex as the space of names becomes richer (e.g.,
objects, threads, etc.), we should always strive to preserve the
spirit of static scoping.</p><h5>6.4.1<tt>&nbsp;</tt><a name="(part._.How_.Bad_.Is_.It_)"></a>How Bad Is It?</h5><p><div class="SIntrapara">You might look at our running example and wonder whether we&rsquo;re
creating a tempest in a teapot.  In return, you should consider two
situations:
</div><div class="SIntrapara"><ol><li><p>To understand the binding structure of your program, you may
need to look at <span style="font-style: italic">the whole program</span>.  No matter how much you&rsquo;ve
decomposed your program into small, understandable fragments, it
doesn&rsquo;t matter if you have a free identifier anywhere.</p></li><li><p>Understanding the binding structure is not only a function of
the <span style="font-style: italic">size</span> of the program but also of the complexity of its
control flow.  Imagine an interactive program with numerous
callbacks; you&rsquo;d have to track through every one of them, too, to
know which binding governs an identifier.</p></li></ol></div><div class="SIntrapara">Need a little more of a nudge?  Let&rsquo;s replace the expression of our
example program with this one:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">moon-visible?</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f2</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Suppose <span class="stt">moon-visible?</span> is a function that presumably evaluates
to false on new-moon nights, and true at other times.  Then, this
program will evaluate to an answer except on new-moon nights, when it
will fail with an unbound identifier error.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>What happens on cloudy nights?</p></blockquote></div></p><h5>6.4.2<tt>&nbsp;</tt><a name="(part._.The_.Top-.Level_.Scope)"></a>The Top-Level Scope</h5><p><div class="SIntrapara">Matters become more complex when we contemplate top-level
definitions in many languages.  For instance, some versions of Scheme
(which is a paragon of lexical scoping) allow you to write this:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">which seems to pretty clearly suggest where the <span class="stt">y</span> in the body
of <span class="stt">f</span> will come from, except:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">is legal and <span class="stt">(f 10)</span> produces <span class="stt">12</span>.
Wait, you might think, always take the last one!  But:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">z</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="hspace">&nbsp;</span><span class="RktMeta">z</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Here, <span class="stt">z</span> is bound to the first value of <span class="stt">y</span> whereas the
inner <span class="stt">y</span> is bound to the second value.<span class="refelem"><span class="refcolumn"><span class="refcontent">Most
&ldquo;scripting&rdquo; languages exhibit similar problems.  As a result, on the
Web you will find enormous confusion about whether a certain language
is statically- or dynamically-scoped, when in fact readers are
comparing behavior inside functions (often static) against the
top-level (usually dynamic).  Beware!</span></span></span>
There is actually a
valid explanation of this behavior in terms of lexical scope, but it
can become convoluted, and perhaps a more sensible option is to
prevent such redefinition.  Racket does precisely this, thereby
offering the convenience of a top-level without its pain.</div></p><h4>6.5<tt>&nbsp;</tt><a name="(part._.Exposing_the_.Environment)"></a>Exposing the Environment</h4><p>If we were building the implementation for others to use, it would be
wise and a courtesy for the exported interpreter to take only an
expression and list of function definitions, and invoke our defined
<span class="stt">interp</span> with the empty environment.  This both spares users an
implementation detail, and avoids the use of an interpreter with an
incorrect environment.  In some contexts, however, it can be useful to
expose the environment parameter.  For instance, the environment can
represent a set of pre-defined bindings: e.g., if the language wishes
to provide <span class="stt">pi</span> automatically bound to <span class="stt">3.2</span> (in Indiana).</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="adding-functions.html" title="backward to &quot;5 Adding Functions to the Language&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="higher-order-functions.html" title="forward to &quot;7 Functions Anywhere&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>