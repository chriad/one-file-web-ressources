<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>1&nbsp;Introduction</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Everything__We_Will_Say__About_Parsing.html" class="tocviewlink" data-pltdoc="x">Everything (We Will Say) About Parsing</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="first-interp.html" class="tocviewlink" data-pltdoc="x">A First Look at Interpretation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="first-desugar.html" class="tocviewlink" data-pltdoc="x">A First Taste of Desugaring</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="adding-functions.html" class="tocviewlink" data-pltdoc="x">Adding Functions to the Language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="From_Substitution_to_Environments.html" class="tocviewlink" data-pltdoc="x">From Substitution to Environments</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="higher-order-functions.html" class="tocviewlink" data-pltdoc="x">Functions Anywhere</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="mut-struct-vs-var.html" class="tocviewlink" data-pltdoc="x">Mutation:<span class="mywbr"> &nbsp;</span> Structures and Variables</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="recursion.html" class="tocviewlink" data-pltdoc="x">Recursion and Cycles:<span class="mywbr"> &nbsp;</span> Procedures and Data</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Objects.html" class="tocviewlink" data-pltdoc="x">Objects</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Memory_Management.html" class="tocviewlink" data-pltdoc="x">Memory Management</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Representation_Decisions.html" class="tocviewlink" data-pltdoc="x">Representation Decisions</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Desugaring_as_a_Language_Feature.html" class="tocviewlink" data-pltdoc="x">Desugaring as a Language Feature</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Control_Operations.html" class="tocviewlink" data-pltdoc="x">Control Operations</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="types.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Statically:<span class="mywbr"> &nbsp;</span> Types</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="contracts.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Dynamically:<span class="mywbr"> &nbsp;</span> Contracts</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Alternate_Application_Semantics.html" class="tocviewlink" data-pltdoc="x">Alternate Application Semantics</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Introduction</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">1.1&nbsp;</td><td><a href="#%28part._.Our_.Philosophy%29" class="tocviewlink" data-pltdoc="x">Our Philosophy</a></td></tr><tr><td align="right">1.2&nbsp;</td><td><a href="#%28part._.The_.Structure_of_.This_.Book%29" class="tocviewlink" data-pltdoc="x">The Structure of This Book</a></td></tr><tr><td align="right">1.3&nbsp;</td><td><a href="#%28part._.The_.Language_of_.This_.Book%29" class="tocviewlink" data-pltdoc="x">The Language of This Book</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Our_.Philosophy%29" class="tocsubseclink" data-pltdoc="x">Our Philosophy</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.The_.Structure_of_.This_.Book%29" class="tocsubseclink" data-pltdoc="x">The Structure of This Book</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.The_.Language_of_.This_.Book%29" class="tocsubseclink" data-pltdoc="x">The Language of This Book</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Everything__We_Will_Say__About_Parsing.html" title="forward to &quot;2 Everything (We Will Say) About Parsing&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>1<tt>&nbsp;</tt><a name="(part._.Introduction)"></a>Introduction</h3><h4>1.1<tt>&nbsp;</tt><a name="(part._.Our_.Philosophy)"></a>Our Philosophy</h4><p>Please watch the
<a href="http://www.youtube.com/watch?v=3N__tvmZrzc">video on YouTube</a>.
Someday there will be a textual description here instead.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._.The_.Structure_of_.This_.Book)"></a>The Structure of This Book</h4><p>Unlike some other textbooks, this one does not follow a top-down
narrative.  Rather it has the flow of a conversation, with
backtracking.  We will often build up programs incrementally, just as
a pair of programmers would.  We will include mistakes, not because I
don&rsquo;t know the answer, but because <span style="font-style: italic">this is the best way for you
to learn</span>.  Including mistakes makes it impossible for you to read
passively: you must instead engage with the material, because you can
never be sure of the veracity of what you&rsquo;re reading.</p><p>At the end, you&rsquo;ll always get to the right answer.  However, this
non-linear path is more frustrating in the short term (you will often
be tempted to say, &ldquo;Just tell me the answer, already!&rdquo;), and it
makes the book a poor reference guide (you can&rsquo;t open up to a random
page and be sure what it says is correct).  However, that feeling of
frustration is the sensation of learning.  I don&rsquo;t know of a way
around it.</p><p>At various points you will encounter this:</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>This is an exercise.  Do try it.</p></blockquote></div></p><p>This is a traditional textbook exercise.  It&rsquo;s something you need to
do on your own.  If you&rsquo;re using this book as part of a course, this
may very well have been assigned as homework.  In contrast, you will
also find exercise-like questions that look like this:</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>There&rsquo;s an activity here!  Do you see it?</p></blockquote></div></p><p>When you get to one of these, <span style="font-weight: bold">stop</span>.  Read, think, and formulate
an answer before you proceed.  You must do this because this is
actually an <span style="font-style: italic">exercise</span>, but the answer is already in the
book&#8212;<wbr></wbr>most often in the text immediately following (i.e., in the part
you&rsquo;re reading right now)&#8212;<wbr></wbr>or is something you can determine for
yourself by running a program.  If you just read on, you&rsquo;ll see the
answer without having thought about it (or not see it at all, if the
instructions are to run a program), so you will get to neither (a)
test your knowledge, nor (b) improve your intuitions.  In other words,
these are additional, explicit attempts to encourage active learning.
Ultimately, however, I can only encourage it; it&rsquo;s up to you to
practice it.</p><h4>1.3<tt>&nbsp;</tt><a name="(part._.The_.Language_of_.This_.Book)"></a>The Language of This Book</h4><p><div class="SIntrapara">The main programming language used in this book is
<a href="http://www.racket-lang.org/">Racket</a>.
Like with all operating systems, however, Racket actually supports a
host of programming languages, so you must tell Racket
<span style="font-style: italic">which</span> language you&rsquo;re programming in.  You inform the Unix
shell by writing a line like
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">#!/bin/sh</span></p></td></tr></table></div><div class="SIntrapara">at the top of a script; you inform the browser by writing, say,
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" ...&gt;</span></p></td></tr></table></div><div class="SIntrapara">Similarly, Racket asks that you declare which language you will be
using.  Racket languages can have the same parenthetical syntax as
Racket but with a different semantics; the same semantics but a
different syntax; or different syntax and semantics.  Thus every
Racket program begins with <span class="stt">#lang</span>
followed by the name of some language: by default, it&rsquo;s Racket
(written as <span class="stt">racket</span>).
<span class="refelem"><span class="refcolumn"><span class="refcontent">In DrRacket v. 5.3, go to Language, then Choose
Language, and select &ldquo;Use the language declared in the source&rdquo;.</span></span></span>
In this book we&rsquo;ll almost always use the language
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">plai-typed</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">.
When we deviate we&rsquo;ll say so explicitly, so unless indicated
otherwise, put
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">#lang plai-typed</span></p></td></tr></table></div><div class="SIntrapara">at the top of every file (and assume I&rsquo;ve done the same).</div></p><p><div class="SIntrapara">The <span style="font-style: italic">Typed PLAI</span> language differs from traditional Racket most
importantly by being statically typed.  It also gives you some useful
new constructs:
<span class="stt">define-type</span>, <span class="stt">type-case</span>, and <span class="stt">test</span>.
<span class="refelem"><span class="refcolumn"><span class="refcontent">There are
additional commands for controlling the output of testing, for
instance.  Be sure to read the documentation for the
language  In DrRacket v. 5.3, go to Help, then Help Desk,
and in the Help Desk search bar, type &ldquo;plai-typed&rdquo;.</span></span></span>
Here&rsquo;s an example of each in use.  We can introduce new datatypes:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define-type</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">MisspelledAnimal</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">caml</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">humps</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">yacc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">height</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">You can roughly think of this as analogous to the following in
Java: an abstract class <span class="stt">MisspelledAnimal</span> and two concrete
sub-classes <span class="stt">caml</span> and <span class="stt">yacc</span>, each of which has one numeric
constructor argument named <span class="stt">humps</span> and <span class="stt">height</span>, respectively.</div></p><p><div class="SIntrapara">In this language, we construct instances as follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">caml</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">yacc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1.9</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">As the name suggests, <span class="stt">define-type</span> creates a type of the given
name.  We can use this when, for instance, binding the above instances
to names:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ma1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">MisspelledAnimal</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">caml</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ma2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">MisspelledAnimal</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">yacc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1.9</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In fact you don&rsquo;t need these particular type declarations, because
Typed PLAI will infer types for you here and in many other cases.
Thus you could just as well have written
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ma1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">caml</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ma2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">yacc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1.9</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">but we prefer to write explicit type declarations as a matter of both
discipline and comprehensibility when we return to programs later.</div></p><p>The type names can even be used recursively, as we will see
repeatedly in this book (for instance, <a href="Everything__We_Will_Say__About_Parsing.html#%28part._first-parser%29" data-pltdoc="x">Completing the Parser</a>).</p><p><div class="SIntrapara">The language provides a pattern-matcher for use when
writing expressions, such as a function&rsquo;s body:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">good?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">ma</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">MisspelledAnimal</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">boolean</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">MisspelledAnimal</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ma</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">caml</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">humps</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">humps</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">yacc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">height</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">height</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2.1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In the expression <span class="stt">(&gt;= humps 2)</span>, for instance, <span class="stt">humps</span> is
the name given to whatever value was given as the argument to the
constructor <span class="stt">caml</span>.</div></p><p><div class="SIntrapara">Finally, you should write test cases, ideally before you&rsquo;ve defined
your function, but also afterwards to protect against accidental
changes:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">test</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">good?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ma1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">test</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">good?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ma2</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">When you run the above program, the language will give you verbose
output telling you both tests passed.  Read the documentation to learn
how to suppress most of these messages.</div></p><p><div class="SIntrapara">Here&rsquo;s something important that is obscured above.  We&rsquo;ve used the same
name, <span class="stt">humps</span> (and <span class="stt">height</span>), in <span style="font-style: italic">both</span> the datatype
definition and in the fields of the pattern-match.  This is absolutely
unnecessary because the two are related by <span style="font-style: italic">position</span>, not name.
Thus, we could have as well written the function as
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">good?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">ma</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">MisspelledAnimal</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">boolean</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">MisspelledAnimal</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ma</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">caml</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">h</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">h</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">yacc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">h</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">h</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2.1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Because each <span class="stt">h</span> is only visible in the case branch in which it
is introduced, the two <span class="stt">h</span>s do not in fact clash.  You can
therefore use
convention and readability to dictate your choices.  In general, it
makes sense to provide a long and descriptive name when defining the
datatype (because you probably won&rsquo;t use that name again), but shorter
names in the <span class="stt">type-case</span> because you&rsquo;re likely to use use those
names one or more times.</div></p><p><div class="SIntrapara">I did just say you&rsquo;re unlikely to use the field descriptors
introduced in the datatype definition, but you can.  The language
provides selectors to extract fields without the need
for pattern-matching: e.g., <span class="stt">caml-humps</span>.  Sometimes, it&rsquo;s much
easier to use the selector directly rather than go through the
pattern-matcher.  It often isn&rsquo;t, as when defining <span class="stt">good?</span> above,
but just to be clear, let&rsquo;s write it without pattern-matching:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">good?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">ma</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">MisspelledAnimal</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">boolean</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">cond</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">caml?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ma</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">caml-humps</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ma</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">yacc?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ma</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">yacc-height</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ma</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2.1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>What happens if you mis-apply functions to the wrong kinds of values?
For instance, what if you give the <span class="stt">caml</span> constructor a string?
What if you send a number into each version of <span class="stt">good?</span> above?</p></blockquote></div></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Everything__We_Will_Say__About_Parsing.html" title="forward to &quot;2 Everything (We Will Say) About Parsing&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>