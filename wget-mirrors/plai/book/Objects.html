<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>10&nbsp;Objects</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Introduction.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Everything__We_Will_Say__About_Parsing.html" class="tocviewlink" data-pltdoc="x">Everything (We Will Say) About Parsing</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="first-interp.html" class="tocviewlink" data-pltdoc="x">A First Look at Interpretation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="first-desugar.html" class="tocviewlink" data-pltdoc="x">A First Taste of Desugaring</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="adding-functions.html" class="tocviewlink" data-pltdoc="x">Adding Functions to the Language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="From_Substitution_to_Environments.html" class="tocviewlink" data-pltdoc="x">From Substitution to Environments</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="higher-order-functions.html" class="tocviewlink" data-pltdoc="x">Functions Anywhere</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="mut-struct-vs-var.html" class="tocviewlink" data-pltdoc="x">Mutation:<span class="mywbr"> &nbsp;</span> Structures and Variables</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="recursion.html" class="tocviewlink" data-pltdoc="x">Recursion and Cycles:<span class="mywbr"> &nbsp;</span> Procedures and Data</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Objects</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Memory_Management.html" class="tocviewlink" data-pltdoc="x">Memory Management</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Representation_Decisions.html" class="tocviewlink" data-pltdoc="x">Representation Decisions</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Desugaring_as_a_Language_Feature.html" class="tocviewlink" data-pltdoc="x">Desugaring as a Language Feature</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Control_Operations.html" class="tocviewlink" data-pltdoc="x">Control Operations</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="types.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Statically:<span class="mywbr"> &nbsp;</span> Types</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="contracts.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Dynamically:<span class="mywbr"> &nbsp;</span> Contracts</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Alternate_Application_Semantics.html" class="tocviewlink" data-pltdoc="x">Alternate Application Semantics</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>10&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Objects</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">10.1&nbsp;</td><td><a href="#%28part._.Objects_.Without_.Inheritance%29" class="tocviewlink" data-pltdoc="x">Objects Without Inheritance</a></td></tr><tr><td align="right">10.2&nbsp;</td><td><a href="#%28part._.Member_.Access_.Design_.Space%29" class="tocviewlink" data-pltdoc="x">Member Access Design Space</a></td></tr><tr><td align="right">10.3&nbsp;</td><td><a href="#%28part._.What__.Goes_.In__.Else_%29" class="tocviewlink" data-pltdoc="x">What (Goes In) Else?</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">10.1<tt>&nbsp;</tt></span><a href="#%28part._.Objects_.Without_.Inheritance%29" class="tocsubseclink" data-pltdoc="x">Objects Without Inheritance</a></td></tr><tr><td><span class="tocsublinknumber">10.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Objects_in_the_.Core%29" class="tocsubseclink" data-pltdoc="x">Objects in the Core</a></td></tr><tr><td><span class="tocsublinknumber">10.1.2<tt>&nbsp;</tt></span><a href="#%28part._.Objects_by_.Desugaring%29" class="tocsubseclink" data-pltdoc="x">Objects by Desugaring</a></td></tr><tr><td><span class="tocsublinknumber">10.1.3<tt>&nbsp;</tt></span><a href="#%28part._.Objects_as_.Named_.Collections%29" class="tocsubseclink" data-pltdoc="x">Objects as Named Collections</a></td></tr><tr><td><span class="tocsublinknumber">10.1.4<tt>&nbsp;</tt></span><a href="#%28part._.Constructors%29" class="tocsubseclink" data-pltdoc="x">Constructors</a></td></tr><tr><td><span class="tocsublinknumber">10.1.5<tt>&nbsp;</tt></span><a href="#%28part._.State%29" class="tocsubseclink" data-pltdoc="x">State</a></td></tr><tr><td><span class="tocsublinknumber">10.1.6<tt>&nbsp;</tt></span><a href="#%28part._.Private_.Members%29" class="tocsubseclink" data-pltdoc="x">Private Members</a></td></tr><tr><td><span class="tocsublinknumber">10.1.7<tt>&nbsp;</tt></span><a href="#%28part._.Static_.Members%29" class="tocsubseclink" data-pltdoc="x">Static Members</a></td></tr><tr><td><span class="tocsublinknumber">10.1.8<tt>&nbsp;</tt></span><a href="#%28part._.Objects_with_.Self-.Reference%29" class="tocsubseclink" data-pltdoc="x">Objects with Self-<wbr></wbr>Reference</a></td></tr><tr><td><span class="tocsublinknumber">10.1.8.1<tt>&nbsp;</tt></span><a href="#%28part._.Self-.Reference_.Using_.Mutation%29" class="tocsubseclink" data-pltdoc="x">Self-<wbr></wbr>Reference Using Mutation</a></td></tr><tr><td><span class="tocsublinknumber">10.1.8.2<tt>&nbsp;</tt></span><a href="#%28part._self-ref-wout-mut%29" class="tocsubseclink" data-pltdoc="x">Self-<wbr></wbr>Reference Without Mutation</a></td></tr><tr><td><span class="tocsublinknumber">10.1.9<tt>&nbsp;</tt></span><a href="#%28part._.Dynamic_.Dispatch%29" class="tocsubseclink" data-pltdoc="x">Dynamic Dispatch</a></td></tr><tr><td><span class="tocsublinknumber">10.2<tt>&nbsp;</tt></span><a href="#%28part._.Member_.Access_.Design_.Space%29" class="tocsubseclink" data-pltdoc="x">Member Access Design Space</a></td></tr><tr><td><span class="tocsublinknumber">10.3<tt>&nbsp;</tt></span><a href="#%28part._.What__.Goes_.In__.Else_%29" class="tocsubseclink" data-pltdoc="x">What (Goes In) Else?</a></td></tr><tr><td><span class="tocsublinknumber">10.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Classes%29" class="tocsubseclink" data-pltdoc="x">Classes</a></td></tr><tr><td><span class="tocsublinknumber">10.3.2<tt>&nbsp;</tt></span><a href="#%28part._.Prototypes%29" class="tocsubseclink" data-pltdoc="x">Prototypes</a></td></tr><tr><td><span class="tocsublinknumber">10.3.3<tt>&nbsp;</tt></span><a href="#%28part._.Multiple_.Inheritance%29" class="tocsubseclink" data-pltdoc="x">Multiple Inheritance</a></td></tr><tr><td><span class="tocsublinknumber">10.3.4<tt>&nbsp;</tt></span><a href="#%28part._.Super-.Duper_%29" class="tocsubseclink" data-pltdoc="x">Super-<wbr></wbr>Duper!</a></td></tr><tr><td><span class="tocsublinknumber">10.3.5<tt>&nbsp;</tt></span><a href="#%28part._.Mixins_and_.Traits%29" class="tocsubseclink" data-pltdoc="x">Mixins and Traits</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="recursion.html" title="backward to &quot;9 Recursion and Cycles: Procedures and Data&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Memory_Management.html" title="forward to &quot;11 Memory Management&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>10<tt>&nbsp;</tt><a name="(part._.Objects)"></a>Objects</h3><p>When a language admits functions as values, it provides developers the
most natural way to represent a unit of computation.  Suppose a
developer wants to parameterize some function <span class="stt">f</span>.  Any language
lets <span class="stt">f</span> be parameterized by <span style="font-style: italic">passive</span> data, such as numbers
and strings.  But it is often attractive to parameterize it over
<span style="font-style: italic">active</span> data: a datum that can <span style="font-style: italic">compute</span> an answer, perhaps
in response to some information.  Furthermore, the function passed to
<span class="stt">f</span> can&#8212;<wbr></wbr>assuming lexically-scoped functions&#8212;<wbr></wbr>refer to data
from the caller without those data having to be revealed to <span class="stt">f</span>,
thus providing a foundation for security and privacy.  Thus,
lexically-scoped functions are central to the design of many secure
programming techniques.</p><p>While a function is a splendid thing, it suffers from excessive
terseness.  Sometimes we might want multiple functions to all close
over to the same <span style="font-style: italic">shared</span> data; the sharing especially matters if
some of the functions mutate it and expect the others to see the
result of those mutations.  In such cases, it becomes unwieldly to
send just a single function as a parameter; it is more useful to send
a group of functions.  The recipient then needs a way to choose
between the different functions in the group.  This grouping of
functions, and the means to select one from the group, is the essence
of an <span style="font-style: italic">object</span>.  We are therefore perfectly placed to study
objects having covered functions (<a href="higher-order-functions.html" data-pltdoc="x">Functions Anywhere</a>)
and mutation (<a href="mut-struct-vs-var.html" data-pltdoc="x">Mutation: Structures and Variables</a>)&#8212;<wbr></wbr>and, it
will emerge, recursion (<a href="recursion.html" data-pltdoc="x">Recursion and Cycles: Procedures and Data</a>).</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">I cannot hope to do justice to the enormous space of
object systems.  Please read
<a href="http://users.dcc.uchile.cl/~etanter/ooplai/"><span style="font-style: italic">Object-Oriented Programming Languages: 
                   Application and Interpretation</span></a>
by &#201;ric Tanter, which goes into more detail and
covers topics ignored here.</span></span></span>
Let&rsquo;s add this notion of objects to our language.  Then we&rsquo;ll flesh it
out and grow it, and explore the many dimensions in the design space
of objects.  We&rsquo;ll first show how to add objects to the core language,
but because we&rsquo;ll want to prototype many different ideas quickly,
we&rsquo;ll soon shift to a desugaring-based strategy.  Which one you use
depends on whether you think understanding them is critical to
understanding the essence of your language.  One way to measure this
is how complex your desugaring strategy becomes, and whether by adding
some key core language enhancements, you can greatly reduce the
complexity of desugaring.</p><h4>10.1<tt>&nbsp;</tt><a name="(part._.Objects_.Without_.Inheritance)"></a>Objects Without Inheritance</h4><p><div class="SIntrapara">The simplest notion of an object&#8212;<wbr></wbr>pretty much the only thing everyone
who talks about objects agrees about&#8212;<wbr></wbr>is that an object is
</div><div class="SIntrapara"><ul><li><p>a value, that</p></li><li><p>maps names to</p></li><li><p>stuff: either other values or &ldquo;methods&rdquo;.</p></li></ul></div><div class="SIntrapara">From a minimalist perspective, methods seem to be just functions, and
since we already have those in the language, we can put aside this
distinction.<span class="refelem"><span class="refcolumn"><span class="refcontent">We&rsquo;re about to find out that
&ldquo;methods&rdquo; are awfully close to functions but differ in important
ways in how they&rsquo;re called and/or what&rsquo;s bound in them.</span></span></span></div></p><h5>10.1.1<tt>&nbsp;</tt><a name="(part._.Objects_in_the_.Core)"></a>Objects in the Core</h5><p><div class="SIntrapara">Therefore, starting from the language with first-class functions,
let&rsquo;s define this very simple notion of objects by adding
it to the core language.  We clearly have to extend our notion of
values:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Value</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">numV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">closV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">body</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Env</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">objV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">ns</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">vs</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">Value</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">We&rsquo;ll extend the expression grammar to support literal object
construction expressions:<span class="refelem"><span class="refcolumn"><span class="refcontent">Observe that this is already a
design decision.  In some languages, like JavaScript, a developer can
write literal objects: a notion so popular that a subset of the syntax
for it in JavaScript has become a Web standard, JSON.
In other languages, like Java, objects
can only be created by invoking a constructor on a class.  We can
simulate both by assuming that to model the latter kind of language,
we must write object literals only in special positions following a
stylized convention, as we do when desugaring below.</span></span></span>
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktMeta">objC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">ns</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">es</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Evaluating such an object expression is easy: we just evaluate each of
its expression positions:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktMeta">objC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">ns</span><span class="hspace">&nbsp;</span><span class="RktMeta">es</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">objV</span><span class="hspace">&nbsp;</span><span class="RktMeta">ns</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">map</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">e</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">interp</span><span class="hspace">&nbsp;</span><span class="RktMeta">e</span><span class="hspace">&nbsp;</span><span class="RktMeta">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">es</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Unfortunately, we can&rsquo;t actually <span style="font-style: italic">use</span> an object, because we have
no way of obtaining its content.  For that reason, we could add an
operation to extract members:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktMeta">msgC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">whose behavior is intuitive:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktMeta">msgC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lookup-msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">interp</span><span class="hspace">&nbsp;</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p><div class="SIntrapara">Implement
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">lookup-msg</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">*</span><span class="hspace">&nbsp;</span><span class="RktCmt">Value</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Value</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">where the second argument is expected to be a <span class="stt">objV</span>.</div></p></blockquote></div></p><p><div class="SIntrapara">In principle, <span class="stt">msgC</span> can be used to obtain any kind of
member but for simplicity, we need only assume that we have
functions.  To use them, we must apply them to values.  This is
cumbersome to write in the concrete syntax, so let&rsquo;s assume desugaring
has taken care of it for us: the concrete syntax for message
invocation includes both the name of the message to fetch and its
argument expression,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktMeta">msgS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprS</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprS</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and this desugars into <span class="stt">msgC</span> composed with application:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktMeta">msgS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">appC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msgC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">desugar</span><span class="hspace">&nbsp;</span><span class="RktMeta">o</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">desugar</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">With this we have a full first language with objects.  For instance,
here is an object definition and invocation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">letS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">objS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">list</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">sub1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">list</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lamS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">plusS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">idS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lamS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">plusS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">idS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">-1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msgS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">idS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">o</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and this evaluates to <span class="stt">(numV 4)</span>.</div></p><h5>10.1.2<tt>&nbsp;</tt><a name="(part._.Objects_by_.Desugaring)"></a>Objects by Desugaring</h5><p>While defining objects in the core language may be worthwhile, it&rsquo;s an
unwieldy way to go about studying them.  Instead, we&rsquo;ll use Racket to
represent objects, sticking to the parts of the language we already
know how to implement in our interpreter.  That is, we&rsquo;ll assume that
we are looking at the <span style="font-style: italic">output of desugaring</span>.  (For this reason,
we&rsquo;ll also stick to stylized code, potentially writing unnecessary
expressions on the grounds that this is what a simple program
generator would produce.)</p><p>Alert: All the code that follows will be in <span class="stt">#lang plai</span>,
<span style="font-style: italic">not</span> in the typed language.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Why <span class="stt">#lang plai</span>?  What problem<span style="font-style: italic">s</span> do you encounter when you
try to type the following code?  Are some of them amenable to easy
fixes, such as introducing a new datatype and applying it
consistently?  How about if we make simplifications for the purposes
of modeling, such as assuming methods have only one argument?  Or are
some of them less tractable?</p></blockquote></div></p><h5>10.1.3<tt>&nbsp;</tt><a name="(part._.Objects_as_.Named_.Collections)"></a>Objects as Named Collections</h5><p><div class="SIntrapara">Let&rsquo;s begin by reproducing the object language we had above.  An
object is just a value that dispatches on a given name.  For
simplicity, we&rsquo;ll use <span class="stt">lambda</span> to represent the object and
<span class="stt">case</span> to implement the dispatching.<span class="refelem"><span class="refcolumn"><span class="refcontent">Observe that
basic objects are a generalization of <span class="stt">lambda</span> to
have multiple &ldquo;entry-points&rdquo;.  Conversely, a <span class="stt">lambda</span> is an
object with just one entry-point, so it doesn&rsquo;t need a &ldquo;method
name&rdquo; to disambiguate.</span></span></span>
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">o-1</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">add1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">sub1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">-</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This is the same object we defined earlier, and we use its method in
the same way:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">o-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">add1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">6</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">test</span><span class="hspace">&nbsp;</span><span class="RktCmt">succeeds</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Of course, writing method invocations with these nested function calls
is unwieldy (and is about to become even more so), so we&rsquo;d be best off
equipping ourselves with a convenient syntax for invoking
methods&#8212;<wbr></wbr>the same one we saw earlier (<span class="stt">msgS</span>), but here we can
simply define it as a function:<span class="refelem"><span class="refcolumn"><span class="refcontent">We&rsquo;ve taken advantage of
Racket&rsquo;s variable-arity syntax: <span class="stt">. a</span> says &ldquo;bind all the
remaining&#8212;<wbr></wbr>zero or more&#8212;<wbr></wbr>arguments to a list named <span class="stt">a</span>&rdquo;.
<span class="stt">apply</span> &ldquo;splices&rdquo; in such lists of arguments to call functions.</span></span></span>
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">apply</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This enables us to rewrite our test:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">o-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">6</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Something very important changed when we switched to the desugaring
strategy.  Do you see what it is?</p></blockquote></div></p><p><div class="SIntrapara">Recall the syntax definition we had earlier:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktMeta">msgC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">The &ldquo;name&rdquo; position of a message was very explicitly a
<span style="font-style: italic">symbol</span>.  That is, the developer had to write the literal name
of the symbol there.  In our desugared version, the name position is
just an expression that must evaluate to a symbol; for instance, one
could have written
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">o-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">string-&gt;symbol</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"add1"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">6</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">this</span><span class="hspace">&nbsp;</span><span class="RktCmt">also</span><span class="hspace">&nbsp;</span><span class="RktCmt">succeeds</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This is a general problem with desugaring: the target language may
allow expressions that have no counterpart in the source, and hence
cannot be mapped back to it.  Fortunately we don&rsquo;t often need to
perform this inverse mapping, though it does arise in some debugging
and program comprehension tools.  More subtly, however, we must ensure
that the target language does not produce <span style="font-style: italic">values</span> that have no
corresponding equivalent in the source.</div></p><p>Now that we have basic objects, let&rsquo;s start adding the kinds of
features we&rsquo;ve come to expect from most object systems.</p><h5>10.1.4<tt>&nbsp;</tt><a name="(part._.Constructors)"></a>Constructors</h5><p><div class="SIntrapara">A constructor is simply a function that is invoked at object
construction time.  We currently lack such a function.  by turning an
object from a literal into a function that takes constructor
parameters, we achieve this effect:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o-constr-1</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">addX</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o-constr-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">addX</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">8</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o-constr-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">addX</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In the first example, we pass <span class="stt">5</span> as the constructor&rsquo;s argument,
so adding <span class="stt">3</span> yields <span class="stt">8</span>.  The second is similar, and shows
that the two invocations of the constructors don&rsquo;t interfere with one
another.</div></p><h5>10.1.5<tt>&nbsp;</tt><a name="(part._.State)"></a>State</h5><p><div class="SIntrapara">Many people believe that objects primarily exist to encapsulate
state.<span class="refelem"><span class="refcolumn"><span class="refcontent">Alan Kay, who won a Turing Award for inventing
Smalltalk and modern object technology, disagrees.  In
<a href="http://www.smalltalk.org/smalltalk/TheEarlyHistoryOfSmalltalk_Abstract.html"><span style="font-style: italic">The Early History of Smalltalk</span></a>,
he says, &ldquo;[t]he small scale [motivation for OOP] was to find a more
flexible version of assignment, and then to try to eliminate it
altogether&rdquo;.  He adds, &ldquo;It is unfortunate that much of what is
called &lsquo;object-oriented programming&rsquo; today is simply old style
programming with fancier constructs. Many programs are loaded with
&lsquo;assignment-style&rsquo; operations now done by more expensive attached
procedures.&rdquo;</span></span></span>
We certainly haven&rsquo;t lost that ability.  If we desugar to a language
with variables (we could equivalently use boxes, in return for a
slight desugaring overhead), we can easily have multiple methods
mutate common state, such as a constructor argument:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o-state-1</span><span class="hspace">&nbsp;</span><span class="RktMeta">count</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">inc</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">count</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">count</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">dec</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">count</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">-</span><span class="hspace">&nbsp;</span><span class="RktMeta">count</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">get</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">count</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">For instance, we can test a sequence of operations:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o-state-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">inc</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">dec</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">get</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and also notice that mutating one object doesn&rsquo;t affect another:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">o1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o-state-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">o2</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o-state-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">o1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">inc</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">o1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">inc</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">o1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">get</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">o2</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">get</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><h5>10.1.6<tt>&nbsp;</tt><a name="(part._.Private_.Members)"></a>Private Members</h5><p><div class="SIntrapara">Another common object language feature is private members: ones that
are visible only inside the object, not outside
it.<span class="refelem"><span class="refcolumn"><span class="refcontent">Except that, in Java, instances of other classes of
the same type are privy to &ldquo;private&rdquo; members.  Otherwise, you would
simply never be able to implement an Abstract Data Type.</span></span></span>
These may seem like an additional feature we need to implement, but we
already have the necessary mechanism in the form of locally-scoped,
lexically-bound variables:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o-state-2</span><span class="hspace">&nbsp;</span><span class="RktMeta">init</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">count</span><span class="hspace">&nbsp;</span><span class="RktMeta">init</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">inc</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">count</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">count</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">dec</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">count</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">-</span><span class="hspace">&nbsp;</span><span class="RktMeta">count</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">get</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">count</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">The desugaring above provides no means for accessing <span class="stt">count</span>, and
lexical scoping ensures that it remains hidden to the world.</div></p><h5>10.1.7<tt>&nbsp;</tt><a name="(part._.Static_.Members)"></a>Static Members</h5><p><div class="SIntrapara">Another feature often valuable to users of objects is <span style="font-style: italic">static</span>
members: those that are common to all instances of the &ldquo;same&rdquo; type
of object.<span class="refelem"><span class="refcolumn"><span class="refcontent">We use quotes because there are many notions of
sameness for objects.  And then some.</span></span></span>
This, however, is merely a lexically-scoped
identifier (making it private) that lives outside the constructor
(making it common to all uses of the constructor):
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">o-static-1</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">counter</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">amount</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">counter</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">counter</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">inc</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">amount</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">amount</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">dec</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">amount</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">-</span><span class="hspace">&nbsp;</span><span class="RktMeta">amount</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">get</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">amount</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">count</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">counter</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">We&rsquo;ve written the counter increment where the &ldquo;constructor&rdquo; for this
object would go, though it could just as well be manipulated inside
the methods.</div></p><p><div class="SIntrapara">To test it, we should make multiple objects and ensure they each
affect the global count:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o-static-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1000</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">count</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o-static-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">count</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><h5>10.1.8<tt>&nbsp;</tt><a name="(part._.Objects_with_.Self-.Reference)"></a>Objects with Self-Reference</h5><p>Until now, our objects have simply been packages of named functions:
functions with multiple named entry-points, if you will.  We&rsquo;ve seen
that many of the features considered important in object systems are
actually simple patterns over functions and scope, and have indeed
been used&#8212;<wbr></wbr>without names assigned to them&#8212;<wbr></wbr>for decades by
programmers armed with <span class="stt">lambda</span>.</p><p>One characteristic that actually distinguishes object systems is that
each object is automatically equipped with a reference to the same
object,
often called <span class="stt">self</span> or <span class="stt">this</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">I prefer this
slightly dry way of putting it to the anthropomorphic &ldquo;knows about
itself&rdquo; terminology often adopted by object advocates.  Indeed, note
that we have gotten this far into object system properties without
ever needing to resort to anthropomorphism.</span></span></span>  Can we implement this
easily?</p><h5>10.1.8.1<tt>&nbsp;</tt><a name="(part._.Self-.Reference_.Using_.Mutation)"></a>Self-Reference Using Mutation</h5><p><div class="SIntrapara">Yes, we can, because we have seen just this very pattern when we
implemented recursion; we&rsquo;ll just generalize it now to refer not just
to the same box or function but to the same object.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">o-self!</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">dummy</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">first</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">second</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">second</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">self</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Observe that this is precisely the recursion pattern
(<a href="recursion.html#%28part._rec-fun%29" data-pltdoc="x">Recursive Functions</a>), adapted
slightly.  We&rsquo;ve tested it having <span class="stt">first</span> send a method to its
own <span class="stt">second</span>.  Sure enough, this produces the expected answer:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">o-self!</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">7</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><h5>10.1.8.2<tt>&nbsp;</tt><a name="(part._self-ref-wout-mut)"></a>Self-Reference Without Mutation</h5><p><div class="SIntrapara">If you studied how to implement recursion without mutation, you&rsquo;ll
notice that the same solution applies here, too.  Observe:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">o-self-no!</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">first</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg/self</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">second</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">second</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Each method now takes <span class="stt">self</span> as an argument.  That means method
invocation must be modified to follow this new pattern:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg/self</span><span class="hspace">&nbsp;</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">apply</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">That is, when invoking a method on <span class="stt">o</span>, we must pass <span class="stt">o</span> as
a parameter to the method.  Obviously, this approach is dangerous
because we can potentially pass a <span style="font-style: italic">different</span> object as the
&ldquo;<span class="stt">self</span>&rdquo;.  Exposing this to the developer is therefore probably
a bad idea; if this implementation technique is used, it should only
be done in desugaring.  <span class="refelem"><span class="refcolumn"><span class="refcontent">Nevertheless, Python exposes
just this <span style="font-style: italic">in its surface syntax</span>.  While this tribute to the
Y-combinator is touching, perhaps the resultant brittleness was
unnecessary.</span></span></span></div></p><h5>10.1.9<tt>&nbsp;</tt><a name="(part._.Dynamic_.Dispatch)"></a>Dynamic Dispatch</h5><p>Finally, we should make sure our objects can handle a characteristic
attribute of object systems, which is the ability to invoke a method
without the caller having to know or decide which object will handle
the invocation.  Suppose we have a binary tree data structure, where a
tree consists of either empty nodes or leaves that hold a value.  In
traditional functions, we are forced to implement the equivalent some
form of conditional&#8212;<wbr></wbr>either a <span class="stt">cond</span> or a <span class="stt">type-case</span> or
pattern-match or other moral equivalent&#8212;<wbr></wbr>that exhaustively lists and
selects between the different kinds of trees.  If the definition of a
tree grows to include new kinds of trees, each of these code fragments
must be modified.  Dynamic dispatch solves this problem by making that
conditional branch disappear from the user&rsquo;s program and instead be
handled by the method selection code <span style="font-style: italic">built into the language</span>.
The key feature that this provides is an
<span style="font-style: italic">extensible conditional</span>.
This is one dimension of the extensibility that objects
provide.<span class="refelem"><span class="refcolumn"><span class="refcontent">This property&#8212;<wbr></wbr>which appears to make systems
more <span style="font-style: italic">black-box extensible</span> because one part of the system can
grow without the other part needing to be modified to accommodate
those changes&#8212;<wbr></wbr>is often hailed as a key benefit of
object-orientation.  While this is indeed an advantage objects have
over functions, there is a dual advantage that functions have over
objects, and indeed many object programmers end up contorting their
code&#8212;<wbr></wbr>using the Visitor pattern&#8212;<wbr></wbr>to make it look more like a
function-based organization.  Read
<a href="http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/"><span style="font-style: italic">Synthesizing Object-Oriented and Functional Design to Promote Re-Use</span></a>
for a running example that will lay out the problem in its full
glory.  Try to solve it in your favorite language, and
see the
<a href="http://www.cs.utah.edu/plt/publications/icfp98-ff/paper.shtml">Racket solution</a>.</span></span></span></p><p><div class="SIntrapara">Let&rsquo;s now defined our two kinds of tree objects:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mt</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">dummy</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">add</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">self</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">node</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">r</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">dummy</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">add</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">add</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">add</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">self</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">With these, we can make a concrete tree:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">a-tree</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">node</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">node</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mt</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">node</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">15</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">node</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">6</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mt</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mt</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">And finally, test it:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">a-tree</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">add</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">15</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">6</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Observe that both in the test case and in the <span class="stt">add</span> method of
<span class="stt">node</span>, there is a reference to <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">add</span> without checking
whether the recipient is a <span class="stt">mt</span> or <span class="stt">node</span>.  Instead, the
run-time system extracts the recipient&rsquo;s <span class="stt">add</span> method and invokes
it.  This missing conditional in the user&rsquo;s program is the essence of
dynamic dispatch.</div></p><h4>10.2<tt>&nbsp;</tt><a name="(part._.Member_.Access_.Design_.Space)"></a>Member Access Design Space</h4><p><div class="SIntrapara">We already have two orthogonal dimensions when it comes to the
treatment of member names.  One dimension is whether the name is
provided statically or computed, and the other is whether the set of
names is fixed or variable:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p></p></td><td><p><span style="font-weight: bold">Name is Static</span></p></td><td><p><span style="font-weight: bold">Name is Computed</span></p></td></tr><tr><td><p><span style="font-weight: bold">Fixed Set of Members</span></p></td><td><p>As in base Java.</p></td><td><p>As in Java with reflection to compute the name.</p></td></tr><tr><td><p><span style="font-weight: bold">Variable Set of Members</span></p></td><td><p>Difficult to envision (what use would it be?).</p></td><td><p>Most scripting languages.</p></td></tr></table></div><div class="SIntrapara">Only one case does not quite make sense: if we force the developer to
specify the member name in the source file explicitly, then no new
members would be accessible (and some accesses to previously-existing,
but deleted, members would fail).  All other points in this design
space have, however, been explored by languages.</div></p><p>The lower-right quadrant corresponds closely with languages that use
hash-tables to represent objects.  Then the name is simply the index
into the hash-table.  Some languages carry this to an extreme and use
the same representation even for numeric indices, thereby (for
instance) conflating objects with dictionaries and even arrays.  Even
when the object only handles &ldquo;member names&rdquo;, this style of object
creates significant difficulty for type-checking [REF] and is hence
not automatically desirable.</p><p>Therefore, in the rest of this section, we will stick with
&ldquo;traditional&rdquo; objects that have a fixed set of names and even static
member name references (the top-left quadrant).  Even then, we will
find there is much, much more to study.</p><h4>10.3<tt>&nbsp;</tt><a name="(part._.What__.Goes_.In__.Else_)"></a>What (Goes In) Else?</h4><p>Until now, our <span class="stt">case</span> statements have not had an <span class="stt">else</span>
clause.  One reason to do so would be if we had a variable set of
members in an object, though that is probably better handled through a
different representation than a conditional: a hash-table, for
instance, as we&rsquo;ve discussed above.  In contrast, if an object&rsquo;s set
of members is fixed, desugaring to a conditional works well for the
purpose of illustration (because it <span style="font-style: italic">emphasizes</span> the fixed nature
of the set of member names, which a hash table leaves open to
interpretation&#8212;<wbr></wbr>and also error).  There is, however, another reason
for an <span class="stt">else</span> clause, which is to &ldquo;chain&rdquo; control to another,
<span style="font-style: italic">parent</span>, object.  This is called <span style="font-style: italic">inheritance</span>.</p><p>Let&rsquo;s return to our model of desugared objects above.  To implement
inheritance, the object must be given &ldquo;something&rdquo; to which it can
delegate method invocations that it does not recognize.  A great deal
will depend on what that &ldquo;something&rdquo; is.</p><p><div class="SIntrapara">One answer could be that it is simply another object.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">...</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">else</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">parent-object</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Due to our representation of objects, this application effectively
searches for the method in the parent object (and, presumably,
recursively in its parents).  If a method matching the name is found,
it returns through this chain to the original call in <span class="stt">msg</span> that
sought the method.  If none is found, the final object presumably
signals a &ldquo;message not found&rdquo; error.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Observe that the application <span class="stt">(parent-object m)</span> is like &ldquo;half a
<span class="stt">msg</span>&rdquo;, just like an l-value was &ldquo;half a value lookup&rdquo; [REF].
Is there any connection?</p></blockquote></div></p><p>Let&rsquo;s try this by extending our trees to implement another method,
<span class="stt">size</span>.  We&rsquo;ll write an &ldquo;extension&rdquo; (you may be tempted to say
&ldquo;sub-class&rdquo;, but hold off for now!) for each <span class="stt">node</span> and
<span class="stt">mt</span> to implement the <span class="stt">size</span> method.  We intend these to
extend the existing definitions of <span class="stt">node</span> and <span class="stt">mt</span>, so we&rsquo;ll
use the extension pattern described above.<span class="refelem"><span class="refcolumn"><span class="refcontent">We&rsquo;re not
editing the existing definitions because that is supposed to be the
whole point of object inheritance: to reuse code in a black-box
fashion.  This also means different parties, who do not know one
another, can each extend the same base code.  If they had to edit the
base, first they have to find out about each other, and in addition,
one might dislike the edits of the other.  Inheritance is meant to
sidestep these issues entirely.</span></span></span></p><h5>10.3.1<tt>&nbsp;</tt><a name="(part._.Classes)"></a>Classes</h5><p><div class="SIntrapara">Immediately we see a difficulty.  Is this the constructor pattern?
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">node/size</span><span class="hspace">&nbsp;</span><span class="RktMeta">parent-object</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">r</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">That suggests that the parent is at the &ldquo;same level&rdquo; as the object&rsquo;s
constructor fields.  That seems reasonable, in that once all these
parameters are given, the object is &ldquo;fully defined&rdquo;.  However,
we also still have
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">node</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">r</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Are we going to write all the parameters twice?  (Whenever we write
something twice, we should worry that we may not do so consistently,
thereby inducing subtle errors.)  Here&rsquo;s an alternative:
<span class="stt">node/size</span> can <span style="font-style: italic">construct the instance of <span class="stt">node</span></span> that
is its parent.  That is, <span class="stt">node/size</span>&rsquo;s parent parameter is not the
parent <span style="font-style: italic">object</span> but rather the parent&rsquo;s object <span style="font-style: italic">maker</span>.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">node/size</span><span class="hspace">&nbsp;</span><span class="RktMeta">parent-maker</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">r</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">parent-object</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">parent-maker</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">r</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">dummy</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">size</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">size</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">size</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">else</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">parent-object</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">self</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mt/size</span><span class="hspace">&nbsp;</span><span class="RktMeta">parent-maker</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">parent-object</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">parent-maker</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">self</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">dummy</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">self</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">case</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">size</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">else</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">parent-object</span><span class="hspace">&nbsp;</span><span class="RktMeta">m</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">self</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Then the object constructor must remember to pass the parent-object
maker on every invocation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">a-tree/size</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">node/size</span><span class="hspace">&nbsp;</span><span class="RktMeta">node</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">node/size</span><span class="hspace">&nbsp;</span><span class="RktMeta">node</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mt/size</span><span class="hspace">&nbsp;</span><span class="RktMeta">mt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mt/size</span><span class="hspace">&nbsp;</span><span class="RktMeta">mt</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">node/size</span><span class="hspace">&nbsp;</span><span class="RktMeta">node</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">15</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">node/size</span><span class="hspace">&nbsp;</span><span class="RktMeta">node</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">6</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mt/size</span><span class="hspace">&nbsp;</span><span class="RktMeta">mt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mt/size</span><span class="hspace">&nbsp;</span><span class="RktMeta">mt</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mt/size</span><span class="hspace">&nbsp;</span><span class="RktMeta">mt</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Obviously, this is something we might simplify with appropriate
syntactic sugar.  We can confirm that both the old and new tests still
work:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">a-tree/size</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">add</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">15</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">6</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">msg</span><span class="hspace">&nbsp;</span><span class="RktMeta">a-tree/size</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">size</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Rewrite this block of code using self-application instead of mutation.</p></blockquote></div></p><p><div class="SIntrapara">What we have done is capture the essence of a <span style="font-style: italic">class</span>.  Each
function parameterized over a parent is...well, it&rsquo;s a bit tricky,
really.  Let&rsquo;s call it a <span style="font-style: italic">blob</span> for now.  A blob corresponds to
what a Java programmer defines when they write a <span class="stt">class</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">class</span><span class="hspace">&nbsp;</span><span class="RktMeta">NodeSize</span><span class="hspace">&nbsp;</span><span class="RktMeta">extends</span><span class="hspace">&nbsp;</span><span class="RktMeta">Node</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>So why are we going out of the way to not call it a &ldquo;class&rdquo;?</p></blockquote></div></p><p>When a developer invokes a Java class&rsquo;s constructor, it in effect
constructs objects all the way up the inheritance chain (in practice,
a compiler might optimize this to require only one constructor
invocation and one object allocation).  These are private copies of
the objects corresponding to the parent classes (private, that is,
up to the presence of static members).  There is, however, a question
of how much of these objects is visible.  Java chooses that&#8212;<wbr></wbr>unlike
in our implementation above&#8212;<wbr></wbr>only one method of a given name (and
signature) remains, no matter how many there might have been on the
inheritance chain, whereas every field remains in the result, and can
be accessed by casting.  The latter makes some sense because each
field presumably has invariants governing it, so keeping them separate
(and hence all present) is wise.  In contrast, it is easy to imagine
an implementation that also makes all the methods available, not only
the ones lowest (i.e., most refined) in the inheritance hierarchy.
Many scripting languages take the latter approach.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>The code above is fundamentally broken.  The <span class="stt">self</span> reference is
to the same <span style="font-style: italic">syntactic</span> object, whereas it needs to refer to the
most-refined object: this is known as
<span style="font-style: italic">open recursion</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">This demonstrates the other form of
extensibility we get from traditional objects:
<span style="font-style: italic">extensible recursion</span>.</span></span></span>
Modify the object representations so that <span class="stt">self</span> always refers to
the most refined version of the object.  Hint: You will find the
self-application method (<a href="#%28part._self-ref-wout-mut%29" data-pltdoc="x">Self-Reference Without Mutation</a>)
of recursion handy.</p></blockquote></div></p><h5>10.3.2<tt>&nbsp;</tt><a name="(part._.Prototypes)"></a>Prototypes</h5><p>In our description above, we&rsquo;ve supplied each class with a description
of its parent <span style="font-style: italic">class</span>.  Object construction then makes instances
of each as it goes up the inheritance chain.  There is another way to
think of the parent: not as a class to be instantiated but, instead,
directly as an object itself.  Then all children with the same parent
would observe the very same object, which means changes to it from one
child object would be visible to another child.  The shared parent
object is known as a <span style="font-style: italic">prototype</span>.</p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">The archetypal prototype-based language is
<a href="http://selflanguage.org/">Self</a>.
Though you may have read that languages like JavaScript are &ldquo;based
on&rdquo; Self, there is value to studying the idea from its source,
especially because Self presents these ideas in their purest form.</span></span></span>
Some language designers have argued that prototypes are more primitive
than classes in that, with other basic mechanisms such as functions,
one can recover classes from prototypes&#8212;<wbr></wbr>but not the other way
around.  That is essentially what we have done above: each &ldquo;class&rdquo;
function contains inside it an object description, so a class is an
object-returning-function.  Had we exposed these are two different
operations and chosen to inherit directly an object, we would have
something akin to prototypes.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Modify the inheritance pattern above to implement a Self-like,
prototype-based language, instead of a class-based language.
Because classes provide each object with distinct copies of their
parent objects, a prototype-language might provide a <span style="font-style: italic">clone</span>
operation to simplify creation of the operation that simulates classes
atop prototypes.</p></blockquote></div></p><h5>10.3.3<tt>&nbsp;</tt><a name="(part._.Multiple_.Inheritance)"></a>Multiple Inheritance</h5><p>Now you might ask, why is there only one fall-through option?
It&rsquo;s easy to generalize this to there being many, which leads naturally
to <span style="font-style: italic">multiple inheritance</span>.  In effect, we have multiple objects to
which we can chain the lookup, which of course raises the question of
what order in which we should do so.  It would be bad enough if the
ascendants were arranged in a tree, because even a tree does not have
a canonical order of traversal: take just breadth-first and
depth-first traversal, for instance (each of which has compelling
uses).  Worse, suppose a blob <span class="stt">A</span> extends <span class="stt">B</span> and <span class="stt">C</span>;
but now suppose <span class="stt">B</span> and <span class="stt">C</span> each extend
<span class="stt">D</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">This infamous situation is called
<span style="font-style: italic">diamond inheritance</span>.  If you choose to include multiple
inheritance in your language you can lose yourself for days in design
decisions on this.  Because it is highly unlikely you will find a
canonical answer, your pain will have only begun.</span></span></span>  Now we have to
confront this question: will there be one or two <span class="stt">D</span> objects in
the instance of <span class="stt">A</span>?  Having only one saves space and might
interact better with our expectations, but then, will we visit this
object once or twice?  Visiting it twice should not make any
difference, so it seems unnecessary. But visiting it once means the
behavior of one of <span class="stt">B</span> or <span class="stt">C</span> might change.  And so on.  As
a result, virtually every multiple-inheritance language is accompanied
by a subtle algorithm merely to define the lookup order.</p><p>Multiple inheritance is only attractive until you&rsquo;ve thought it
through.</p><h5>10.3.4<tt>&nbsp;</tt><a name="(part._.Super-.Duper_)"></a>Super-Duper!</h5><p>Many languages have a notion of super-invocations, i.e., the ability
to invoke a method or access a field higher up in the inheritance
chain.<span class="refelem"><span class="refcolumn"><span class="refcontent">Note that I say &ldquo;the&rdquo; and &ldquo;chain&rdquo;.  When we
switch to multiple inheritance, these concepts are replaced with
something much more complex.</span></span></span>
This includes doing so at the point of object construction, where
there is often a requirement that all constructors be invoked, to make
sure the object is properly defined.</p><p>We have become so accustomed to thinking of these calls as going
&ldquo;up&rdquo; the chain that we may have forgotten to ask whether this is the
most natural direction.  Keep in mind that constructors and methods
are expected to enforce <span style="font-style: italic">invariants</span>.  Whom should we trust more:
the super-class or the sub-class?  One argument would say that the
sub-class is most refined, so it has the most global view of the
object.  Conversely, each super-class has a vested interest in
protecting its invariants against violation by ignorant sub-classes.</p><p>These are two fundamentally opposed views of what inheritance means.
Going up the chain means we view the extension as <span style="font-style: italic">replacing</span> the
parent.  Going down the chain means we view the extension as
<span style="font-style: italic">refining</span> the parent.  Because we normally associate
sub-classing with refinement, why do our languages choose the
&ldquo;wrong&rdquo; order of calling?  Some languages have, therefore, explored
invocation in the downward direction by default.<span class="refelem"><span class="refcolumn"><span class="refcontent"><a href="http://www.daimi.au.dk/~eernst/gbeta/">gbeta</a>
is a modern programming language that supports
<span class="stt">inner</span>, as well as many other interesting features.
It is also interesting to consider
<a href="http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf">combining both directions</a>.</span></span></span></p><h5>10.3.5<tt>&nbsp;</tt><a name="(part._.Mixins_and_.Traits)"></a>Mixins and Traits</h5><p>Let&rsquo;s return to our &ldquo;blobs&rdquo;.</p><p>When we write a <span class="stt">class</span> in Java, what are we really defining
between the opening and closing braces?  It is not the entire class:
that depends on the parent that it extends, and so on recursively.
Rather, what we define inside the braces is a <span style="font-style: italic">class extension</span>.
It only becomes a full-blown class because we <span style="font-style: italic">also</span> identify the
parent class in the same place.</p><p><div class="SIntrapara">Naturally, we should ask: Why?  Why not separate the act of
<span style="font-style: italic">defining an extension</span> from <span style="font-style: italic">applying the extension to a
base class</span>?  That is, suppose instead of
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">class</span><span class="hspace">&nbsp;</span><span class="RktMeta">C</span><span class="hspace">&nbsp;</span><span class="RktMeta">extends</span><span class="hspace">&nbsp;</span><span class="RktMeta">B</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">we instead write:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">classext</span><span class="hspace">&nbsp;</span><span class="RktMeta">E</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and separately
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">class</span><span class="hspace">&nbsp;</span><span class="RktMeta">C</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">E</span><span class="RktPn">(</span><span class="RktMeta">B</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">where <span class="stt">B</span> is some already-defined class.</div></p><p><div class="SIntrapara">Thusfar, it looks like we&rsquo;ve just gone to great lengths to obtain what
we had before.  However, the function-application-like syntax is meant
to be suggestive: we can &ldquo;apply&rdquo; this extension to several different
base classes.  Thus:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">class</span><span class="hspace">&nbsp;</span><span class="RktMeta">C1</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">E</span><span class="RktPn">(</span><span class="RktMeta">B1</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">class</span><span class="hspace">&nbsp;</span><span class="RktMeta">C2</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">E</span><span class="RktPn">(</span><span class="RktMeta">B2</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and so on.  What we have done by separating the definition of <span class="stt">E</span>
from that of the class it extends is to <span style="font-style: italic">liberate class
extensions from the tyranny of the fixed base class</span>.  We have a name
for these extensions: they&rsquo;re called
<span style="font-style: italic">mixins</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">The term &ldquo;mixin&rdquo; originated in
Common Lisp, where it was a particular pattern of using multiple
inheritance.   Lipstick on a pig.</span></span></span></div></p><p>Mixins make class definition more compositional.  They provide many of
the benefits of multiple-inheritance (reusing multiple fragments of
functionality) but within the aegis of a single-inheritance language
(i.e., no complicated rules about lookup order).  Observe that when
desugaring, it&rsquo;s actually quite easy to add mixins to the language.  A
mixin is primarily a &ldquo;function over classes&rsquo;;.  Because we have
already determined how to desugar classes, and our target language for
desugaring also has functions, and classes desugar to expressions that
can be nested inside functions, it becomes almost trivial to implement
a simple model of mixins.<span class="refelem"><span class="refcolumn"><span class="refcontent">This is a case where the
greater generality of the target language of desugaring can lead us to
a <span style="font-style: italic">better</span> construct, if we reflect it back into the source
language.</span></span></span></p><p>In a typed language, a good design for mixins can actually improve
object-oriented programming practice.  Suppose we&rsquo;re defining a
mixin-based version of Java.  If a mixin is effectively a
class-to-class function, what is the &ldquo;type&rdquo; of this &ldquo;function&rdquo;?
Clearly, mixin ought to use <span style="font-style: italic">interfaces</span> to describe what it
expects and provides.  Java already enables (but does not require) the
latter, but it does not enable the former: a class (extension) extends
another <span style="font-style: italic">class</span>&#8212;<wbr></wbr>with all its members visible to the
extension&#8212;<wbr></wbr>not its <span style="font-style: italic">interface</span>.  That means it
obtains all of the parent&rsquo;s behavior, not a specification thereof.
In turn, if the parent changes, the class might break.</p><p><div class="SIntrapara">In a mixin language, we can instead write
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">mixin</span><span class="hspace">&nbsp;</span><span class="RktMeta">M</span><span class="hspace">&nbsp;</span><span class="RktMeta">extends</span><span class="hspace">&nbsp;</span><span class="RktMeta">I</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">where <span class="stt">I</span> is an interface.  Then <span class="stt">M</span> can only be applied to
a class that satisfies the interface <span class="stt">I</span>, and in turn the
language can <span style="font-style: italic">ensure that only members specified in <span class="stt">I</span> are
visible in <span class="stt">M</span></span>.  This follows one of the important principles of
good software design.<span class="refelem"><span class="refcolumn"><span class="refcontent">&ldquo;Program to an interface, not an
implementation.&rdquo; &#8212;<wbr></wbr><span style="font-style: italic">Design Patterns</span></span></span></span></div></p><p>A good design for mixins can go even further.  A class can only be
used once in an inheritance chain, by definition (if a class
eventually referred back to itself, there would be a cycle in the
inheritance chain, causing potential infinite loops).  In contrast,
when we compose functions, we have no qualms about using the same
function twice (e.g.: <span class="stt">(map ... (filter ... (map ...)))</span>).  Is
there value to using a mixin twice?<span class="refelem"><span class="refcolumn"><span class="refcontent">There certainly is!
See sections 3 and 4 of
<a href="http://www.cs.brown.edu/~sk/Publications/Papers/Published/fkf-classes-mixins/"><span style="font-style: italic">Classes and Mixins</span></a>.</span></span></span></p><p>Mixins solve an important problem that arises in the design of
libraries.  Suppose we have a dozen different features which can be
combined in different ways.  How many classes should we provide?
Furthermore, not all of these can be combined with each other.  It is
obviously impractical to generate the entire combinatorial explosion
of classes.  It would be better if the devleoper could pick and choose
the features they care about, with some mechanism to prevent
unreasonable combinations.  This is precisely the problem that mixins
solve: they provide the class extensions, which the developers can
combine, in an interface-preserving way, to create just the
classes they need.<span class="refelem"><span class="refcolumn"><span class="refcontent">Mixins are used extensively in the
Racket GUI library.  For instance, <span class="stt">color:text-mixin</span> consumes
basic text editor interfaces and implements the colored text editor
interface.  The latter is iself a basic text editor interface, so
additional basic text mixins can be applied to the result.</span></span></span></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>How does your favorite object-oriented library solve this problem?</p></blockquote></div></p><p>Mixins do have one limitation: they enforce a linearity of
composition.  This strictness is sometimes misplaced, because it puts
a burden on programmers that may not be necessary.  A generalization
of mixins called <span style="font-style: italic">traits</span> says that instead of extending a single
mixin, we can extend a <span style="font-style: italic">set</span> of them.  Of course, the moment we
extend more than one, we must again contend with potential
name-clashes.  Thus traits must be equipped with mechanisms for
resolving name clashes, often in the form of some name-combination
algebra.  Traits thus offer a nice complement to mixins, enabling
programmers to choose the mechanism that best fits their needs.  As a
result, Racket provides both mixins and traits.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="recursion.html" title="backward to &quot;9 Recursion and Cycles: Procedures and Data&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Memory_Management.html" title="forward to &quot;11 Memory Management&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>