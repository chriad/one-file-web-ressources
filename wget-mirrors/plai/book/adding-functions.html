<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>5&nbsp;Adding Functions to the Language</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Introduction.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Everything__We_Will_Say__About_Parsing.html" class="tocviewlink" data-pltdoc="x">Everything (We Will Say) About Parsing</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="first-interp.html" class="tocviewlink" data-pltdoc="x">A First Look at Interpretation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="first-desugar.html" class="tocviewlink" data-pltdoc="x">A First Taste of Desugaring</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Adding Functions to the Language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="From_Substitution_to_Environments.html" class="tocviewlink" data-pltdoc="x">From Substitution to Environments</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="higher-order-functions.html" class="tocviewlink" data-pltdoc="x">Functions Anywhere</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="mut-struct-vs-var.html" class="tocviewlink" data-pltdoc="x">Mutation:<span class="mywbr"> &nbsp;</span> Structures and Variables</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="recursion.html" class="tocviewlink" data-pltdoc="x">Recursion and Cycles:<span class="mywbr"> &nbsp;</span> Procedures and Data</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Objects.html" class="tocviewlink" data-pltdoc="x">Objects</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Memory_Management.html" class="tocviewlink" data-pltdoc="x">Memory Management</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Representation_Decisions.html" class="tocviewlink" data-pltdoc="x">Representation Decisions</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Desugaring_as_a_Language_Feature.html" class="tocviewlink" data-pltdoc="x">Desugaring as a Language Feature</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Control_Operations.html" class="tocviewlink" data-pltdoc="x">Control Operations</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="types.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Statically:<span class="mywbr"> &nbsp;</span> Types</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="contracts.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Dynamically:<span class="mywbr"> &nbsp;</span> Contracts</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Alternate_Application_Semantics.html" class="tocviewlink" data-pltdoc="x">Alternate Application Semantics</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>5&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Adding Functions to the Language</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">5.1&nbsp;</td><td><a href="#%28part._.Defining_.Data_.Representations%29" class="tocviewlink" data-pltdoc="x">Defining Data Representations</a></td></tr><tr><td align="right">5.2&nbsp;</td><td><a href="#%28part._.Growing_the_.Interpreter%29" class="tocviewlink" data-pltdoc="x">Growing the Interpreter</a></td></tr><tr><td align="right">5.3&nbsp;</td><td><a href="#%28part._.Substitution%29" class="tocviewlink" data-pltdoc="x">Substitution</a></td></tr><tr><td align="right">5.4&nbsp;</td><td><a href="#%28part._fof-interp-resumed%29" class="tocviewlink" data-pltdoc="x">The Interpreter, Resumed</a></td></tr><tr><td align="right">5.5&nbsp;</td><td><a href="#%28part._eager-lazy-subst%29" class="tocviewlink" data-pltdoc="x">Oh Wait, There&rsquo;s More!</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">5.1<tt>&nbsp;</tt></span><a href="#%28part._.Defining_.Data_.Representations%29" class="tocsubseclink" data-pltdoc="x">Defining Data Representations</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cfundef~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;fundef&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cexpr.C~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;exprC&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cid.C-def~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;idC-def&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3capp-def~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;app-def&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">5.2<tt>&nbsp;</tt></span><a href="#%28part._.Growing_the_.Interpreter%29" class="tocsubseclink" data-pltdoc="x">Growing the Interpreter</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cinterp~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;interp&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cinterp-body~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;interp-body&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">5.3<tt>&nbsp;</tt></span><a href="#%28part._.Substitution%29" class="tocsubseclink" data-pltdoc="x">Substitution</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3csubst~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;subst&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3csubst-body~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;subst-body&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">5.4<tt>&nbsp;</tt></span><a href="#%28part._fof-interp-resumed%29" class="tocsubseclink" data-pltdoc="x">The Interpreter, Resumed</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3capp.C-interp-case-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-interp-case-take-1&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3capp.C-interp-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-interp-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cid.C-interp-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;idC-interp-case&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">5.5<tt>&nbsp;</tt></span><a href="#%28part._eager-lazy-subst%29" class="tocsubseclink" data-pltdoc="x">Oh Wait, There&rsquo;s More!</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="first-desugar.html" title="backward to &quot;4 A First Taste of Desugaring&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="From_Substitution_to_Environments.html" title="forward to &quot;6 From Substitution to Environments&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>5<tt>&nbsp;</tt><a name="(part._adding-functions)"></a>Adding Functions to the Language</h3><p>Let&rsquo;s start turning this into a real programming language.  We could
add intermediate features such as conditionals, but to do almost
anything interesting we&rsquo;re going to need functions or their moral
equivalent, so let&rsquo;s get to it.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Add conditionals to your language.  You can either add boolean
datatypes or, if you want to do something quicker, add a conditional
that treats <span class="stt">0</span> as false and everything else as true.</p><p>What are the important test cases you should write?</p></blockquote></div></p><p><div class="SIntrapara">Imagine, therefore, that we&rsquo;re modeling a system like DrRacket.  The
developer defines functions in the definitions window, and uses them
in the interactions window.  For now, let&rsquo;s assume all definitions go
in the definitions window only (we&rsquo;ll relax this soon [REF]), and all
expressions in the interactions window only.  Thus, running a program
simply loads definitions.  Because our interpreter corresponds to the
interactions window prompt, we&rsquo;ll therefore assume it is supplied with
a set of definitions.</div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>A <span style="font-style: italic">set</span> of definitions suggests
no ordering, which means, presumably, any definition can refer to any
other.  That&rsquo;s what I intend here, but when you are designing your own
language, be sure to think about this.</p></blockquote></blockquote></blockquote></div></p><h4>5.1<tt>&nbsp;</tt><a name="(part._.Defining_.Data_.Representations)"></a>Defining Data Representations</h4><p><div class="SIntrapara">To keep things simple, let&rsquo;s just consider functions of one argument.
Here are some Racket examples:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">double</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">quadruple</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">double</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">double</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">const5</span><span class="hspace">&nbsp;</span><span class="RktMeta">_</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>When a function has multiple arguments, what simple but important
criterion governs the names of those arguments?</p></blockquote></div></p><p>What are the parts of a function definition?  It has a name (above,
<span class="stt">double</span>, <span class="stt">quadruple</span>, and <span class="stt">const5</span>), which we&rsquo;ll
represent as a symbol (<span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">double</span>, etc.); its
<span style="font-style: italic">formal parameter</span> or
<span style="font-style: italic">argument</span> has a name (e.g., <span class="stt">x</span>), which too we
can model as a symbol (<span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">x</span>); and it has a body.  We&rsquo;ll
determine the body&rsquo;s representation in stages, but let&rsquo;s start to lay
out a datatype for function definitions:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cfundef~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cfundef~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;fundef&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define-type</span><span class="hspace">&nbsp;</span><span class="RktSym">FunDefC</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">fdC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">name</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">symbol</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">arg</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">symbol</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">body</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>What is the body?  Clearly, it has the form of an arithmetic
expression, and sometimes it can even be represented using the
existing <span class="stt">ArithC</span> language: for instance, the body of
<span class="stt">const5</span> can be represented as <span class="stt">(numC 5)</span>.  But representing
the body of <span class="stt">double</span> requires something more: not just addition
(which we have), but also &ldquo;<span class="stt">x</span>&rdquo;.  You are probably used to
calling this a <span style="font-style: italic">variable</span>, but we will <span style="font-style: italic">not</span> use that term
for now.  Instead, we will call it an <span style="font-style: italic">identifier</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">I
promise we&rsquo;ll return to this issue of nomenclature later [REF].</span></span></span></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Anything else?</p></blockquote></div></p><p>Finally, let&rsquo;s look at the body of <span class="stt">quadruple</span>.  It has yet
another new construct: a function <span style="font-style: italic">application</span>.  Be very careful
to distinguish between a function <span style="font-style: italic">definition</span>, which describes
what the function is, and an <span style="font-style: italic">application</span>, which uses it.  These
are uses.  The <span style="font-style: italic">argument</span> (or <span style="font-style: italic">actual parameter</span>) in the inner
application of <span class="stt">double</span> is <span class="stt">x</span>; the argument in the outer
application is <span class="stt">(double x)</span>.  Thus, the argument can be any
complex expression.</p><p>Let&rsquo;s commit all this to a crisp datatype.  Clearly we&rsquo;re extending
what we had before (because we still want all of arithmetic).  We&rsquo;ll
give a new name to our datatype to signify that it&rsquo;s growing up:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cexpr.C~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cexpr.C~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;exprC&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define-type</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">numC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">number</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cid.C-def~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;idC-def&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3capp-def~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;app-def&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">plusC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">multC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Identifiers are closely related to formal parameters.  When we apply a
function by giving it a value for its parameter, we are in effect
asking it to replace all instances of that formal parameter in the
body&#8212;<wbr></wbr>i.e., the identifiers with the same name as the formal
parameter&#8212;<wbr></wbr>with that value.<span class="refelem"><span class="refcolumn"><span class="refcontent">Observe that we are being
coy about a few issues: what kind of &ldquo;value&rdquo; [REF] and when to
replace [REF].</span></span></span>  To simplify this process of search-and-replace, we
might as well use the same datatype to represent both.  We&rsquo;ve
already chosen symbols to represent formal parameters, so:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cid.C-def~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cid.C-def~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;idC-def&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">idC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">s</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">symbol</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>Finally, applications.  They have two parts: the function&rsquo;s name, and
its argument.  We&rsquo;ve already agreed that the argument can be any
full-fledged expression (including identifiers and other
applications).  As for the function name, it again makes sense to use
the same datatype as we did when giving the function its name in a
function definition.  Thus:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3capp-def~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3capp-def~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;app-def&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">appC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fun</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">symbol</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">arg</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>identifying which function to apply, and providing its argument.</p><p><div class="SIntrapara">Using these definitions, it&rsquo;s instructive to write out the
representations of the examples we defined above:
</div><div class="SIntrapara"><ul><li><p><span class="stt">(fdC </span><span class="stt">&rsquo;</span><span class="stt">double </span><span class="stt">&rsquo;</span><span class="stt">x (plusC (idC </span><span class="stt">&rsquo;</span><span class="stt">x) (idC </span><span class="stt">&rsquo;</span><span class="stt">x)))</span></p></li><li><p><span class="stt">(fdC </span><span class="stt">&rsquo;</span><span class="stt">quadruple </span><span class="stt">&rsquo;</span><span class="stt">x (appC </span><span class="stt">&rsquo;</span><span class="stt">double (appC </span><span class="stt">&rsquo;</span><span class="stt">double (idC </span><span class="stt">&rsquo;</span><span class="stt">x))))</span></p></li><li><p><span class="stt">(fdC </span><span class="stt">&rsquo;</span><span class="stt">const5 </span><span class="stt">&rsquo;</span><span class="stt">_ (numC 5))</span></p></li></ul></div><div class="SIntrapara">We also need to choose a representation for a set of function
definitions.  It&rsquo;s convenient to represent these by a
list.</div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Look out!  Did you notice that we spoke of a
<span style="font-style: italic">set</span> of function definitions, but chose a <span style="font-style: italic">list</span>
representation?  That means we&rsquo;re using an ordered collection of data
to represent an unordered entity.  At the very least, then, when
testing, we should use any and all permutations of definitions to
ensure we haven&rsquo;t subtly built in a dependence on the order.</p></blockquote></blockquote></blockquote></div></p><h4>5.2<tt>&nbsp;</tt><a name="(part._.Growing_the_.Interpreter)"></a>Growing the Interpreter</h4><p>Now we&rsquo;re ready to tackle the interpreter proper.  First, let&rsquo;s remind
ourselves of what it needs to consume.  Previously, it consumed only
an expression to evaluate.  Now it also needs to take a list of
function definitions:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cinterp~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cinterp~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;interp&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">fds</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">listof</span><span class="hspace">&nbsp;</span><span class="RktSym">FunDefC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">number</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cinterp-body~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;interp-body&gt;</a><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Let&rsquo;s revisit our old interpreter (<a href="first-interp.html" data-pltdoc="x">A First Look at Interpretation</a>).  In the
case of numbers, clearly we still return the number as the answer.  In
the addition and multiplication case, we still need to recur (because
the sub-expressions might be complex), but which set of function
definitions do we use?  Because the act of evaluating an expression
neither adds nor removes function <span style="font-style: italic">definitions</span>, the set of
definitions remains the same, and should just be passed along
unchanged in the recursive calls.</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cinterp-body~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cinterp-body~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;interp-body&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">numC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cid.C-interp-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;idC-interp-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3capp.C-interp-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-interp-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">plusC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">multC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Now let&rsquo;s tackle application.  First we have to look up the function
definition, for which we&rsquo;ll assume we have a helper function of this
type available:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">get-fundef</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">*</span><span class="hspace">&nbsp;</span><span class="RktCmt">(listof</span><span class="hspace">&nbsp;</span><span class="RktCmt">FunDefC)</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">FunDefC</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Assuming we find a function of the given name, we need to evaluate its
body.  However, remember what we said about identifiers and
parameters?  We must &ldquo;search-and-replace&rdquo;, a process you have seen
before in school algebra called <span style="font-style: italic">substitution</span>.  This is
sufficiently important that we should talk first about substitution
before returning to the interpreter (<a href="#%28part._fof-interp-resumed%29" data-pltdoc="x">The Interpreter, Resumed</a>).</div></p><h4>5.3<tt>&nbsp;</tt><a name="(part._.Substitution)"></a>Substitution</h4><p>Substitution is the act of replacing a name (in this case, that of the
formal parameter) in an expression (in this case, the body of the
function) with another expression (in this case, the actual
parameter).  Let&rsquo;s define its type:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">subst</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprC</span><span class="hspace">&nbsp;</span><span class="RktCmt">*</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">*</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprC</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprC</span><span class="RktMeta"></span></td></tr></table></blockquote><p>It helps to also give its parameters informative names:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3csubst~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3csubst~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;subst&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">subst</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">what</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">for</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">symbol</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">in</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3csubst-body~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;subst-body&gt;</a><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>The first argument is what we want to replace the name with; the
second is for what name we want to perform substitution; and the third
is in which expression we want to do it.</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Suppose we want to substitute <span class="stt">3</span> for the identifier <span class="stt">x</span> in
the bodies of the three example functions above.  What should it
produce?</p></blockquote></div></p><p><div class="SIntrapara">In <span class="stt">double</span>, this should produce <span class="stt">(+ 3 3)</span>; in
<span class="stt">quadruple</span>, it should produce <span class="stt">(double (double 3))</span>; and in
<span class="stt">const5</span>, it should produce <span class="stt">5</span> (i.e., no substitution
happens because there are no instances of <span class="stt">x</span> in the
body).</div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>A common mistake is to assume that the result of
substituting, e.g., <span class="stt">3</span> for <span class="stt">x</span> in <span class="stt">double</span> is
<span class="stt">(define (double x) (+ 3 3))</span>.  This is incorrect.  We only
substitute <span style="font-style: italic">at the point when we apply the function</span>, at which
point the function&rsquo;s invocation is replaced by its body.  The header
enables us to find the function and ascertain the name of its
parameter; but only its body remains for evaluation.  Examine how
substitution is used to notice the type error that would result from
returning a function definition.</p></blockquote></blockquote></blockquote></div></p><p>These examples already tell us what to do in almost all the cases.
Given a number, there&rsquo;s nothing to substitute.  If it&rsquo;s an identifier,
we haven&rsquo;t seen an example with a <span style="font-style: italic">different</span> identifier but
you&rsquo;ve guessed what should happen: it stays unchanged.  In the other
cases, descend into the sub-expressions, performing substitution.</p><p>Before we turn this into code, there&rsquo;s an important case to consider.
Suppose the name we are substituting happens to be the name of a
function.  Then what should happen?</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>What, indeed, should happen?</p></blockquote></div></p><p>There are many ways to approach this question.  One is from a design
perspective: function names live in their own &ldquo;world&rdquo;, distinct from
ordinary program identifiers.  Some languages (such as C and Common
Lisp, in slightly different ways) take this perspective, and partition
identifiers into different <span style="font-style: italic">namespaces</span> depending on how they are
used.  In other languages, there is no such distinction; indeed, we
will examine such languages soon [REF].</p><p>For now, we will take a pragmatic viewpoint.  Because expressions
evaluate to numbers, that means a function name could turn into a
number.  However, numbers cannot name functions, only symbols can.
Therefore, it makes no sense to substitute in that position, and we
should leave the function name unmolested irrespective of its
relationship to the variable being substituted.  (Thus, a function
could have a parameter named <span class="stt">x</span> as well as refer to another
<span style="font-style: italic">function</span> called <span class="stt">x</span>, and these would be kept distinct.)</p><p>Now we&rsquo;ve made all our decisions, and we can provide the body code:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3csubst-body~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3csubst-body~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;subst-body&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="hspace">&nbsp;</span><span class="RktSym">in</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">numC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">in</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">idC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">symbol=?</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="hspace">&nbsp;</span><span class="RktSym">for</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">what</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">else</span><span class="hspace">&nbsp;</span><span class="RktSym">in</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">appC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">appC</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">subst</span><span class="hspace">&nbsp;</span><span class="RktSym">what</span><span class="hspace">&nbsp;</span><span class="RktSym">for</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">plusC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">plusC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">subst</span><span class="hspace">&nbsp;</span><span class="RktSym">what</span><span class="hspace">&nbsp;</span><span class="RktSym">for</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">subst</span><span class="hspace">&nbsp;</span><span class="RktSym">what</span><span class="hspace">&nbsp;</span><span class="RktSym">for</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">multC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">multC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">subst</span><span class="hspace">&nbsp;</span><span class="RktSym">what</span><span class="hspace">&nbsp;</span><span class="RktSym">for</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">subst</span><span class="hspace">&nbsp;</span><span class="RktSym">what</span><span class="hspace">&nbsp;</span><span class="RktSym">for</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Observe that, whereas in the <span class="stt">numC</span> case the interpreter returned
<span class="stt">n</span>, substitution returns <span class="stt">in</span> (i.e., the original
expression, equivalent at that point to writing <span class="stt">(numC n)</span>.
Why?</p></blockquote></div></p><h4>5.4<tt>&nbsp;</tt><a name="(part._fof-interp-resumed)"></a>The Interpreter, Resumed</h4><p>Phew!  Now that we&rsquo;ve completed the definition of substitution (or so
we think), let&rsquo;s complete the interpreter.  Substitution was a
heavyweight step, but it also does much of the work involved in
applying a function.  It is tempting to write</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3capp.C-interp-case-take-1~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3capp.C-interp-case-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-interp-case-take-1&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">appC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">local</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">fd</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">get-fundef</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">subst</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fdC-arg</span><span class="hspace">&nbsp;</span><span class="RktSym">fd</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fdC-body</span><span class="hspace">&nbsp;</span><span class="RktSym">fd</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>Tempting, but wrong.</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Do you see why?</p></blockquote></div></p><p>Reason from the types.  What does the interpreter return?  Numbers.
What does substitution return?  Oh, that&rsquo;s right, expressions!  For
instance, when we substituted in the body of <span class="stt">double</span>, we got
back the representation of <span class="stt">(+ 5 5)</span>.  This is not a valid answer
for the interpreter.  Instead, it must be reduced to an answer.  That,
of course, is precisely what the interpreter does:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3capp.C-interp-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3capp.C-interp-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;appC-interp-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">appC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">local</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">fd</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">get-fundef</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">subst</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fdC-arg</span><span class="hspace">&nbsp;</span><span class="RktSym">fd</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fdC-body</span><span class="hspace">&nbsp;</span><span class="RktSym">fd</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">fds</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>Okay, that leaves only one case: identifiers.  What could possibly be
complicated about them?  They should be just about as simple as
numbers!  And yet we&rsquo;ve put them off to the very end, suggesting
something subtle or complex is afoot.</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Work through some examples to understand what the interpreter should
do in the identifier case.</p></blockquote></div></p><p><div class="SIntrapara">Let&rsquo;s suppose we had defined <span class="stt">double</span> as follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">double</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>When we substitute <span class="stt">5</span> for <span class="stt">x</span>, this produces the expression
<span class="stt">(+ 5 y)</span>.  So far so good, but what is left to substitute
<span class="stt">y</span>?  As a matter of fact, it should be clear from the very
outset that this definition of <span class="stt">double</span> is <span style="font-style: italic">erroneous</span>.  The
identifier <span class="stt">y</span> is said to be <span style="font-style: italic">free</span>, an adjective that in
this setting has negative connotations.</p><p>In other words, the interpreter should never confront an identifier.
All identifiers ought to be parameters that have already been
substituted (known as <span style="font-style: italic">bound</span> identifiers&#8212;<wbr></wbr>here, a positive
connotation) before the interpreter ever sees them.  As a result,
there is only one possible response given an identifier:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cid.C-interp-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cid.C-interp-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;idC-interp-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">idC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">_</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">interp</span><span class="hspace">&nbsp;</span><span class="RktVal">"shouldn't get here"</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>And that&rsquo;s it!</p><p>Finally, to complete our interpreter, we should define
<span class="stt">get-fundef</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">get-fundef</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">fds</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">FunDefC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">FunDefC</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">cond</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">empty?</span><span class="hspace">&nbsp;</span><span class="RktMeta">fds</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">error</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">get-fundef</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"reference</span><span class="hspace">&nbsp;</span><span class="RktVal">to</span><span class="hspace">&nbsp;</span><span class="RktVal">undefined</span><span class="hspace">&nbsp;</span><span class="RktVal">function"</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">cons?</span><span class="hspace">&nbsp;</span><span class="RktMeta">fds</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">cond</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">equal?</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fdC-name</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta">fds</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta">fds</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">else</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">get-fundef</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rest</span><span class="hspace">&nbsp;</span><span class="RktMeta">fds</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><h4>5.5<tt>&nbsp;</tt><a name="(part._eager-lazy-subst)"></a>Oh Wait, There&rsquo;s More!</h4><p>Earlier, we gave the following type to <span class="stt">subst</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">subst</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprC</span><span class="hspace">&nbsp;</span><span class="RktCmt">*</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">*</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprC</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprC</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Sticking to surface syntax for brevity, suppose we apply <span class="stt">double</span>
to <span class="stt">(+ 1 2)</span>.  This would substitute <span class="stt">(+ 1 2)</span> for each
<span class="stt">x</span>, resulting in the following
expression&#8212;<wbr></wbr><span class="stt">(+ (+ 1 2) (+ 1 2))</span>&#8212;<wbr></wbr>for interpretation.  Is this
necessarily what we want?</p><p>When you learned algebra in school, you may have been taught to do
this differently: first reduce the argument to an answer (in this
case, <span class="stt">3</span>), then substitute the answer for the parameter.  This
notion of substitution might have the following type instead:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">subst</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">number</span><span class="hspace">&nbsp;</span><span class="RktCmt">*</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">*</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprC</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprC</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara">Careful now: we can&rsquo;t put raw numbers inside expressions, so we&rsquo;d have
to constantly wrap the number in an invocation of <span class="stt">numC</span>.  Thus,
it would make sense for <span class="stt">subst</span> to have a helper that it invokes
after wrapping the first parameter.  (In fact, our existing
<span class="stt">subst</span> would be a perfectly good candidate: because it accepts
any <span class="stt">ExprC</span> in the first parameter, it will certainly work just
fine with a <span class="stt">numC</span>.) </div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>In fact, we don&rsquo;t even have substitution quite right!  The version of
substitution we have doesn&rsquo;t scale past this language due to a subtle
problem known as &ldquo;name capture&rdquo;.  Fixing substitution is complex,
subtle, and an exciting intellectual endeavor, but it&rsquo;s not the
direction I want to go in here.  We&rsquo;ll instead sidestep this problem
in this book.  If you&rsquo;re interested, however, read about the
<span style="font-style: italic">lambda calculus</span>, which provides the tools for defining
substitution correctly.</p></blockquote></blockquote></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Modify your interpreter to substitute names with answers, not
expressions.</p></blockquote></div></p><p>We&rsquo;ve actually stumbled on a profound distinction in programming
languages.  The act of evaluating arguments before substituting them
in functions is called <span style="font-style: italic">eager</span> application, while that of
deferring evaluation is called <span style="font-style: italic">lazy</span>&#8212;<wbr></wbr>and has some variations.
For now, we will actually prefer the eager semantics, because this is
what most mainstream languages adopt.  Later [REF], we will return to
talking about the lazy application semantics and its implications.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="first-desugar.html" title="backward to &quot;4 A First Taste of Desugaring&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="From_Substitution_to_Environments.html" title="forward to &quot;6 From Substitution to Environments&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>