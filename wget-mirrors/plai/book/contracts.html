<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>16&nbsp;Checking Program Invariants Dynamically: Contracts</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Introduction.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Everything__We_Will_Say__About_Parsing.html" class="tocviewlink" data-pltdoc="x">Everything (We Will Say) About Parsing</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="first-interp.html" class="tocviewlink" data-pltdoc="x">A First Look at Interpretation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="first-desugar.html" class="tocviewlink" data-pltdoc="x">A First Taste of Desugaring</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="adding-functions.html" class="tocviewlink" data-pltdoc="x">Adding Functions to the Language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="From_Substitution_to_Environments.html" class="tocviewlink" data-pltdoc="x">From Substitution to Environments</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="higher-order-functions.html" class="tocviewlink" data-pltdoc="x">Functions Anywhere</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="mut-struct-vs-var.html" class="tocviewlink" data-pltdoc="x">Mutation:<span class="mywbr"> &nbsp;</span> Structures and Variables</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="recursion.html" class="tocviewlink" data-pltdoc="x">Recursion and Cycles:<span class="mywbr"> &nbsp;</span> Procedures and Data</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Objects.html" class="tocviewlink" data-pltdoc="x">Objects</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Memory_Management.html" class="tocviewlink" data-pltdoc="x">Memory Management</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Representation_Decisions.html" class="tocviewlink" data-pltdoc="x">Representation Decisions</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Desugaring_as_a_Language_Feature.html" class="tocviewlink" data-pltdoc="x">Desugaring as a Language Feature</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Control_Operations.html" class="tocviewlink" data-pltdoc="x">Control Operations</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="types.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Statically:<span class="mywbr"> &nbsp;</span> Types</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Checking Program Invariants Dynamically:<span class="mywbr"> &nbsp;</span> Contracts</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Alternate_Application_Semantics.html" class="tocviewlink" data-pltdoc="x">Alternate Application Semantics</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>16&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Checking Program Invariants Dynamically:<span class="mywbr"> &nbsp;</span> Contracts</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">16.1&nbsp;</td><td><a href="#%28part._.Contracts_as_.Predicates%29" class="tocviewlink" data-pltdoc="x">Contracts as Predicates</a></td></tr><tr><td align="right">16.2&nbsp;</td><td><a href="#%28part._.Tags__.Types__and_.Observations_on_.Values%29" class="tocviewlink" data-pltdoc="x">Tags, Types, and Observations on Values</a></td></tr><tr><td align="right">16.3&nbsp;</td><td><a href="#%28part._.Higher-.Order_.Contracts%29" class="tocviewlink" data-pltdoc="x">Higher-<wbr></wbr>Order Contracts</a></td></tr><tr><td align="right">16.4&nbsp;</td><td><a href="#%28part._.Syntactic_.Convenience%29" class="tocviewlink" data-pltdoc="x">Syntactic Convenience</a></td></tr><tr><td align="right">16.5&nbsp;</td><td><a href="#%28part._.Extending_to_.Compound_.Data_.Structures%29" class="tocviewlink" data-pltdoc="x">Extending to Compound Data Structures</a></td></tr><tr><td align="right">16.6&nbsp;</td><td><a href="#%28part._.More_on_.Contracts_and_.Observations%29" class="tocviewlink" data-pltdoc="x">More on Contracts and Observations</a></td></tr><tr><td align="right">16.7&nbsp;</td><td><a href="#%28part._.Contracts_and_.Mutation%29" class="tocviewlink" data-pltdoc="x">Contracts and Mutation</a></td></tr><tr><td align="right">16.8&nbsp;</td><td><a href="#%28part._.Combining_.Contracts%29" class="tocviewlink" data-pltdoc="x">Combining Contracts</a></td></tr><tr><td align="right">16.9&nbsp;</td><td><a href="#%28part._.Blame%29" class="tocviewlink" data-pltdoc="x">Blame</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">16.1<tt>&nbsp;</tt></span><a href="#%28part._.Contracts_as_.Predicates%29" class="tocsubseclink" data-pltdoc="x">Contracts as Predicates</a></td></tr><tr><td><span class="tocsublinknumber">16.2<tt>&nbsp;</tt></span><a href="#%28part._.Tags__.Types__and_.Observations_on_.Values%29" class="tocsubseclink" data-pltdoc="x">Tags, Types, and Observations on Values</a></td></tr><tr><td><span class="tocsublinknumber">16.3<tt>&nbsp;</tt></span><a href="#%28part._.Higher-.Order_.Contracts%29" class="tocsubseclink" data-pltdoc="x">Higher-<wbr></wbr>Order Contracts</a></td></tr><tr><td><span class="tocsublinknumber">16.4<tt>&nbsp;</tt></span><a href="#%28part._.Syntactic_.Convenience%29" class="tocsubseclink" data-pltdoc="x">Syntactic Convenience</a></td></tr><tr><td><span class="tocsublinknumber">16.5<tt>&nbsp;</tt></span><a href="#%28part._.Extending_to_.Compound_.Data_.Structures%29" class="tocsubseclink" data-pltdoc="x">Extending to Compound Data Structures</a></td></tr><tr><td><span class="tocsublinknumber">16.6<tt>&nbsp;</tt></span><a href="#%28part._.More_on_.Contracts_and_.Observations%29" class="tocsubseclink" data-pltdoc="x">More on Contracts and Observations</a></td></tr><tr><td><span class="tocsublinknumber">16.7<tt>&nbsp;</tt></span><a href="#%28part._.Contracts_and_.Mutation%29" class="tocsubseclink" data-pltdoc="x">Contracts and Mutation</a></td></tr><tr><td><span class="tocsublinknumber">16.8<tt>&nbsp;</tt></span><a href="#%28part._.Combining_.Contracts%29" class="tocsubseclink" data-pltdoc="x">Combining Contracts</a></td></tr><tr><td><span class="tocsublinknumber">16.9<tt>&nbsp;</tt></span><a href="#%28part._.Blame%29" class="tocsubseclink" data-pltdoc="x">Blame</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="types.html" title="backward to &quot;15 Checking Program Invariants Statically: Types&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Alternate_Application_Semantics.html" title="forward to &quot;17 Alternate Application Semantics&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>16<tt>&nbsp;</tt><a name="(part._contracts)"></a>Checking Program Invariants Dynamically: Contracts</h3><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Contracts_as_.Predicates%29" class="toclink" data-pltdoc="x">16.1<span class="hspace">&nbsp;</span>Contracts as Predicates</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Tags__.Types__and_.Observations_on_.Values%29" class="toclink" data-pltdoc="x">16.2<span class="hspace">&nbsp;</span>Tags, Types, and Observations on Values</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Higher-.Order_.Contracts%29" class="toclink" data-pltdoc="x">16.3<span class="hspace">&nbsp;</span>Higher-Order Contracts</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Syntactic_.Convenience%29" class="toclink" data-pltdoc="x">16.4<span class="hspace">&nbsp;</span>Syntactic Convenience</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Extending_to_.Compound_.Data_.Structures%29" class="toclink" data-pltdoc="x">16.5<span class="hspace">&nbsp;</span>Extending to Compound Data Structures</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.More_on_.Contracts_and_.Observations%29" class="toclink" data-pltdoc="x">16.6<span class="hspace">&nbsp;</span>More on Contracts and Observations</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Contracts_and_.Mutation%29" class="toclink" data-pltdoc="x">16.7<span class="hspace">&nbsp;</span>Contracts and Mutation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Combining_.Contracts%29" class="toclink" data-pltdoc="x">16.8<span class="hspace">&nbsp;</span>Combining Contracts</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Blame%29" class="toclink" data-pltdoc="x">16.9<span class="hspace">&nbsp;</span>Blame</a></p></td></tr></table><p>Type systems offer rich and valuable ways to represent program
invariants.  However, they also represent an important trade-off,
because not all non-trivial properties of programs can be verified
statically<span class="refelem"><span class="refcolumn"><span class="refcontent">This is a formal property, known as
<a href="http://en.wikipedia.org/wiki/Rice's_theorem">Rice&rsquo;s Theorem</a>.</span></span></span>.
Furthermore, even if we can devise a method to settle a certain
property statically, the burdens of annotation and computational
complexity may be too great.  Thus, it is inevitable that some of the
properties we care about must either be ignored or settled only at
run-time.  Here, we will discuss run-time enforcement.</p><p>Virtually every programming language has some form of assertion
mechanism that enables programmers to write properties that are richer
than the language&rsquo;s static type system permits.  In languages without
static types, these properties might start with simple type-like
assertions: whether a parameter is numeric, for instance.  However,
the language of assertions is often the entire programming language,
so any predicate can be used as an assertion: for instance, an
implementation of a cryptography package might want to ensure certain
parameters pass a primality test, or a balanced binary search-tree
might want to ensure that its subtrees are indeed balanced and
preserve the search-tree ordering.</p><h4>16.1<tt>&nbsp;</tt><a name="(part._.Contracts_as_.Predicates)"></a>Contracts as Predicates</h4><p>It is therefore easy to see how to implement simple
contracts.<span class="refelem"><span class="refcolumn"><span class="refcontent">In what follows we will use the language
<span class="stt">#lang plai</span>, for two reasons.  First, this better simulates
programming in an untyped language.  Second, for simplicity we will
write type-like assertions as contracts, but in the typed language
these will be flagged by the type-checker itself, not letting us see
the run-time behavior.  In effect, it is easier to &ldquo;turn off&rdquo; the
type checker.  However, contracts make perfect sense even in a typed
world, because they enhance the set of invariants that a programmer
can express.</span></span></span>  A contract embodies a predicate.  It consumes a value
and applies the predicate to the value.  If the value passes the
predicate, the contract returns the value unmolested; if the value
fails, the contract reports an error.  Its only behaviors are to
return the supplied value or to error: it should not change the value
in any way.  In short, on values that pass the predicate, the
contact itself acts as the identity function.</p><p><div class="SIntrapara">We can encode this essence in the following function:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">make-contract</span><span class="hspace">&nbsp;</span><span class="RktMeta">pred?</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">pred?</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"violation"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta">s</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">error</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">contract</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"~a"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Here&rsquo;s an example contract:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">non-neg?-contract</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">make-contract</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">and</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number?</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">&gt;=</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">(In a typed language, the <span class="stt">number?</span> check would of course be
unnecessary because it can be encoded&#8212;<wbr></wbr>and statically checked!&#8212;<wbr></wbr>in
the type of the function using the contract.)
Suppose we want to make sure we don&rsquo;t get imaginary numbers when
computing square roots; we might write
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">real-sqrt-1</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">sqrt</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">non-neg?-contract</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In many languages assertions are written as statements rather than as
expressions, so an alternate way to write this would be:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">real-sqrt-2</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">non-neg?-contract</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">sqrt</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">(In some cases this form is clearer because it states crisply at the
beginning of the function what is expected of the parameters.  It also
enables parameters to be checked just once.  Indeed, in some languages
the contract can be written in the function header itself, thereby
improving the information given in the interface.)  Now if
<span class="stt">real-sqrt-1</span> or <span class="stt">real-sqrt-2</span> are applied to <span class="stt">4</span> they
produce <span class="stt">2</span>, but if applied to <span class="stt">-1</span> they raise a contract
violation error.</div></p><h4>16.2<tt>&nbsp;</tt><a name="(part._.Tags__.Types__and_.Observations_on_.Values)"></a>Tags, Types, and Observations on Values</h4><p>At this point we&rsquo;ve reproduced the essence of assertion systems in
most languages.  What else is there to say?  Let&rsquo;s suppose for a
moment that our language is not statically typed.  Then we will want
to write assertions that reproduce at least traditional type-like
invariants, if not more.  <span class="stt">make-contract</span> above can capture all
standard type-like properties such as checking for numbers, strings,
and so on, assuming the appropriate predicates are either provided by
the language or can be fashioned from the ones given.  Or can it?</p><p>Recall that even our simplest type language had not just base types,
like numbers, but also constructed types.  While some of these, like
lists and vectors, appear to not be very challenging, they are once
we care about mutation, performance, and blame, which we discuss
below.  However, functions are immediately problematic.</p><p><div class="SIntrapara">As a working example, we will take the following function:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">d/dx</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">/</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">-</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0.001</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0.001</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Statically, we would give this the type </div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">(it consumes a function, and produces its derivative&#8212;<wbr></wbr>another
function).  Let us suppose we want to guard this with contracts.</div></p><p>The fundamental problem is that in most languages, we cannot directly
express this as a predicate.  Most language run-time systems store
very limited information about the types of values&#8212;<wbr></wbr>so limited that,
relative to the types we have seen so far, we should use a different
name to describe this information; traditionally they are called
<span style="font-style: italic">tags</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">There have been a few efforts to preserve
rich type information from the source program through lower levels of
abstraction all the way down to assembly language, but these are
research efforts.</span></span></span>  Sometimes tags coincide with what we might regard
as types: for instance, a number will have a tag identifying it as a
number (perhaps even a specific kind of number), a string will have a
tag identifying it as a string, and so forth.  Thus we can write
predicates based on the values of these tags.</p><p>When we get to structured values, however, the situation is more
complex.  A vector would have a tag declaring it to be a vector, but
not dictating what kinds of values its elements are (and they may not
even all be of the same kind); however, a program can usually also
obtain its size, and thus traverse it, to gather this information.
(There is, however, more to be said about structured values below
[REF].)</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Write a contract that checks that a list consists solely of even
numbers.</p></blockquote></div></p><p><div class="SIntrapara">Here it is:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">list-of-even?-contract</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">make-contract</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">and</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">list?</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">andmap</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">andmap</span><span class="hspace">&nbsp;</span><span class="RktMeta">even?</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">(Again, note that the first two questions need not be asked if we
know, statically, that we have a list of numbers.)  Similarly, an
object might simply identify itself as an object, not providing
additional information.  But in languages that permit reflection on
the object&rsquo;s structure, a contract can still gather the information it
needs.</div></p><p>In every language, however, this becomes problematic when we encounter
functions.  We might think of a function as having a type for its
domain and range, but to a run-time system, a function is just an
opaque object with a function tag, and perhaps some very limited
metadata (such as the function&rsquo;s arity).  The run-time system can
hardly even tell whether the function consumes and produces
functions&#8212;<wbr></wbr>as opposed to other kinds of values&#8212;<wbr></wbr>much less whether
it consumes and produces ones of <span class="stt">(number -&gt; number)</span> type.</p><p>This problem is nicely embodied in the (misnamed) <span class="stt">typeof</span>
operator in JavaScript.  Given values of base types like numbers and
strings, <span class="stt">typeof</span> returns a string to that effect (e.g.,
<span class="stt">"number"</span>).  For objects, it returns <span class="stt">"object"</span>.  Most
importantly, for functions it returns <span class="stt">"function"</span>, with no
additional information.<span class="refelem"><span class="refcolumn"><span class="refcontent">For this reason, perhaps
<span class="stt">typeof</span> is a bad name for this operator.  It should have been
called <span class="stt">tagof</span> instead, leaving open the possibility that future
static type systems for JavaScript could provide a true
<span class="stt">typeof</span>.</span></span></span></p><p>To summarize, this means that at the point of being confronted with a
function, a function contract can only check that it is, indeed, a
function (and if it is not, that is clearly an error).  It cannot
check anything about the domain and range of the function.  Should we
give up?</p><h4>16.3<tt>&nbsp;</tt><a name="(part._.Higher-.Order_.Contracts)"></a>Higher-Order Contracts</h4><p><div class="SIntrapara">To determine what to do, it helps to recall what sort of guarantee
contracts provide in the first place.  In <span class="stt">real-sqrt-1</span> above, we
demanded that the argument be non-negative.  However, this is only
checked if&#8212;<wbr></wbr>and when&#8212;<wbr></wbr><span class="stt">real-sqrt-1</span> is actually used, and then
only on the actual values that are passed to it.   For instance, if
the program contains this fragment
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">real-sqrt-1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">-1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">but this thunk is never invoked, the programmer would never see this
contract violation.  In fact, it may be that the thunk is not invoked
on this run of the program, but in a later run it will be; thus, the
program has a lurking contract error.  For this reason, it is usually
preferable to express invariants through static types; but where we do
use contracts, we understand that it is with the caveat that we will
only be notified of errors when the program is suitably exercised.</div></p><p>This is a useful insight, because it offers a solution to our problem
with functions.  We check, immediately, that the purported function
value truly is a function.  However, instead of ignoring the domain
and range contracts, we <span style="font-style: italic">defer</span> them.  We check the domain
contract when (and each time) the function is actually applied to a
value, and we check the range contract when the function actually
returns a value.</p><p><div class="SIntrapara">This is clearly a different pattern than <span class="stt">make-contract</span>
followed.  Thus, we should give <span class="stt">make-contract</span> a more
descriptive name: it checks <span style="font-style: italic">immediate</span> contracts (i.e., those
that can be checked in their entirety now).<span class="refelem"><span class="refcolumn"><span class="refcontent">In the Racket
contract system, immediate contracts are called <span style="font-style: italic">flat</span>.  This term
is slightly misleading, since they can also protect data structures.</span></span></span>
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">pred?</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">pred?</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>In contrast, a function contract takes two <span style="font-style: italic">contracts</span> as
arguments&#8212;<wbr></wbr>representing checks to be made on the domain and
range&#8212;<wbr></wbr>and returns a predicate.  This is the predicate to apply on
values purporting to satisfy that contract.  First, this checks that
the given value actually is a function: this part is still immediate.
Then, we create a <span style="font-style: italic">surrogate</span> procedure that applies the
&ldquo;residual&rdquo; contracts&#8212;<wbr></wbr>to check the domain and range&#8212;<wbr></wbr>but otherwise
behaves the same as the original function.</p><p><div class="SIntrapara">This creation of a surrogate represents a departure from the
traditional assertion mechanism, which simply checks values and
then leaves them alone.  Instead, for functions we must use the
created surrogate if we want contract checking.  In general,
therefore, it is useful to have a wrapper that consumes a contract and
value, and creates a guarded version of that value:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">guard</span><span class="hspace">&nbsp;</span><span class="RktMeta">ctc</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">ctc</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">As a very simple example, let us suppose we want to wrap the
<span class="stt">add1</span> function in numeric contracts (with <span class="stt">function</span>, the
constructor of function contracts, to be defined momentarily):
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">a1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">guard</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">add1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">We want <span class="stt">a1</span> to be bound to essentially the following code:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">a1</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">num?-con</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">num?-con</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Here, the <span class="stt">(lambda (x) ...)</span> is the surrogate; it applies two
numeric contracts around the invocation of <span class="stt">add1</span>.  Recall that
contracts must behave like the identity function in the absence of
violations, so this procedure has precisely the same behavior as
<span class="stt">add1</span> on non-violating uses.</div></p><p><div class="SIntrapara">To achieve this, we use the following definition of
<span class="stt">function</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">For simplicity we assume single-argument
functions here, but the extension to multiple arity is
straightforward.  Indeed, more complex contracts can even check for
relationships <span style="font-style: italic">between</span> the arguments.</span></span></span>
Remember that we have to also ensure that the given value is truly a
function (as <span class="stt">add1</span> above indeed is, and can be checked
immediately, which is why the check has disappeared by the time we
bind the surrogate to <span class="stt">a1</span>):
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta">dom</span><span class="hspace">&nbsp;</span><span class="RktMeta">rng</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">procedure?</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rng</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">dom</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">To understand how this works, let us substitute arguments.  To keep
the resulting code readable, we will first construct the
<span class="stt">number?</span> contract checker and give it a name:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">num?-con</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">num?-con</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number?</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Now let&rsquo;s return to the definition of <span class="stt">a1</span>.  First we apply
<span class="stt">guard</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">a1</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta">num?-con</span><span class="hspace">&nbsp;</span><span class="RktMeta">num?-con</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">add1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Now we apply the function contract constructor:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">a1</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">procedure?</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">num?-con</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">num?-con</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">add1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Applying the left-left-lambda gives:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">a1</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">procedure?</span><span class="hspace">&nbsp;</span><span class="RktMeta">add1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">num?-con</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">num?-con</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta">add1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Notice that this immediately checks that the guarded value is indeed a
function.  Thus we get
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">a1</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">num?-con</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">num?-con</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">which is precisely the surrogate we desired, with the behavior of
<span class="stt">add1</span>  on non-violating executions.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>How many ways are there to violate the above contract for <span class="stt">add1</span>?</p></blockquote></div></p><p><div class="SIntrapara">There are three ways, corresponding to the three contract
constructors:
</div><div class="SIntrapara"><ol><li><p>the value wrapped might not be a function;</p></li><li><p>the wrapped value might be a function that is applied to a
non-numeric value; or,</p></li><li><p>the wrapped value might be a function that consumes numbers
but produces values of non-numeric type.</p></li></ol></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Write examples that perform each of these three violations, and
observe the behavior of the contract system.  Can you improve the
error messages to better distinguish these cases?</p></blockquote></div></p><p><div class="SIntrapara">The same wrapping technique works for <span class="stt">d/dx</span> as well:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">d/dx</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">guard</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">/</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">-</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0.001</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0.001</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>There are seven ways to violate this contract, corresponding to each
of the seven contract constructors.  Violate each of them by passing
arguments or modifying code, as needed.  Can you improve error
reporting to correctly identify each kind of violation?</p></blockquote></div></p><p>Notice that the nested function contract defers the checking of the
immediate contracts for two applications, rather than one.  This is
what we should expect, because immediate contracts only report
problems with actual values, so they cannot report anything until
applied to actual values.  However, this does mean that the notion of
&ldquo;violation&rdquo;&rsquo; is subtle: the function value passed to <span class="stt">d/dx</span> may
in fact truly be in violation of the contract, but this violation will
not be <span style="font-style: italic">observed</span> until numeric values are passed or returned.</p><h4>16.4<tt>&nbsp;</tt><a name="(part._.Syntactic_.Convenience)"></a>Syntactic Convenience</h4><p><div class="SIntrapara">Earlier we saw two styles of using flat contracts, as embodied in
<span class="stt">real-sqrt-1</span> and <span class="stt">real-sqrt-2</span>.  Both styles have
disadvantages.  The latter, which is reminiscent of traditional
assertion systems, simply does not work for higher-order values,
because it is the wrapped value that must be used in the computation.
(Not surprisingly, traditional assertion systems only handle immediate
contracts, so they fail to notice this subtlety.)  The  style in the
former, where we wrap each use with a contract, works in theory but
suffers from three downsides:
</div><div class="SIntrapara"><ol><li><p>The developer may forget to wrap some uses.</p></li><li><p>The contract is checked once per use, which is wasteful when
there is more than one use.</p></li><li><p>The program comingles contract checking with its functional
behavior, reducing readability.</p></li></ol></div><div class="SIntrapara">Fortunately, a judicious use of syntactic sugar can solve this problem
in common cases.  For instance, suppose we want to make it easy to
attach contracts to function parameters, so a developer could write
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define/contract</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">real-sqrt</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">::</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">positive?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">sqrt</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">with the intent of guarding <span class="stt">x</span> with <span class="stt">positive?</span>, but
performing the check only once, on function invocation.  This should
translate to, say,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">real-sqrt</span><span class="hspace">&nbsp;</span><span class="RktMeta">new-x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">guard</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">positive?</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new-x</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">sqrt</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">That is, the macro generates a fresh name for each identifier, then
associates the name given by the user to the wrapped version of the
value supplied to that fresh name.  The following macro implements
exactly this:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define/contract</span><span class="hspace">&nbsp;</span><span class="RktMeta">stx</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">syntax-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">stx</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">::</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">_</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta">::</span><span class="hspace">&nbsp;</span><span class="RktMeta">c</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">with-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">new-id</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">generate-temporaries</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">f</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">new-id</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">guard</span><span class="hspace">&nbsp;</span><span class="RktMeta">c</span><span class="hspace">&nbsp;</span><span class="RktMeta">new-id</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">With conveniences like this, designers of contract languages can
improve the readability, efficiency, and robustness of contract
use.</div></p><h4>16.5<tt>&nbsp;</tt><a name="(part._.Extending_to_.Compound_.Data_.Structures)"></a>Extending to Compound Data Structures</h4><p>As we have already discussed, it appears easy to extend contracts to
structured datatypes such as lists, vectors, and user-defined
recursive datatypes.  This only requires that the appropriate set of
run-time observations be available.  This will usually be the case, up
to the resolution of types in the language.  For instance, as we have
discussed [REF], a language with datatypes does not require
<span style="font-style: italic">type</span> predicates but will still offer predicates to distinguish
the <span style="font-style: italic">variants</span>; this is case where type-level &ldquo;contract&rdquo;
checking is best (and perhaps must) be left to the static type system,
while the contacts assert more refined structural properties.</p><p>However, this strategy can run into significant performance problems.
For instance, suppose we built a balanced binary search-tree to
perform asymptotic logarithmic time (in the size of the tree)
insertions and lookups.  Now say we have wrapped this tree in a
suitable contract.  Sadly, the mere act of checking the contract
visits the entire tree, thereby taking linear time!  Ideally,
therefore, we would prefer a strategy whereby the contract was already
checked&#8212;<wbr></wbr>incrementally&#8212;<wbr></wbr>at the time of construction, and does not
need to be checked again at the time of lookup.</p><p>Worse, both balancing and search-tree ordering are recursive
properties.  In principle, therefore, they attach to every sub-tree,
and so should be applied on every recursive call.  During insertion,
which is a recursive procedure, the contract would be checked on every
visited sub-tree.  In a tree of size <span class="relax">\(t\)</span>, the contract predicate
applies to a sub-tree of <span class="relax">\(t \over 2\)</span> elements, then to a
sub-sub-tree of <span class="relax">\(t \over 4\)</span> elements, and so on, resulting&#8212;<wbr></wbr>in the
worst case&#8212;<wbr></wbr>in visiting a total of
<span class="relax">\(t \over 2\)</span> + <span class="relax">\(t \over 4\)</span> + <span class="relax">\(\cdots\)</span> + <span class="relax">\(t \over t\)</span>
elements...making our intended logarithmic-time insertion process take
linear time.</p><p>In both cases, there is ready mitigation available in many cases.
Each value needs to be associated (either intrinsically, or by storage
in a hash table) with the set of contracts it has already passed.
Then, when a contract is ready to apply, it first checks whether the
value has already been checked and, if it has, does not check again.
This is essentially a form of memoization of contract checking and can
thus reduce the algorithmic complexity of checking.  Again, like
memoization, this works best when the values are immutable.  If the
values can mutate and the contracts perform arbitrary computations, it
may not be sound to perform this optimization.</p><p>There is a subtler way in which we might examine the issue of data
structures.  As an example, consider the contract we wrote earlier to
check that all values in a numeric list are even.  Suppose we have
wrapped a list in this contract, but are interested only in the first
element of the list.  Naturally, we are paying the cost of checking
all the values in the list, which may take a very long time.  More
importantly, however, a user might argue that reporting a violation
about the second element of the list is itself a violation of our
expectation about contract-checking, since we did not actually use
that element.</p><p>This suggests deferring checking even for some values that could be
checked immediately.  For instance, the entire list could be turned
into a wrapped value containing a deferred check, and each value is
checked only when it is visited.  This strategy might be attractive,
but it is not trivial to code, and especially runs into problems in
the presence of <span style="font-style: italic">aliasing</span>: if two different identifiers are
referring to the same list, one with a contract guard and the other
without, we have to ensure both of them function as expected (which
usually means we cannot store any mutable state in the list itself).</p><h4>16.6<tt>&nbsp;</tt><a name="(part._.More_on_.Contracts_and_.Observations)"></a>More on Contracts and Observations</h4><p>A general problem for any contract implementation&#8212;<wbr></wbr>which is
exacerbated by complex data&#8212;<wbr></wbr>is a curious one.  Earlier, we
complained that it was difficult to check function contracts because
we have insufficient power to observe: all we can check is that a
value is a function, and no more.  In real languages, the problem for
data structures is actually the opposite: we have too much ability to
observe.  For instance, if we implement a strategy of deferring
checking of a list, we quite possibly need to use a structure to hold
the actual list, and modify <span class="stt">first</span> and <span class="stt">rest</span> to get their
values through this structure (after checking contracts).  However, a
procedure like <span class="stt">list?</span> might now return <span class="stt">false</span> rather than
<span class="stt">true</span> because structures are not lists; therefore, <span class="stt">list?</span>
needs to be re-bound to a procedure that also returns <span class="stt">true</span> on
structures that represent these special deferred-contract lists.  But
the contract system author needs to also remember to tackle
<span class="stt">cons?</span>, <span class="stt">pair?</span>, and goodness knows how many other
procedures that all perform observations.</p><p>In general, one observation is essentially impossible to &ldquo;fix&rdquo;:
<span class="stt">eq?</span>.  Normally, we have the property that every value is
<span class="stt">eq?</span> to itself, even for functions.  However,  the wrapped value
of a function is a new procedure that not only <span style="font-style: italic">isn&rsquo;t</span> <span class="stt">eq?</span>
to itself but probably <span style="font-style: italic">shouldn&rsquo;t</span> be, because its behavior
truly is different (though only on contract violations, and only after
enough values have been supplied to observe the violation).  However,
this means that a program cannot surreptitiously guard itself, because
the act of guarding can be observed.  As a result, a malicious module
can sometimes detect whether it is being passed guarded values,
behaving normally when it is and abnormally only when it is not!</p><h4>16.7<tt>&nbsp;</tt><a name="(part._.Contracts_and_.Mutation)"></a>Contracts and Mutation</h4><p>We should rightly be concerned about the interaction between contracts
and mutation, and even more so when we have contracts that are either
inherently deferred or have been implemented in a deferred fashion.
There are two things to be concerned about.  One is storing a
contracted value in mutable state.  The other is writing a contract
<span style="font-style: italic">for</span> mutable state.</p><p>When we store a contracted value, the strategy of wrapping ensures
that contract checking works gracefully.  At each stage, a contract
checks as much as it can with the value at hand, and creates a wrapped
value embodying the residual check.  Thus, even if this wrapped value
is stored in mutable state and retrieved for use later, it still
contains these checks, and they will be performed when the value is
eventually used.</p><p>The other issue is writing contracts for mutable data, such as boxes
and vectors.  In this case we probably have to create a wrapper for
the entire datatype that records the intended contract.  Then, when a
value inside the datatype is replaced with a new one, the operation
that performs the update&#8212;<wbr></wbr>such as <span class="stt">set-box!</span>&#8212;<wbr></wbr>needs to retrieve
the intended contract from the wrapper, apply it to the value, and
store the wrapped value.  Therefore, this requires changing the
behavior of the data structure mutation operators to be sensitive to
contracted values.  However, mutation does not change the point at
which violations are caught: right away for immediate contracts, upon
(in)appropriate use for deferred ones.</p><h4>16.8<tt>&nbsp;</tt><a name="(part._.Combining_.Contracts)"></a>Combining Contracts</h4><p>Now that we&rsquo;ve discussed combinators for all the basic datatypes, it&rsquo;s
natural to discuss combining contracts.  Just as we saw unions [REF]
and intersections [REF] for types, we should be considering unions and
intersections (respectively, &ldquo;or&rdquo;s and &ldquo;and&rdquo;s), ; for that matter,
we might also consider negation.  However, contracts are only
superficially like types, so we have to consider these questions in
their own light for contracts rather than try to map the meanings we
have learned from types to the sphere of contracts.</p><p>As always, the immediate case is straightforward.  Union contracts
combine with disjunction&#8212;<wbr></wbr>indeed, being predicates, their results can
literally be combined with <span class="stt">or</span>&#8212;<wbr></wbr>and intersection contracts with
conjunction.  We apply the predicates in turn, with short-circuiting,
and either generate an error or return the contracted value.
Intersection contracts combine with conjunction (<span class="stt">and</span>).  And
negation contracts are simply the original immediate contract applied
and the decision negated (with <span class="stt">not</span>).</p><p>Contract combination is much harder in the deferred, higher-order
case.  For instance, consider the negation of a function contract from
numbers to numbers.  What exactly does it mean to negate it?  Does it
mean the function should <span style="font-style: italic">not</span> accept numbers?  Or that if it
does, it should not produce them?  Or both?  And in particular, how do
we enforce such a contract?  How, for instance, do we check that a
function does not accept numbers&#8212;<wbr></wbr>are we expecting that when given a
number, it produces an error?  But now consider the identity function
wrapped with such a contract; since it clearly does not result in an
error when given a number (or indeed any other value), does that mean
we should wait until it produces a value, and if it does produce a
number, reject it?  But worst of all, note that this means we will be
running functions on domains on which they are <span style="font-style: italic">not</span> defined: a
sure recipe for destroying program invariants, polluting the heap, or
crashing the program.</p><p>Intersection contracts require values to pass all the sub-contracts.
This means re-wrapping the higher-order value in something that checks
all the domain sub-contracts as well as all the range sub-contracts.
Failing to meet even one sub-contract means the value has failed the
entire intersction.</p><p>Union contracts are more subtle, because failing to meet any one
sub-contract is not grounds for rejection.  Rather, it simply means
that that one sub-contract is no longer a candidate contract
representing the wrapped value; the other sub-contracts might still be
candidates, and only when no others are left must be reject the value.
This means the implementation of union contracts must maintain memory
of which sub-contracts have and have not yet passed&#8212;<wbr></wbr>memory, in this
case, being a sophisticated term for the use of
mutation.<span class="refelem"><span class="refcolumn"><span class="refcontent">In a multi-threaded language like Racket, this
also requires locks to avoid race conditions.</span></span></span>  As each sub-contract
fails, it is removed from the list of candidates, while all the
remaining ones continue to applied.  When no candidates remain, the
contract system must report a violation.  The error report would
presumably provide the actual values that eliminated each part of each
sub-contract (keeping in mind that these may be nested multiple
functions deep).</p><p>The implemented versions of contract constructors and combinators in
Racket place restrictions on the acceptable forms of sub-contracts.
These enable implementations that are both efficient and yield useful
error messages.  Furthermore, the more extreme situations discussed
above rarely occur in practice&#8212;<wbr></wbr>though now you know how to implement
them if you need to.</p><h4>16.9<tt>&nbsp;</tt><a name="(part._.Blame)"></a>Blame</h4><p>Let&rsquo;s now return to the issue of reporting contract violations.  By
this I don&rsquo;t mean what string to print, but the much more important
question of <span style="font-style: italic">what</span> to report, which as we are about to see is
really a semantic consideration.</p><p><div class="SIntrapara">To illustrate the problem recall our definition of <span class="stt">d/dx</span> above,
and assume we were running it without any contract checking.  Suppose
now that we apply this function to the entirely inappropriate
<span class="stt">string-append</span> (which neither consumes nor produces numbers).
This simply produces a value:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (define d/dx-sa (d/dx string-append))</span></p></td></tr></table></div><div class="SIntrapara">(Observe that this would succeed even if contract checking were on,
because the immediate portion of the function contract recognizes
<span class="stt">string-append</span> to be a function.)  Now suppose we
apply <span class="stt">d/dx-sa</span> to a number, as we ought to be able to do:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (d/dx-sa 10)</span></p></td></tr><tr><td><p><span class="stt">string-append: contract violation</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">expected: string?</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">given: 10.001</span></p></td></tr></table></div><div class="SIntrapara">Notice that the error report is deep inside the body of <span class="stt">d/dx</span>.
On the one hand, this is entirely legitimate: that is where the
improper application of <span class="stt">string-append</span> occurred.  However, the
<span style="font-style: italic">fault</span> is not that of <span class="stt">d/dx</span> at all&#8212;<wbr></wbr>rather, it is the
fault of whatever body of code supplied <span class="stt">string-append</span> as a
purportedly legitimate function from numbers to numbers.  Except,
however, the code that did so has long since fled the scene; it is no
longer on the stack, and is hence outside the ambit of traditional
error-reporting mechanisms.</div></p><p>This problem is not a peculiarity of <span class="stt">d/dx</span>; in fact, it
routinely occurs in large systems.  This is because systems,
especially with graphical, network, and other external interfaces,
make heavy use of <span style="font-style: italic">callbacks</span>: functions (or methods) that
register interest in some entity and are invoked to signal some status
or value.  (Here, <span class="stt">d/dx</span> is the moral equivalent of the graphics
layer, and <span class="stt">string-append</span> is the callback that has been supplied
to (and stored by) it.)  Eventually, the system layer invokes the
callback.  If this results in an error, it is the fault of
<span style="font-style: italic">neither</span> the system layer&#8212;<wbr></wbr>which was given a callback of
purportedly the right contract&#8212;<wbr></wbr><span style="font-style: italic">nor</span> of the callback itself,
which presumably has legitimate uses but was improperly supplied to
the function.  Rather, <span style="font-style: italic">the fault is of the entity that
introduced these two entities</span>.  However, at this point the call stack
contains only the callback (on top) and the system (below it)&#8212;<wbr></wbr>and
the only guilty party is no longer present.  These kinds of errors can
therefore be extremely difficult to debug.</p><p>The solution is to extend the contract system to incorporate a notion
of <span style="font-style: italic">blame</span>.  The idea is to effectively record the introduction
that resulted in a pair of components coming together, so that if a
contract violation occurs between them, we can ascribe the failure to
the expression that did the introduction.  Observe that this is only
really interesting in the context of functions, but for consistency we
will extend blame to immediate contracts as well in a natural way.</p><p>For a function, notice that there are two possible points of failure:
either it was <span style="font-style: italic">given</span> the wrong kind of value (the
pre-condition), or it <span style="font-style: italic">produced</span> the wrong kind of value (the
post-condition).  It is important to distinguish these two cases
because in the former case we should blame the environment&#8212;<wbr></wbr>in
particular, the actual parameter expression&#8212;<wbr></wbr>whereas in the latter
case (assuming the parameter has passed muster) we should blame the
function itself.  (The natural extension to immediate values is that
we can only blame the value itself for not satisfying the contract,
which is akin to the &ldquo;post-condition&rdquo;.)</p><p>For contracts, we will introduce the terms <span style="font-style: italic">positive</span> and
<span style="font-style: italic">negative</span> position.  For a first-order function, the negative
position is the pre-condition and the positive one the post-condition.
Therefore, this might appear to be needless extra terminology.  As we
will soon see, however, these terms have a more general meaning.</p><p>We will now generalize the parameters consumed by contracts.
Previously, immediate contracts consumed a predicate and function
contracts consumed domain and range contracts.  This will still be the
case.  However, what they each return will be a function of two
arguments: labels for the positive and negative positions.  (These
labels can be drawn from any reasonable datatype: abstract syntax
nodes, buffer offsets, or other descriptions.  For simplicity, we will
use strings.)  Thus function contracts will close over the labels of
these program positions, to later blame the provider of an invalid
function.</p><p><div class="SIntrapara">The <span class="stt">guard</span> function is now responsible for passing through the
labels of the contract application locations:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">guard</span><span class="hspace">&nbsp;</span><span class="RktMeta">ctc</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta">pos</span><span class="hspace">&nbsp;</span><span class="RktMeta">neg</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">ctc</span><span class="hspace">&nbsp;</span><span class="RktMeta">pos</span><span class="hspace">&nbsp;</span><span class="RktMeta">neg</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and let us also have <span class="stt">blame</span> display the appropriate label (which
we will pass to it from the contract implementations):
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta">s</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">error</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">contract</span><span class="hspace">&nbsp;</span><span class="RktMeta">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Suppose we are guarding the use of <span class="stt">add1</span>, as before.  What are
useful names for the positive and negative positions?  The positive
position is post-condition: i.e., any failure here must be blamed on
the body of <span class="stt">add1</span>.  The negative position is the pre-condition:
i.e., any failure here must be blamed on the parameter to
<span class="stt">add1</span>.  Thus:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">a1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">guard</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">add1</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"add1</span><span class="hspace">&nbsp;</span><span class="RktVal">body"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"add1</span><span class="hspace">&nbsp;</span><span class="RktVal">input"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Had we provided a non-function to guard, we would expect an error at
the  &ldquo;post-condition&rdquo; location: this is not really a failure of the
post-condition, but surely the parameter cannot be blamed if the
application failed to be a function.  (However, this shows that we are
really stretching the term &ldquo;post-condition&rdquo;, and the terms
&ldquo;positive&rdquo; provides a useful alternative.)  Because we trust the
implementation of <span class="stt">add1</span> to only produce numbers, we would expect
it is impossible to fail the post-condition.  However, we would expect
an expression like <span class="stt">(a1 "x")</span> to trigger a pre-condition error,
presumably signaling a contract error at the location <span class="stt">"add1
input"</span>.  In contrast, had we guarded a function that violates the
post-condition, such as this,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">bad-a1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">guard</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">number-&gt;string</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"bad-add1</span><span class="hspace">&nbsp;</span><span class="RktVal">body"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"bad-add1</span><span class="hspace">&nbsp;</span><span class="RktVal">input"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">we would expect blame to be ascribed to <span class="stt">"bad-add1 body"</span>.</div></p><p><div class="SIntrapara">Let us now see how to implement these contract constructors.  For
immediate contracts, we have seen that blame should be ascribed to the
positive position:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">pred?</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">pos</span><span class="hspace">&nbsp;</span><span class="RktMeta">neg</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">pred?</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta">pos</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">For functions, we might be tempted to write
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta">dom</span><span class="hspace">&nbsp;</span><span class="RktMeta">rng</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">pos</span><span class="hspace">&nbsp;</span><span class="RktMeta">neg</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">procedure?</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">dom</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rng</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta">pos</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">but this fails to work in a very fundamental way: it violates the
expected signature on contracts.  That is because all contracts now
expect to be given the labels of positive and negative positions, which
means <span class="stt">dom</span> and <span class="stt">rng</span> cannot be used as above.  (As another
hint, we are using <span class="stt">pos</span> but not <span class="stt">neg</span> anywhere in the body,
even though we have seen examples where we expect the position bound
to <span class="stt">neg</span> to be blamed.)  Instead, clearly, we somehow instantiate
the domain and range contracts using <span class="stt">pos</span> and <span class="stt">neg</span>, so
that they &ldquo;know&rdquo; and &ldquo;remember&rdquo; where a potentially violating
function was applied.</div></p><p><div class="SIntrapara">The most obvious reaction would be to instantiate these contract
constructors with the same values of <span class="stt">dom</span> and <span class="stt">rng</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta">dom</span><span class="hspace">&nbsp;</span><span class="RktMeta">rng</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">pos</span><span class="hspace">&nbsp;</span><span class="RktMeta">neg</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">dom-c</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">dom</span><span class="hspace">&nbsp;</span><span class="RktMeta">pos</span><span class="hspace">&nbsp;</span><span class="RktMeta">neg</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">rng-c</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rng</span><span class="hspace">&nbsp;</span><span class="RktMeta">pos</span><span class="hspace">&nbsp;</span><span class="RktMeta">neg</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">procedure?</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rng-c</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">dom-c</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta">pos</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Now all the signatures match up, and we can run our contracts.  But
when we do so, the answers are a little strange.  For instance, on our
simplest contract violation example, we get
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (a1 "x")</span></p></td></tr><tr><td><p><span class="stt">contract: add1 body</span></p></td></tr></table></div><div class="SIntrapara">Huh?  Maybe we should expand out the code of <span class="stt">a1</span> to see what
happened.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">a1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"x"</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">guard</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">add1</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"add1</span><span class="hspace">&nbsp;</span><span class="RktVal">body"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"add1</span><span class="hspace">&nbsp;</span><span class="RktVal">input"</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"add1</span><span class="hspace">&nbsp;</span><span class="RktVal">body"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"add1</span><span class="hspace">&nbsp;</span><span class="RktVal">input"</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">add1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">dom-c</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"add1</span><span class="hspace">&nbsp;</span><span class="RktVal">body"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"add1</span><span class="hspace">&nbsp;</span><span class="RktVal">input"</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">rng-c</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"add1</span><span class="hspace">&nbsp;</span><span class="RktVal">body"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"add1</span><span class="hspace">&nbsp;</span><span class="RktVal">input"</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rng-c</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">dom-c</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">dom-c</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number?</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"add1</span><span class="hspace">&nbsp;</span><span class="RktVal">body"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">rng-c</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number?</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"add1</span><span class="hspace">&nbsp;</span><span class="RktVal">body"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rng-c</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">dom-c</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Poor <span class="stt">add1</span>: it never stood a chance!  The only blame label left
is <span class="stt">"add1 body"</span>, so it was the only thing that could ever be
blamed.</div></p><p>We will return to this problem in a moment, but observe how in the
above code, there are no real traces of the function contract left.
All we have are immediate contracts, ready to blame actual values if
and when they occur.  This is perfectly consistent with what we said
earlier [REF] about being able to observe only immediate values.  Of
course, this is only true for first-order functions; when we get to
higher-order functions, this will no longer be true.</p><p>What went wrong?  Notice that only the contract bound to <span class="stt">rng-c</span>
ought to be blaming the body of <span class="stt">add1</span>.  In contrast, the
contract bound to <span class="stt">dom-c</span> ought to be blaming the input to
<span class="stt">add1</span>.  It&rsquo;s almost as if, in the domain position of a function
contract, the positive and negative labels should be...swapped.</p><p>If we consider the contract-guarded <span class="stt">d/dx</span>, we see that this is
indeed the case.  The key insight is that, when applying a function
taken as a parameter, the &ldquo;outside&rdquo; becomes the &ldquo;inside&rdquo; and vice
versa.  That is, the body of <span class="stt">d/dx</span>&#8212;<wbr></wbr>which was in positive
position&#8212;<wbr></wbr>is now the caller of the function to differentiate, putting
that function&rsquo;s body in positive position and the caller&#8212;<wbr></wbr>the body of
<span class="stt">d/dx</span>&#8212;<wbr></wbr>in negative position.  Thus, on the domain side of the
contract, every nested function contract causes positive and negative
positions to swap.</p><p>On the range side, there is no need to swap.  Consider again
<span class="stt">d/dx</span>.  The function it returns represents the derivative, so it
should be given a number (representing the point at which to calculate
the derivative) and it should return a number (the derivative at that
point).  The negative position of this function is indeed the client
who uses the derivative function&#8212;<wbr></wbr>the pre-condition&#8212;<wbr></wbr>and the
positive position is indeed the body of <span class="stt">d/dx</span> itself&#8212;<wbr></wbr>the
post-condition&#8212;<wbr></wbr>since it is responsible for generating the
derivative.</p><p><div class="SIntrapara">As a result, we obtain an updated, and correct, definition for the
function constructor:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta">dom</span><span class="hspace">&nbsp;</span><span class="RktMeta">rng</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">pos</span><span class="hspace">&nbsp;</span><span class="RktMeta">neg</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">dom-c</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">dom</span><span class="hspace">&nbsp;</span><span class="RktMeta">neg</span><span class="hspace">&nbsp;</span><span class="RktMeta">pos</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">rng-c</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rng</span><span class="hspace">&nbsp;</span><span class="RktMeta">pos</span><span class="hspace">&nbsp;</span><span class="RktMeta">neg</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">procedure?</span><span class="hspace">&nbsp;</span><span class="RktMeta">val</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rng-c</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">dom-c</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">blame</span><span class="hspace">&nbsp;</span><span class="RktMeta">pos</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Apply this to our earlier example and confirm that we get the expected
blame.  Also expand the code manually to see why this happens.</p></blockquote></div></p><p><div class="SIntrapara">Suppose, further, we define <span class="stt">d/dx</span> with the labels
<span class="stt">"d/dx body"</span> for its positive position and
<span class="stt">"d/dx input"</span> for its negative.
Say we supply the function <span class="stt">number-&gt;string</span>, which patently does
not compute derivatives, and apply the result to <span class="stt">10</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">d/dx</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">guard</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">number?</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">immediate</span><span class="hspace">&nbsp;</span><span class="RktMeta">string?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">number-&gt;string</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"n-&gt;s</span><span class="hspace">&nbsp;</span><span class="RktVal">body"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"n-&gt;s</span><span class="hspace">&nbsp;</span><span class="RktVal">input"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This correctly indicates that the blame should be ascribed to the
expression that fed <span class="stt">number-&gt;string</span> as a supposed numeric
function to <span class="stt">d/dx</span>&#8212;<wbr></wbr>not to <span class="stt">d/dx</span> itself.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Hand-evaluate <span class="stt">d/dx</span>, apply it to <span style="font-style: italic">all</span> the relevant violation
examples, and confirm that the resulting blame is accurate.  What
happens if you supply <span class="stt">d/dx</span> with <span class="stt">string-&gt;number</span> with
a function contract indicating it maps strings to numbers?  What if
you supply the same function with no contract at all?</p></blockquote></div></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="types.html" title="backward to &quot;15 Checking Program Invariants Statically: Types&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Alternate_Application_Semantics.html" title="forward to &quot;17 Alternate Application Semantics&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>