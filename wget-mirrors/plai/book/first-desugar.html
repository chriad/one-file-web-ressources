<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>4&nbsp;A First Taste of Desugaring</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Introduction.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Everything__We_Will_Say__About_Parsing.html" class="tocviewlink" data-pltdoc="x">Everything (We Will Say) About Parsing</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="first-interp.html" class="tocviewlink" data-pltdoc="x">A First Look at Interpretation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">A First Taste of Desugaring</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="adding-functions.html" class="tocviewlink" data-pltdoc="x">Adding Functions to the Language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="From_Substitution_to_Environments.html" class="tocviewlink" data-pltdoc="x">From Substitution to Environments</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="higher-order-functions.html" class="tocviewlink" data-pltdoc="x">Functions Anywhere</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="mut-struct-vs-var.html" class="tocviewlink" data-pltdoc="x">Mutation:<span class="mywbr"> &nbsp;</span> Structures and Variables</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="recursion.html" class="tocviewlink" data-pltdoc="x">Recursion and Cycles:<span class="mywbr"> &nbsp;</span> Procedures and Data</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Objects.html" class="tocviewlink" data-pltdoc="x">Objects</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Memory_Management.html" class="tocviewlink" data-pltdoc="x">Memory Management</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Representation_Decisions.html" class="tocviewlink" data-pltdoc="x">Representation Decisions</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Desugaring_as_a_Language_Feature.html" class="tocviewlink" data-pltdoc="x">Desugaring as a Language Feature</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Control_Operations.html" class="tocviewlink" data-pltdoc="x">Control Operations</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="types.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Statically:<span class="mywbr"> &nbsp;</span> Types</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="contracts.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Dynamically:<span class="mywbr"> &nbsp;</span> Contracts</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Alternate_Application_Semantics.html" class="tocviewlink" data-pltdoc="x">Alternate Application Semantics</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>4&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">A First Taste of Desugaring</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">4.1&nbsp;</td><td><a href="#%28part._.Extension__.Binary_.Subtraction%29" class="tocviewlink" data-pltdoc="x">Extension:<span class="mywbr"> &nbsp;</span> Binary Subtraction</a></td></tr><tr><td align="right">4.2&nbsp;</td><td><a href="#%28part._.Extension__.Unary_.Negation%29" class="tocviewlink" data-pltdoc="x">Extension:<span class="mywbr"> &nbsp;</span> Unary Negation</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#%28part._.Extension__.Binary_.Subtraction%29" class="tocsubseclink" data-pltdoc="x">Extension:<span class="mywbr"> &nbsp;</span> Binary Subtraction</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cdesugar~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;desugar&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cbminus.S-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;bminusS-case&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="#%28part._.Extension__.Unary_.Negation%29" class="tocsubseclink" data-pltdoc="x">Extension:<span class="mywbr"> &nbsp;</span> Unary Negation</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="first-interp.html" title="backward to &quot;3 A First Look at Interpretation&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="adding-functions.html" title="forward to &quot;5 Adding Functions to the Language&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>4<tt>&nbsp;</tt><a name="(part._first-desugar)"></a>A First Taste of Desugaring</h3><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><p>We&rsquo;ve begun with a very spartan arithmetic language.  Let&rsquo;s look at
how we might extend it with more arithmetic operations that can
nevertheless be expressed in terms of existing ones.  We&rsquo;ll add just
two, because these will suffice to illustrate the point.</p><h4>4.1<tt>&nbsp;</tt><a name="(part._.Extension__.Binary_.Subtraction)"></a>Extension: Binary Subtraction</h4><p>First, we&rsquo;ll add subtraction.  Because our language already has
numbers, addition, and multiplication, it&rsquo;s easy to define
subtraction: <span class="relax">\(a - b = a + -1 \times b\)</span>.</p><p>Okay, that was easy!  But now we should turn this into concrete code.
To do so, we face a decision: where does this new subtraction operator
reside?  It is tempting, and perhaps seems natural, to just add one
more rule to our existing <span class="stt">ArithC</span> datatype.</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>What are the negative consequences of modifying <span class="stt">ArithC</span>?</p></blockquote></div></p><p>This creates a few problems.  The first, obvious, one is that we now
have to modify all programs that process <span class="stt">ArithC</span>.  So far that&rsquo;s
only our interpreter, which is pretty simple, but in a more complex
implementation, that could already be a concern.  Second, we were
trying to add new constructs that we can define in terms of existing
ones; it feels slightly self-defeating to do this in a way that isn&rsquo;t
modular.  Third, and most subtly, there&rsquo;s something
<span style="font-style: italic">conceptually</span> wrong about modifying <span class="stt">ArithC</span>.  That&rsquo;s
because <span class="stt">ArithC</span> represents our <span style="font-style: italic">core</span> language.  In
contrast, subtraction and other additions represent our user-facing,
surface language.  It&rsquo;s wise to record conceptually different ideas in
distinct datatypes, rather than shoehorn them into one.  The
separation can look a little unwieldy sometimes, but it makes the
program much easier for future developers to read and maintain.
Besides, for different purposes you might want to layer on different
extensions, and separating the core from the surface enables that.</p><p><div class="SIntrapara">Therefore, we&rsquo;ll define a new datatype to reflect our intended surface
syntax terms:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">ArithS</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">numS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">plusS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ArithS</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ArithS</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">bminusS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ArithS</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ArithS</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">multS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ArithS</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ArithS</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This looks almost exactly like <span class="stt">ArithC</span>, other than the added
case, which follows the familiar recursive pattern.</div></p><p>Given this datatype, we should do two things.  First, we should modify
our parser to also parse <span class="stt">-</span> expressions, and always construct
<span class="stt">ArithS</span> terms (rather than any <span class="stt">ArithC</span> ones).  Second, we
should implement a <span class="stt">desugar</span> function that translates
<span class="stt">ArithS</span> values into <span class="stt">ArithC</span> ones.</p><p>Let&rsquo;s write the obvious part of <span class="stt">desugar</span>:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cdesugar~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cdesugar~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;desugar&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">desugar</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">as</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ArithS</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ArithC</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">ArithS</span><span class="hspace">&nbsp;</span><span class="RktSym">as</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">numS</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numC</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">plusS</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">plusC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">desugar</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">desugar</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">multS</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">multC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">desugar</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">desugar</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cbminus.S-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;bminusS-case&gt;</a><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Now let&rsquo;s convert the mathematical description of subtraction above
into code:</div></p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cbminus.S-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cbminus.S-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;bminusS-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">bminusS</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">plusC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">desugar</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">multC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numC</span><span class="hspace">&nbsp;</span><span class="RktVal"><span class="nobreak">-1</span></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">desugar</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>It&rsquo;s a common mistake to forget the recursive calls to <span class="stt">desugar</span>
on <span class="stt">l</span> and <span class="stt">r</span>.  What happens when you forget them?  Try
for yourself and see.</p></blockquote></div></p><h4>4.2<tt>&nbsp;</tt><a name="(part._.Extension__.Unary_.Negation)"></a>Extension: Unary Negation</h4><p>Now let&rsquo;s consider another extension, which is a little more
interesting: unary negation.  This forces you to do a little more work
in the parser because, depending on your surface syntax, you may need
to look ahead to determine whether you&rsquo;re in the unary or binary
case.  But that&rsquo;s not even the interesting part!</p><p>There are many ways we can desugar unary negation.  We can define it
naturally as <span class="relax">\(-b = 0 - b\)</span>, or we could abstract over the desugaring
of binary subtraction with this expansion: <span class="relax">\(-b = 0 + -1 \times b\)</span>.</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Which one do you prefer?  Why?</p></blockquote></div></p><p><div class="SIntrapara">It&rsquo;s tempting to pick the first expansion, because it&rsquo;s much simpler.
Imagine we&rsquo;ve extended the <span class="stt">ArithS</span> datatype with a
representation of unary negation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktMeta">uminusS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">e</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ArithS</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Now the implementation in <span class="stt">desugar</span> is straightforward:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktMeta">uminusS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">e</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">desugar</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">bminusS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Let&rsquo;s make sure the types match up.  Observe that <span class="stt">e</span> is a
<span class="stt">ArithS</span> term, so it is valid to use as an argument to
<span class="stt">bminusS</span>, and the entire term can legally be passed to
<span class="stt">desugar</span>.  It is therefore important to <span style="font-style: italic">not</span> desugar
<span class="stt">e</span> but rather embed it directly in the generated term.  This
embedding of an input term in another one and recursively calling
desugar is a common pattern in desugaring tools; it is called a
<span style="font-style: italic">macro</span> (specifically, the &ldquo;macro&rdquo; here is this definition of
<span class="stt">uminusS</span>).</div></p><p><div class="SIntrapara">However, there are two problems with the definition above:
</div><div class="SIntrapara"><ol><li><p><div class="SIntrapara">The first is that the recursion is <span style="font-style: italic">generative</span>, which
  forces us to take extra care.<span class="refelem"><span class="refcolumn"><span class="refcontent">If you haven&rsquo;t heard of
generative recursion before, read the section on it in
<a href="http://www.htdp.org/"><span style="font-style: italic">How to Design Programs</span></a>.  Essentially, in
generative recursion the sub-problem is a computed function of the
input, rather than a structural piece of it.  This is an especially
simple case of generative recursion, because the &ldquo;function&rdquo; is
simple: it&rsquo;s just the <span class="stt">bminusS</span> constructor.</span></span></span>  We might be
  tempted to fix this by using a different rewrite:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktMeta">uminusS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">e</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">bminusS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">numS</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">desugar</span><span class="hspace">&nbsp;</span><span class="RktMeta">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">which does indeed eliminate the generativity.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Unfortunately, this desugaring transformation won&rsquo;t work at all!  Do
you see why?  If you don&rsquo;t, try to run it.</p></blockquote></div></p></li><li><p>The second is that we are implicitly depending on exactly what
<span class="stt">bminusS</span> means; if its meaning changes, so will that of
<span class="stt">uminusS</span>, even if we don&rsquo;t want it to.  In contrast, defining
a functional abstraction that consumes two terms and generates one
representing the addition of the first to -1 times the second, and
using this to define the desugaring of both <span class="stt">uminusS</span> and
<span class="stt">bminusS</span>, is a little more fault-tolerant.</p><p>You might say that the meaning of subtraction is never going to
change, so why bother?  Yes and no.  Yes, it&rsquo;s <span style="font-style: italic">meaning</span> is
unlikely to change; but no, its <span style="font-style: italic">implementation</span> might.  For
instance, the developer may decide to log all uses of binary
subtraction.  In the macro expansion, all uses of unary negation
would also get logged, but they would not in the second expansion.</p></li></ol></div></p><p>Fortunately, in this particular case we have a much simpler option,
which is to define <span class="relax">\(-b = -1 \times b\)</span>.  This expansion works with
the primitives we have, and follows structural recursion.  The reason
we took the above detour, however, is to alert you to these problems,
and warn that you might not always be so fortunate.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="first-interp.html" title="backward to &quot;3 A First Look at Interpretation&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="adding-functions.html" title="forward to &quot;5 Adding Functions to the Language&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>