<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>8&nbsp;Mutation: Structures and Variables</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Introduction.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Everything__We_Will_Say__About_Parsing.html" class="tocviewlink" data-pltdoc="x">Everything (We Will Say) About Parsing</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="first-interp.html" class="tocviewlink" data-pltdoc="x">A First Look at Interpretation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="first-desugar.html" class="tocviewlink" data-pltdoc="x">A First Taste of Desugaring</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="adding-functions.html" class="tocviewlink" data-pltdoc="x">Adding Functions to the Language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="From_Substitution_to_Environments.html" class="tocviewlink" data-pltdoc="x">From Substitution to Environments</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="higher-order-functions.html" class="tocviewlink" data-pltdoc="x">Functions Anywhere</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Mutation:<span class="mywbr"> &nbsp;</span> Structures and Variables</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="recursion.html" class="tocviewlink" data-pltdoc="x">Recursion and Cycles:<span class="mywbr"> &nbsp;</span> Procedures and Data</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Objects.html" class="tocviewlink" data-pltdoc="x">Objects</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Memory_Management.html" class="tocviewlink" data-pltdoc="x">Memory Management</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Representation_Decisions.html" class="tocviewlink" data-pltdoc="x">Representation Decisions</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Desugaring_as_a_Language_Feature.html" class="tocviewlink" data-pltdoc="x">Desugaring as a Language Feature</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Control_Operations.html" class="tocviewlink" data-pltdoc="x">Control Operations</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="types.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Statically:<span class="mywbr"> &nbsp;</span> Types</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="contracts.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Dynamically:<span class="mywbr"> &nbsp;</span> Contracts</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Alternate_Application_Semantics.html" class="tocviewlink" data-pltdoc="x">Alternate Application Semantics</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>8&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Mutation:<span class="mywbr"> &nbsp;</span> Structures and Variables</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">8.1&nbsp;</td><td><a href="#%28part._.Mutable_.Structures%29" class="tocviewlink" data-pltdoc="x">Mutable Structures</a></td></tr><tr><td align="right">8.2&nbsp;</td><td><a href="#%28part._mut-vars%29" class="tocviewlink" data-pltdoc="x">Variables</a></td></tr><tr><td align="right">8.3&nbsp;</td><td><a href="#%28part._.The_.Design_of_.Stateful_.Language_.Operations%29" class="tocviewlink" data-pltdoc="x">The Design of Stateful Language Operations</a></td></tr><tr><td align="right">8.4&nbsp;</td><td><a href="#%28part._.Parameter_.Passing%29" class="tocviewlink" data-pltdoc="x">Parameter Passing</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">8.1<tt>&nbsp;</tt></span><a href="#%28part._.Mutable_.Structures%29" class="tocsubseclink" data-pltdoc="x">Mutable Structures</a></td></tr><tr><td><span class="tocsublinknumber">8.1.1<tt>&nbsp;</tt></span><a href="#%28part._.A_.Simple_.Model_of_.Mutable_.Structures%29" class="tocsubseclink" data-pltdoc="x">A Simple Model of Mutable Structures</a></td></tr><tr><td><span class="tocsublinknumber">8.1.2<tt>&nbsp;</tt></span><a href="#%28part._.Scaffolding%29" class="tocsubseclink" data-pltdoc="x">Scaffolding</a></td></tr><tr><td><span class="tocsublinknumber">8.1.3<tt>&nbsp;</tt></span><a href="#%28part._.Interaction_with_.Closures%29" class="tocsubseclink" data-pltdoc="x">Interaction with Closures</a></td></tr><tr><td><span class="tocsublinknumber">8.1.4<tt>&nbsp;</tt></span><a href="#%28part._.Understanding_the_.Interpretation_of_.Boxes%29" class="tocsubseclink" data-pltdoc="x">Understanding the Interpretation of Boxes</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cinterp-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;interp-take-1&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cvalue-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;value-take-1&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cbox.C-case-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;boxC-case-take-1&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cunbox.C-case-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unboxC-case-take-1&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cseq.C-case-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;seqC-case-take-1&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cseq.C-case-take-2~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;seqC-case-take-2&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">8.1.5<tt>&nbsp;</tt></span><a href="#%28part._.Can_the_.Environment_.Help_%29" class="tocsubseclink" data-pltdoc="x">Can the Environment Help?</a></td></tr><tr><td><span class="tocsublinknumber">8.1.6<tt>&nbsp;</tt></span><a href="#%28part._.Introducing_the_.Store%29" class="tocsubseclink" data-pltdoc="x">Introducing the Store</a></td></tr><tr><td><span class="tocsublinknumber">8.1.7<tt>&nbsp;</tt></span><a href="#%28part._store-passing-style%29" class="tocsubseclink" data-pltdoc="x">Interpreting Boxes</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cinterp-mut-struct~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;interp-mut-struct&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cms-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-numC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cms-lam.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-lamC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cms-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-idC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cms-seq.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-seqC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cms-plus.C%2Fmult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-plusC/multC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cms-box.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-boxC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cms-unbox.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-unboxC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cms-setbox.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-setboxC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cms-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-appC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cms-app.C-case-main~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-appC-case-main&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">8.1.8<tt>&nbsp;</tt></span><a href="#%28part._.The_.Bigger_.Picture%29" class="tocsubseclink" data-pltdoc="x">The Bigger Picture</a></td></tr><tr><td><span class="tocsublinknumber">8.2<tt>&nbsp;</tt></span><a href="#%28part._mut-vars%29" class="tocsubseclink" data-pltdoc="x">Variables</a></td></tr><tr><td><span class="tocsublinknumber">8.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Terminology%29" class="tocsubseclink" data-pltdoc="x">Terminology</a></td></tr><tr><td><span class="tocsublinknumber">8.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Syntax%29" class="tocsubseclink" data-pltdoc="x">Syntax</a></td></tr><tr><td><span class="tocsublinknumber">8.2.3<tt>&nbsp;</tt></span><a href="#%28part._.Interpreting_.Variables%29" class="tocsubseclink" data-pltdoc="x">Interpreting Variables</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cset.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;setC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3crest-of-set.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;rest-of-setC-case&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">8.3<tt>&nbsp;</tt></span><a href="#%28part._.The_.Design_of_.Stateful_.Language_.Operations%29" class="tocsubseclink" data-pltdoc="x">The Design of Stateful Language Operations</a></td></tr><tr><td><span class="tocsublinknumber">8.4<tt>&nbsp;</tt></span><a href="#%28part._.Parameter_.Passing%29" class="tocsubseclink" data-pltdoc="x">Parameter Passing</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="higher-order-functions.html" title="backward to &quot;7 Functions Anywhere&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="recursion.html" title="forward to &quot;9 Recursion and Cycles: Procedures and Data&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>8<tt>&nbsp;</tt><a name="(part._mut-struct-vs-var)"></a>Mutation: Structures and Variables</h3><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><p>It&rsquo;s time for another</p><p><div class="SIntrapara"><span style="font-weight: bold">Which of these is the same?</span></div><div class="SIntrapara"><blockquote><ul><li><p><span class="stt">f = 3</span></p></li><li><p><span class="stt">o.f = 3</span></p></li><li><p><span class="stt">f = 3</span></p></li></ul></blockquote></div></p><p>Assuming all three are in Java, the first and third could behave
exactly like each other or exactly like the second: it all depends on
whether <span class="stt">f</span> is a local identifier (such as a parameter) or a
field of the object (i.e., the code is really <span class="stt">this.f = 3</span>).</p><p>In either case, we are asking the evaluator to permanently change the
value bound to <span class="stt">f</span>.  This has important implications for other
observers.  Until now, for a given set of inputs, a computation always
returned the same value.  Now, the answer depends on <span style="font-style: italic">when</span> it
was invoked: above, it depends on whether it was invoked before or
after the value of <span class="stt">f</span> was changed.  The introduction of time has
profound effects on reasoning about programs.</p><p>However, there are really two quite different notions of change buried
in the uniform syntax above.  Changing the value of a field
(<span class="stt">o.f = 3</span> or <span class="stt">this.f = 3</span>) is extremely different from
changing that of an identifier
(<span class="stt">f = 3</span> where <span class="stt">f</span> is bound inside the method, not by the
object).  We will explore these in turn.  We&rsquo;ll tackle fields below,
and return to identifiers in <a href="#%28part._mut-vars%29" data-pltdoc="x">Variables</a>.</p><h4>8.1<tt>&nbsp;</tt><a name="(part._.Mutable_.Structures)"></a>Mutable Structures</h4><h5>8.1.1<tt>&nbsp;</tt><a name="(part._.A_.Simple_.Model_of_.Mutable_.Structures)"></a>A Simple Model of Mutable Structures</h5><p><div class="SIntrapara">Objects are a generalization of structures, as we will soon see [REF].
Therefore, fields in objects are a generalization of fields in
structures and to understand mutation, it is mostly (but not entirely!
[REF]) sufficient to understand mutable objects.  To be even more
reductionist, we don&rsquo;t need a structure to have many fields: a single
one will suffice.  We call this a <span style="font-style: italic">box</span>.  In Racket, boxes support
just three operations:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">boxof</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">boxof</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">boxof</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">void</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Thus, <span class="stt">box</span> takes a value and wraps it in a mutable container.
<span class="stt">unbox</span> extracts the current value inside the container.
Finally, <span class="stt">set-box!</span> changes the value in the container, and in a
typed language, the new value is expected to be type-consistent with
what was there before.  You can thus think of a box as equivalent to a
Java container class with parameterized type, which has a single
member field with a getter and setter: <span class="stt">box</span> is the constructor,
<span class="stt">unbox</span> is the getter, and <span class="stt">set-box!</span> is the setter.
(Because there is only one field, its name is irrelevant.)
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">class</span><span class="hspace">&nbsp;</span><span class="RktMeta">Box&lt;T&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">private</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="hspace">&nbsp;</span><span class="RktMeta">the_value</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">Box</span><span class="RktPn">(</span><span class="RktMeta">T</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">this.the_value</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">T</span><span class="hspace">&nbsp;</span><span class="RktMeta">get</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">return</span><span class="hspace">&nbsp;</span><span class="RktMeta">the_value</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">void</span><span class="hspace">&nbsp;</span><span class="RktMeta">set</span><span class="RktPn">(</span><span class="RktMeta">T</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">the_value</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>Because we must sometimes mutate in groups (e.g., removing money from
one bank account and depositing it in another), it is useful to be
able to sequence a group of mutable operations.  In Racket,
<span class="stt">begin</span> lets you write a sequence of operations; it
evaluates them in order and returns the value of the last one.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Define <span class="stt">begin</span> by desugaring into
<span class="stt">let</span> (and hence into <span class="stt">lambda</span>).</p></blockquote></div></p><p><span class="refelem"><span class="refcolumn"><span class="refcontent">This is an excellent illustration of the non-canonical
nature of desugaring.  We&rsquo;ve chosen to add to the core a construct
that is certainly not necessary.  If our goal was to shrink the size
of the interpreter&#8212;<wbr></wbr>perhaps at some cost to the size of the input
program&#8212;<wbr></wbr>we would not make this choice.  But our goal in this book is
to study pedagogic interpreters, so we choose a larger language
because it is more instructive.</span></span></span>
Even though it is possible to eliminate <span class="stt">begin</span> as syntactic
sugar, it will prove extremely useful for understanding how mutation
works.  Therefore, we will add a simple, two-term version of
sequencing to the core.</p><h5>8.1.2<tt>&nbsp;</tt><a name="(part._.Scaffolding)"></a>Scaffolding</h5><p><div class="SIntrapara">First, let&rsquo;s extend our core language datatype:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">idC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">s</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">appC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fun</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">plusC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">multC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">lamC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">body</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">boxC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">unboxC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">setboxC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">seqC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">b1</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">b2</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Observe that in a <span class="stt">setboxC</span> expression, both the box position and
its new value are expressions.  The latter is unsurprising, but the
former might be.  It means we can write programs such as this in
corresponding Racket:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">b0</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">b1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">list</span><span class="hspace">&nbsp;</span><span class="RktMeta">b0</span><span class="hspace">&nbsp;</span><span class="RktMeta">b1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">second</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This evaluates to a list of boxes, the first containing <span class="stt">1</span> and
the second <span class="stt">2</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">Your output may look like
<span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">(#&amp;1 #&amp;2)</span>.  The <span class="stt">#&amp;</span> notation is Racket&rsquo;s abbreviated
syntactic prefix for &ldquo;box&rdquo;.</span></span></span>  Observe that the first argument to the
first <span class="stt">set-box!</span> instruction was <span class="stt">(first l)</span>, i.e., an
expression that evaluated to a box, rather than just a literal box or
an identifier.  This is precisely analogous to languages like Java,
where one can (taking some type liberties) write
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">public</span><span class="hspace">&nbsp;</span><span class="RktMeta">static</span><span class="hspace">&nbsp;</span><span class="RktMeta">void</span><span class="hspace">&nbsp;</span><span class="RktMeta">main</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">String</span><span class="RktPn">[</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">args</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">Box&lt;Integer&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">b0</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta">Box&lt;Integer&gt;</span><span class="RktPn">(</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">Box&lt;Integer&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">b1</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta">Box&lt;Integer&gt;</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">ArrayList&lt;Box&lt;Integer&gt;&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta">ArrayList&lt;Box&lt;Integer&gt;&gt;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">l.add</span><span class="RktPn">(</span><span class="RktMeta">b0</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">l.add</span><span class="RktPn">(</span><span class="RktMeta">b1</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">l.get</span><span class="RktPn">(</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktMeta">.set</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">l.get</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta">.set</span><span class="RktPn">(</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Observe that <span class="stt">l.get(0)</span> is a compound expression being used to
find the appropriate box, and evaluates to the box object on which
<span class="stt">set</span> is invoked.</div></p><p>For convenience, we will assume that we have implemented desugaring to
provide us with (a) <span class="stt">let</span> and (b) if necessary, more than two
terms in a sequence (which can be desugared into nested sequences).
We will also sometimes write expressions in the original Racket
syntax, both for brevity (because the core language terms can grow
quite large and unwieldy) and so that you can run these same terms in
Racket and observe what answers they produce.  As this implies, we are
taking the behavior in Racket&#8212;<wbr></wbr>which is similar to the behavior in
just about every mainstream language with mutable objects and
structures&#8212;<wbr></wbr>as the reference behavior.</p><h5>8.1.3<tt>&nbsp;</tt><a name="(part._.Interaction_with_.Closures)"></a>Interaction with Closures</h5><p><div class="SIntrapara">Consider a simple counter:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">new-loc</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Every time it is invoked, it produces the next integer:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (new-loc)</span></p></td></tr><tr><td><p><span class="stt">- number</span></p></td></tr><tr><td><p><span class="stt">1</span></p></td></tr><tr><td><p><span class="stt">&gt; (new-loc)</span></p></td></tr><tr><td><p><span class="stt">- number</span></p></td></tr><tr><td><p><span class="stt">2</span></p></td></tr></table></div><div class="SIntrapara">Why does this work?  It&rsquo;s because the box is created only once, and
bound to <span class="stt">n</span>, and then closed over.
All subsequent mutations affect <span style="font-style: italic">the same box</span>.  In
contrast, swapping two lines makes a big difference:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">new-loc-broken</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Observe:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (new-loc-broken)</span></p></td></tr><tr><td><p><span class="stt">- number</span></p></td></tr><tr><td><p><span class="stt">1</span></p></td></tr><tr><td><p><span class="stt">&gt; (new-loc-broken)</span></p></td></tr><tr><td><p><span class="stt">- number</span></p></td></tr><tr><td><p><span class="stt">1</span></p></td></tr></table></div><div class="SIntrapara">In this case, a new box is allocated on every invocation of the
function, so the answer each time is the same (despite the mutation
inside the procedure).  Our implementation of boxes should be certain
to preserve this distinction.</div></p><p>The examples above hint at an implementation necessity.  Clearly,
whatever the environment closes over in <span class="stt">new-loc</span> must refer
to the same box each time.  Yet something also needs to make sure that
the value in that box is different each time!  Look at it more
carefully: it must be <span style="font-style: italic">lexically</span> the same, but
<span style="font-style: italic">dynamically</span> different.  This distinction will be at the heart
of our implementation.</p><h5>8.1.4<tt>&nbsp;</tt><a name="(part._.Understanding_the_.Interpretation_of_.Boxes)"></a>Understanding the Interpretation of Boxes</h5><p>Let&rsquo;s begin by reproducing our current interpreter:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cinterp-take-1~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cinterp-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;interp-take-1&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">expr</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Env</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Value</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="hspace">&nbsp;</span><span class="RktSym">expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">numC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numV</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">idC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lookup</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">appC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">local</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">f-value</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closV-body</span><span class="hspace">&nbsp;</span><span class="RktSym">f-value</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-env</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bind</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closV-arg</span><span class="hspace">&nbsp;</span><span class="RktSym">f-value</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closV-env</span><span class="hspace">&nbsp;</span><span class="RktSym">f-value</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">plusC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">multC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">lamC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closV</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&lt;boxC-case&gt;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&lt;unboxC-case&gt;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&lt;setboxC-case&gt;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&lt;seqC-case&gt;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Because we&rsquo;ve introduced a new kind of value, the box, we have to
update the set of values:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cvalue-take-1~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cvalue-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;value-take-1&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define-type</span><span class="hspace">&nbsp;</span><span class="RktSym">Value</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">numV</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">number</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">closV</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">arg</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">symbol</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">body</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Env</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">boxV</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Value</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Two of these cases should be easy.  When we&rsquo;re given a <span class="stt">box</span>
expression, we simply evaluate it and return it wrapped in a
<span class="stt">boxV</span>:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cbox.C-case-take-1~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cbox.C-case-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;boxC-case-take-1&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">boxC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">boxV</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>Similarly, extracting a value from a box is easy:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cunbox.C-case-take-1~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cunbox.C-case-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unboxC-case-take-1&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">unboxC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">boxV-v</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>By now, you should be constructing a healthy set of test cases to make
sure these behave as you&rsquo;d expect.</p><p>Of course, we haven&rsquo;t done any hard work yet.  All the interesting
behavior is, presumably, hidden in the treatment of <span class="stt">setboxC</span>.
It may therefore surprise you that we&rsquo;re going to look at <span class="stt">seqC</span>
first instead (and you&rsquo;ll see why we included it in the core).</p><p>Let&rsquo;s take the most natural implementation of a sequence of two
instructions:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cseq.C-case-take-1~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cseq.C-case-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;seqC-case-take-1&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">seqC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">b1</span><span class="hspace">&nbsp;</span><span class="RktSym">b2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">b1</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">b2</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>That is, we evaluate the first term, then the second, and return the
result of the second.</p><p>You should immediately spot something troubling.  We bound the result
of evaluating the first term, but didn&rsquo;t subsequently do anything with
it.  That&rsquo;s okay: presumably the first term contained a mutation
expression of some sort, and its value is uninteresting (indeed, note
that <span class="stt">set-box!</span> returns a void value).  Thus, another
implementation might be this:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cseq.C-case-take-2~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cseq.C-case-take-2~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;seqC-case-take-2&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">seqC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">b1</span><span class="hspace">&nbsp;</span><span class="RktSym">b2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">begin</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">b1</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">b2</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>Not only is this slightly dissatisfying in that it just uses the
analogous Racket sequencing construct, it still can&rsquo;t possibly be
right!  This can only work <span style="font-style: italic">only if the result of the mutation is
being stored somewhere</span>.  But because our interpreter only computes
values, and does not perform any mutation itself, any mutations in
<span class="stt">(interp b1 env)</span> are completely lost.  This is obviously not
what we want.</p><h5>8.1.5<tt>&nbsp;</tt><a name="(part._.Can_the_.Environment_.Help_)"></a>Can the Environment Help?</h5><p><div class="SIntrapara">Here is another example that can help:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In Racket, this evaluates to <span class="stt">2</span>.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Represent this expression in <span class="stt">ExprC</span>.</p></blockquote></div></p><p><div class="SIntrapara">Let&rsquo;s consider the evaluation of the inner sequence.  In both cases,
the expression (the representation of <span class="stt">(set-box! ...)</span>) is
exactly identical.  Yet something is changing underneath, because
these cause the value of the box to go from <span class="stt">0</span> to <span class="stt">2</span>!  We
can &ldquo;see&rdquo; this even more clearly if instead we evaluate
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">which evaluates to <span class="stt">3</span>.  Here, the two calls to <span class="stt">interp</span> in
the rule for addition are sending exactly the same textual expression
in both cases.  Yet somehow the effects from the left branch of the
addition are being felt in the right branch, and we must rule out
spukhafte Fernwirkung.</div></p><p>If the interpreter is being given precisely the same expression, how
can it possibly avoid producing precisely the same answer?  The most
obvious way is if the interpreter&rsquo;s other parameter, the environment
were somehow different.  As of now the exact same environment is sent
to both both branches of the sequence and both arms of the addition,
so our interpreter&#8212;<wbr></wbr>which produces the same output every time on a
given input&#8212;<wbr></wbr>cannot possibly produce the answers we want.</p><p><div class="SIntrapara">Here is what we know so far:
</div><div class="SIntrapara"><ol><li><p>We must somehow make sure the interpreter is fed different
arguments on calls that are expected to potentially produce
different results.</p></li><li><p>We must return from the interpreter some record of the
mutations made when evaluating its argument expression.</p></li></ol></div><div class="SIntrapara">Because the expression is what it is, the first point suggests that we
might try to use the environment to reflect the differences between
invocations.  In turn, the second point suggests that each invocation
of the interpreter should also <span style="font-style: italic">return</span> the environment, so it
can be passed to the next invocation.
Roughly, then, the type of the interpreter might become:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">interp</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprC</span><span class="hspace">&nbsp;</span><span class="RktCmt">*</span><span class="hspace">&nbsp;</span><span class="RktCmt">Env</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Value</span><span class="hspace">&nbsp;</span><span class="RktCmt">*</span><span class="hspace">&nbsp;</span><span class="RktCmt">Env</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">That is, the interpreter consumes an expression and environment; it
evaluates in that environment, updating it as it proceeds; when the
expression is done evaluating, the interpreter returns the answer (as
it did before), <span style="font-style: italic">along with</span> an updated environment, which in
turn is sent to the next invocation of the interpreter.  And the
treatment of <span class="stt">setboxC</span> would somehow impact the environment to
reflect the mutation.</div></p><p><div class="SIntrapara">Before we dive into the implementation, however, we should consider
the consequences of such a change.  The environment already serves an
important purpose: it holds deferred substitutions.  In that respect,
it already has a precise semantics&#8212;<wbr></wbr>given by substitution&#8212;<wbr></wbr>and we
must be careful to not alter that.  One consequence of its tie to
substitution is that it is also the <span style="font-style: italic">repository of lexical scope
information</span>.  If we were to allow the extended environment escape
from one branch of addition and be used in the other, for instance,
consider the impact on the equivalent of the following program:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">It should be evident that this program has an error: <span class="stt">b</span> in the
right branch of the addition is unbound (the scope of the <span class="stt">b</span> in
the left branch ends with the closing of the <span class="stt">let</span>&#8212;<wbr></wbr>if this is
not evident, desugar the above expression to use functions).  But the
extended environment at the end of interpreting the <span class="stt">let</span> clearly
has <span class="stt">b</span> bound in it.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Work out the above problem in detail and make sure you understand it.</p></blockquote></div></p><p>You could try various other related proposals, but they are likely to
all have similar failings.  For instance, you may decide that, because
the problem has to do with additional bindings in the environment, you
will instead remove all added bindings in the returned environment.
Sounds attractive?  Did you remember we have closures?</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p><div class="SIntrapara">Consider the representation of the following program:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">What problems does this example cause?</div></p></blockquote></div></p><p>Rather, we should note that while the <span style="font-style: italic">constraints</span> described
above are all valid, the <span style="font-style: italic">solution</span> we proposed is not the only
one.  What we require are the two conditions enumerated above; observe
that neither one actually requires the environment to be the
responsible agent.  Indeed, it is quite evident that the environment
<span style="font-style: italic">cannot</span> be the principal agent.</p><h5>8.1.6<tt>&nbsp;</tt><a name="(part._.Introducing_the_.Store)"></a>Introducing the Store</h5><p>The preceding discussion tells us that we need <span style="font-style: italic">two</span> repositories
to accompany the expression, not one.  One of them, the environment,
continues to be responsible for maintaining lexical scope.  But the
environment cannot directly map identifiers to their value, because
the value might change.  Instead, something else needs to be
responsible for maintaining the dynamic state of mutated boxes.  This
latter data structure is called the <span style="font-style: italic">store</span>.</p><p><div class="SIntrapara">Like the environment, the store is a partial map.  Its domain could be
any abstract set of names, but it is natural to think of these as
numbers, meant to stand for memory locations.  This is because the
store in the semantics maps directly onto (abstracted) physical memory
in the machine, which is traditionally addressed by numbers.  Thus the
environment maps names to locations, and the store maps locations to
values:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type-alias</span><span class="hspace">&nbsp;</span><span class="RktMeta">Location</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Binding</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">bind</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">name</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Location</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define-type-alias</span><span class="hspace">&nbsp;</span><span class="RktMeta">Env</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">Binding</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">mt-env</span><span class="hspace">&nbsp;</span><span class="RktMeta">empty</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">extend-env</span><span class="hspace">&nbsp;</span><span class="RktMeta">cons</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Storage</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">cell</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">location</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Location</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">val</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Value</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define-type-alias</span><span class="hspace">&nbsp;</span><span class="RktMeta">Store</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">Storage</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">mt-store</span><span class="hspace">&nbsp;</span><span class="RktMeta">empty</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">override-store</span><span class="hspace">&nbsp;</span><span class="RktMeta">cons</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">We&rsquo;ll also equip ourselves with a function to look up values in the
store, just as we already have one for the environment (which now
returns locations instead):
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lookup</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">for</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Env</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Location</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fetch</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">loc</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Location</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">sto</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Store</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Value</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">With this, we can refine our notion of values to the correct one:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Value</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">numV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">closV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">body</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Env</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">boxV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Location</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Fill in the bodies of <span class="stt">lookup</span> and <span class="stt">fetch</span>.</p></blockquote></div></p><h5>8.1.7<tt>&nbsp;</tt><a name="(part._store-passing-style)"></a>Interpreting Boxes</h5><p><div class="SIntrapara">Now we have something that the environment can return, updated,
reflecting mutations during the evaluation of the expression, without
having to change the environment in any way.  Because a function can
return only one value, let&rsquo;s define a data structure to hold the new
result from the interpreter:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Result</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">v*s</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Value</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">s</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Store</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Thus the interpreter&rsquo;s type becomes:</div></p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cinterp-mut-struct~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cinterp-mut-struct~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;interp-mut-struct&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">expr</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Env</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">sto</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Store</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Result</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cms-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-numC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cms-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-idC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cms-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-appC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cms-plus.C%2Fmult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-plusC/multC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cms-lam.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-lamC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cms-box.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-boxC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cms-unbox.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-unboxC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cms-setbox.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-setboxC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cms-seq.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-seqC-case&gt;</a><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>The easiest one to dispatch is numbers.  Remember that we have to
return the store reflecting all mutations that happened while
evaluating the given expression.  Because a number is a constant, no
mutations could have happened, so the returned store is the same as
the one passed in:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cms-num.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cms-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-numC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">numC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numV</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">sto</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>A similar argument applies to closure creation; observe that we are
speaking of the <span style="font-style: italic">creation</span>, not <span style="font-style: italic">use</span>, of closures:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cms-lam.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cms-lam.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-lamC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">lamC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closV</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">sto</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>Identifiers are almost as straightforward, though if you are
simplistic, you&rsquo;ll get a type error that will alert you that to obtain
a value, you must now look up both in the environment <span class="stt">and in the
store</span>:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cms-id.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cms-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-idC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">idC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fetch</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lookup</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">sto</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">sto</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>Notice how <span class="stt">lookup</span> and <span class="stt">fetch</span> compose to produce the same
result that <span class="stt">lookup</span> alone produced before.</p><p>Now things get interesting.</p><p><div class="SIntrapara">Let&rsquo;s take sequencing.  Clearly, we need to interpret the two terms:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">interp</span><span class="hspace">&nbsp;</span><span class="RktMeta">b1</span><span class="hspace">&nbsp;</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">sto</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">interp</span><span class="hspace">&nbsp;</span><span class="RktMeta">b2</span><span class="hspace">&nbsp;</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">sto</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Oh, but wait.  The whole point was to evaluate the second term
<span style="font-style: italic">in the store returned by the first one</span>&#8212;<wbr></wbr>otherwise there would
have been no point to all these changes.  Therefore, instead we must
evaluate the first term, capture the resulting store, and use it to
evaluate the second.  (Evaluating the first term also yields its
value, but sequencing ignores this value and assumes the first time
was run purely for its potential mutations.)  We will write this in a
stylized manner:</div></p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cms-seq.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cms-seq.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-seqC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">seqC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">b1</span><span class="hspace">&nbsp;</span><span class="RktSym">b2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">b1</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">sto</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v-b1</span><span class="hspace">&nbsp;</span><span class="RktSym">s-b1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">b2</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">s-b1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>This says to <span class="stt">(interp b1 env sto)</span>; name the resulting value and
store <span class="stt">v-b1</span> and <span class="stt">s-b1</span>, respectively; and evaluate the
second term in the store from the first: <span class="stt">(interp b2 env s-b1)</span>.
The result will be the value and store returned by the second term,
which is what we expect.  The fact that the first term&rsquo;s effect is
only on the store can be read from the code because, though we bind
<span class="stt">v-b1</span>, we never subsequently use it.</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Spend a moment contemplating the code above.  You&rsquo;ll soon need to
adjust your eyes to read this pattern fluently.</p></blockquote></div></p><p>Now let&rsquo;s move on to the binary arithmetic primitives.  These are
similar to sequencing in that they have two sub-terms, but in this
case we really do care about the value from each branch.  As usual,
we&rsquo;ll look at only <span class="stt">plusC</span> since <span class="stt">multC</span> is virtually
identical.</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cms-plus.C/mult.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cms-plus.C%2Fmult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-plusC/multC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">plusC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">sto</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v-l</span><span class="hspace">&nbsp;</span><span class="RktSym">s-l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">s-l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v-r</span><span class="hspace">&nbsp;</span><span class="RktSym">s-r</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num+</span><span class="hspace">&nbsp;</span><span class="RktSym">v-l</span><span class="hspace">&nbsp;</span><span class="RktSym">v-r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">s-r</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>Observe that we&rsquo;ve unfolded the sequencing pattern out another level,
so we can hold on to both results and supply them to <span class="stt">num+</span>.</p><p>Here&rsquo;s an important distinction.  When we evaluate a term, we usually
use the same environment for all its sub-terms in accordance with the
scoping rules of the language.  The environment thus flows in a
recursive-descent pattern.  In contrast, the store is <span style="font-style: italic">threaded</span>:
rather than using the same store in all branches, we take the store
from one branch and pass it on to the next, and take the result and
send it back out.  This pattern is called <span style="font-style: italic">store-passing style</span>.</p><p>Now the penny drops.  We see that store-passing style is our secret
ingredient: it enables the environment to preserve lexical scope while
still giving a binding structure that can reflect changes.  Our
intution told us that the environment had to somehow participate in
obtaining different results for the same expression, and we can now
see how it does: not directly, by itself changing, but indirectly, by
referring to the store, which updates.  Now we only need to see how
the store itself &ldquo;changes&rdquo;.</p><p>Let&rsquo;s begin with boxing.  To store a value in a box, we have to first
allocate a new place in the store where its value will reside.  The
value corresponding to a box will then remember this location, for use
in box mutation.</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cms-box.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cms-box.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-boxC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">boxC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">sto</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v-a</span><span class="hspace">&nbsp;</span><span class="RktSym">s-a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">where</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">new-loc</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">boxV</span><span class="hspace">&nbsp;</span><span class="RktSym">where</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">override-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cell</span><span class="hspace">&nbsp;</span><span class="RktSym">where</span><span class="hspace">&nbsp;</span><span class="RktSym">v-a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">s-a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Observe that we have relied above on <span class="stt">new-loc</span>, which is itself
implemented in terms of boxes!  This is outright cheating.  How would
you modify the interpreter so that we no longer need an mutating
implementation of <span class="stt">new-loc</span>?</p></blockquote></div></p><p>To eliminate this style of <span class="stt">new-loc</span>, the simplest option would
be to add yet another parameter to and return value from the
interpreter, which represents the largest address used so far.  Every
operation that allocates in the store would return an incremented
address, while all others would return it unchanged.  In other words,
this is precisely another application of the store-passing pattern.
Writing the interpreter this way would make it extremely unwieldy and
might obscure the more important use of store-passing for the store
itself, which is why we have not done so.  However, it is important to
make sure that we can: that&rsquo;s what tells us that we are not reliant on
boxes to add boxes to the language.</p><p>Now that boxes are recording the location in memory, getting the value
corresponding to them is easy.</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cms-unbox.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cms-unbox.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-unboxC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">unboxC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">sto</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v-a</span><span class="hspace">&nbsp;</span><span class="RktSym">s-a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fetch</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">boxV-l</span><span class="hspace">&nbsp;</span><span class="RktSym">v-a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">s-a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">s-a</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>It&rsquo;s the same pattern we saw before, where we have to use <span class="stt">fetch</span>
to obtain the actual value residing at that location.  Note that we
are relying on Racket to halt with an error if the underlying value
isn&rsquo;t actually a <span class="stt">boxV</span>; otherwise it would be dangerous to not
check, since this would be tantamount to dereferencing arbitrary
memory (as C programs can, sometimes with disastrous consequences).</p><p>Let&rsquo;s now see how to update the value held in a box.  First we have to
evaluate the box expression to obtain a box, and the value expression
to obtain the new value to store in it.  The box&rsquo;s value is going to
be a <span class="stt">boxV</span> holding a location.</p><p><div class="SIntrapara">In principle, we want to &ldquo;change&rdquo;, or override, the value at that
location in the store.  We can do this in two ways.
</div><div class="SIntrapara"><ol><li><p>One is to traverse the store, find the old binding for that
location, and replace it with the new one, copying all the other
store bindings unchanged.</p></li><li><p>The other, lazier, option is to simply extend the store with a
new binding for that location, which works provided we always obtain
the most recent binding for a location (which is how <span class="stt">lookup</span>
works in the environment, so <span class="stt">fetch</span> presumably also does in
the store).</p></li></ol></div><div class="SIntrapara">The code below is written to be independent of these options:</div></p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cms-setbox.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cms-setbox.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-setboxC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">setboxC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">sto</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v-b</span><span class="hspace">&nbsp;</span><span class="RktSym">s-b</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">s-b</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v-v</span><span class="hspace">&nbsp;</span><span class="RktSym">s-v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktSym">v-v</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">override-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cell</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">boxV-l</span><span class="hspace">&nbsp;</span><span class="RktSym">v-b</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v-v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">s-v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>However, because we&rsquo;ve implemented <span class="stt">override-store</span> as
<span class="stt">cons</span> above, we&rsquo;ve actually taken the lazier (and slightly
riskier, because of its dependence on the implementation of
<span class="stt">fetch</span>) option.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Implement the other version of store alteration, whereby we update an
existing binding and thereby avoid multiple bindings for a location in
the store.</p></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>When we look for a location to override the value stored at it, can
the location fail to be present?  If so, write a program that
demonstrates this.  If not, explain what invariant of the interpreter
prevents this from happening.</p></blockquote></div></p><p>Alright, we&rsquo;re now done with everything other than application!  Most
of application should already be familiar: evaluate the function
position, evaluate the argument position, interpret the closure body
in an extension of the closure&rsquo;s environment...but how do stores
interact with this?</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cms-app.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cms-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-appC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">appC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">sto</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v-f</span><span class="hspace">&nbsp;</span><span class="RktSym">s-f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">s-f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v-a</span><span class="hspace">&nbsp;</span><span class="RktSym">s-a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cms-app.C-case-main~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-appC-case-main&gt;</a><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>Let&rsquo;s start by thinking about extending the closure environment.  The
name we&rsquo;re extending it with is obviously the name of the function&rsquo;s
formal parameter.  But what location do we bind it to?  To avoid any
confusion with already-used locations (a confusion we will explicitly
introduce later! [REF]), let&rsquo;s just allocate a new location.  This
location is used in the environment, and the value of the argument
resides at this location in the store:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cms-app.C-case-main~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cms-app.C-case-main~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;ms-appC-case-main&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">where</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">new-loc</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closV-body</span><span class="hspace">&nbsp;</span><span class="RktSym">v-f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-env</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bind</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closV-arg</span><span class="hspace">&nbsp;</span><span class="RktSym">v-f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">where</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closV-env</span><span class="hspace">&nbsp;</span><span class="RktSym">v-f</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">override-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cell</span><span class="hspace">&nbsp;</span><span class="RktSym">where</span><span class="hspace">&nbsp;</span><span class="RktSym">v-a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">s-a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Because we have not said the function parameter is mutable, there is
no real need to have implemented procedure calls this way.  We could
instead have followed the same strategy as before.  Indeed, observe
that the mutability of this location will never be used: only
<span class="stt">setboxC</span> changes what&rsquo;s in an existing store location (the
<span class="stt">override-store</span> above is technically a store
<span style="font-style: italic">initialization</span>), and then only when they are referred to by
<span class="stt">boxV</span>s, but no box is being allocated above.<span class="refelem"><span class="refcolumn"><span class="refcontent">You
could call this the useless app store.</span></span></span>
However, we have chosen to implement application this way for
uniformity, and to reduce the number of cases we&rsquo;d have to handle.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>It&rsquo;s a useful exercise to try to limit the use of store locations
<span style="font-style: italic">only</span> to boxes.  How many changes would you need to make?</p></blockquote></div></p><h5>8.1.8<tt>&nbsp;</tt><a name="(part._.The_.Bigger_.Picture)"></a>The Bigger Picture</h5><p>Even though we&rsquo;ve finished the implementation, there are still many
subtleties and insights to discuss.</p><ol><li><p>Implicit in our implementation is a subtle and important
  decision: the <span style="font-style: italic">order of evaluation</span>.  For instance, why did we
  not implement addition thus?</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktMeta">plusC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">r</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">type-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">Result</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">interp</span><span class="hspace">&nbsp;</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">sto</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">v*s</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v-r</span><span class="hspace">&nbsp;</span><span class="RktMeta">s-r</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">type-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">Result</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">interp</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">s-r</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">v*s</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v-l</span><span class="hspace">&nbsp;</span><span class="RktMeta">s-l</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v*s</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">num+</span><span class="hspace">&nbsp;</span><span class="RktMeta">v-l</span><span class="hspace">&nbsp;</span><span class="RktMeta">v-r</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">s-l</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote><p>It would have been perfectly consistent to do so.  Similarly,
  embodied in the pattern of store-passing is the decision to evaluate
  the function position before the argument.  Observe that:</p><ol><li><p>Previously, we delegated such decisions to the underlying
language implementation.  Now, store-passing has forced us to
<span style="font-style: italic">sequentialize</span> the computation, and hence make this decision
ourselves (whether we realized it or not).</p></li><li><p>Even more importantly, <span style="font-style: italic">this decision is now a semantic
one</span>.  Before there were mutations, one branch of an addition, for
instance, could not affect the value produced by the other
branch.<span class="refelem"><span class="refcolumn"><span class="refcontent">The only effect they could have was halting
with an error or failing to terminate&#8212;<wbr></wbr>which, to be sure, are
certainly observable effects, but at a much more gross level.  A
program would not terminate with two different answers depending
on the order of evaluation.</span></span></span>
Because each branch can have mutations that impact the value of
the other, we <span style="font-style: italic">must</span> choose some order so that programmers
can predict what their program is going to do!  Being forced to
write a store-passing interpreter has made this clear.</p></li></ol></li><li><p>Observe that in the application rule, we are passing along the
<span style="font-style: italic">dynamic</span> store, i.e., the one resulting from evaluating both
function and argument.  This is precisely the opposite of what we
said to do with the environment.  This distinction is critical.  The
store is, in effect, &ldquo;dynamically scoped&rdquo;, in that it reflects the
history of the computation, not its lexical shape.  Because we are
already using the term &ldquo;scope&rdquo; to refer to the bindings of
identifiers, however, it would be confusing to say &ldquo;dynamically
scoped&rdquo; to refer to the store.  Instead, we simply say that it is
<span style="font-style: italic">persistent</span>.</p><p>Languages sometimes dangerously conflate these two.  In C, for
instance, values bound to local identifiers are allocated (by
default) on the stack.  However, the stack matches the environment,
and hence disappears upon completion of the call.  If the call,
however, returned references to any of these values, these
references are now pointing to unused or even overridden memory: a
genuine source of serious errors in C programs.  The problem is that
the values themselves persist; it is only the identifiers that refer
to them that have lexical scope.</p></li><li><p>We have already discussed how there are two strategies for
overriding the store: to simply extend it (and rely on <span class="stt">fetch</span>
to extract the newest one) or to &ldquo;search-and-replace&rdquo;.  The latter
strategy has the virtue of not holding on to useless store bindings
that will can never be obtained again.</p><p>However, this does not cover all the wasted memory.  Over time, we
cease to be able to access some boxes entirely: e.g., if they are
bound to only one identifier, and that identifier is no longer in
scope.  These locations are called <span style="font-style: italic">garbage</span>.  Thinking more
conceptually, garbage locations are those whose elimination does not
have any impact on the value produced by a program.  There are many
strategies for identifying and reclaiming garbage locations, usually
called <span style="font-style: italic">garbage collection</span> [REF].</p></li><li><p>It&rsquo;s very important to evaluate every expression position and
  thread the store that results from it.  Consider, for instance, this
  implementation of <span class="stt">unboxC</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktMeta">unboxC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">type-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">Result</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">interp</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">sto</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">v*s</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v-a</span><span class="hspace">&nbsp;</span><span class="RktMeta">s-a</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v*s</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fetch</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">boxV-l</span><span class="hspace">&nbsp;</span><span class="RktMeta">v-a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">sto</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">s-a</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Did you notice?  We <span class="stt">fetch</span>ed the location from <span class="stt">sto</span>, not
  <span class="stt">s-a</span>.  But <span class="stt">sto</span> reflects mutations up to but before the
  evaluation of the <span class="stt">unboxC</span> expression, not any <span style="font-style: italic">within</span>
  it.  Could there possibly be any?  Mais oui!</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>With the incorrect code above, this would evaluate to <span class="stt">0</span>
  rather than <span class="stt">1</span>.</p></li><li><p>Here&rsquo;s another, similar, error:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktMeta">unboxC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">type-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">Result</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">interp</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">sto</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">v*s</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v-a</span><span class="hspace">&nbsp;</span><span class="RktMeta">s-a</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">v*s</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fetch</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">boxV-l</span><span class="hspace">&nbsp;</span><span class="RktMeta">v-a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">s-a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">sto</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote><p>How do we break this?  Well, we&rsquo;re returning the old store, the one
  before any mutations in the <span class="stt">unboxC</span> happened.  Thus, we just
  need the outside context to depend on one of them.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>This should evaluate to <span class="stt">2</span>, but because the store being
  returned is one where <span class="stt">b</span>&rsquo;s location is bound to the
  representation of <span class="stt">0</span>, the result is <span class="stt">1</span>.</p><p>If we combined both bugs above&#8212;<wbr></wbr>i.e., using <span class="stt">sto</span> twice in the
  last line instead of <span class="stt">s-a</span> twice&#8212;<wbr></wbr>this expression would
  evaluate to <span class="stt">0</span> rather than <span class="stt">2</span>.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Go through the interpreter; replace every reference to an updated
store with a reference to one before update; make sure your test cases
catch all the introduced errors!</p></blockquote></div></p></li><li><p>Observe that these uses of &ldquo;old&rdquo; stores enable us to perform
  a kind of <span style="font-style: italic">time travel</span>: because mutation introduces a notion
  of time, these enable us to go back in time to when the mutation had
  not yet occurred.  This sounds both interesting and perverse; does
  it have any use?</p><p>It does!  Imagine that instead of directly mutating the store, we
  introduce the idea of a journal of <span style="font-style: italic">intended</span> updates to the
  store.  The journal flows in a threaded manner just like the real
  store itself.  Some instruction creates a new journal; after that,
  all lookups first check the journal, and only if the journal cannot
  find a binding for a location is it looked for in the actual store.
  There are two other new instructions: one to <span style="font-style: italic">discard</span> the
  journal (i.e., perform time travel), and the other to <span style="font-style: italic">commit</span>
  it (i.e., all of its edits get applied to the real store).</p><p>This is the essence of <span style="font-style: italic">software transactional memory</span>.  Each
  thread maintains its own journal.  Thus, one thread does not see the
  edits made by the other before committing (because each thread sees
  only its own journal and the global store, but not the journals of
  other threads).  At the same time, each thread gets its own
  consistent view of the world (it sees edits it made, because these
  are recorded in the journal).  If the transaction ends successfully,
  all threads atomically see the updated global store.  If the
  transaction aborts, the discarded journal takes with it all changes and
  the state of the thread reverts (modulo global changes committed by
  other threads).</p><p>Software transactional memory offers one of the most sensible
  approaches to tackling the difficulties of multi-threaded
  programming, if we insist on programming with shared mutable state.
  Because most computers have only one global store, however,
  maintaining the journals can be expensive, and much effort goes into
  optimizing them.  As an alternative, some hardware architectures
  have begun to provide direct support for transactional memory by
  making the creation, maintenance, and commitment of journals as
  efficient as using the global store, removing one important barrier
  to the adoption of this idea.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Augment the language with  the journal features of software
transactional memory journal.</p></blockquote></div></p></li></ol><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>An alternate implementation strategy is to have the environment map
names to <span style="font-style: italic">boxed</span> <span class="stt">Value</span>s.  We don&rsquo;t do it here because it:
(a) would be cheating, (b) wouldn&rsquo;t tell us how to implement the same
feature in a language without boxes, (c) doesn&rsquo;t necessarily carry
over to other mutation operations, and (d) most of all, doesn&rsquo;t really
give us <span style="font-style: italic">insight</span> into what is happening here.</p><p>It is nevertheless useful to understand, not least because you may
find it a useful strategy to adopt when implementing your own
language.  Therefore, alter the implementation to obey this strategy.
Do you still need store-passing style?  Why or why not?</p></blockquote></div></p><h4>8.2<tt>&nbsp;</tt><a name="(part._mut-vars)"></a>Variables</h4><p>Now that we&rsquo;ve got structure mutation worked out, let&rsquo;s consider the
other case: variable mutation.</p><h5>8.2.1<tt>&nbsp;</tt><a name="(part._.Terminology)"></a>Terminology</h5><p><div class="SIntrapara">First, our choice of terms.  We&rsquo;ve insisted on using the word
&ldquo;identifier&rdquo; before because we wanted to reserve &ldquo;variable&rdquo; for
what we&rsquo;re about to study.  In Java, when we say (assuming <span class="stt">x</span> is
locally bound, e.g., as a method parameter)
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">we&rsquo;re asking to <span style="font-style: italic">change</span> the value of <span class="stt">x</span>.  After the first
assignment, the value of <span class="stt">x</span> is <span class="stt">1</span>; after the second one,
it&rsquo;s <span class="stt">3</span>.  Thus, the value of <span class="stt">x</span> <span style="font-style: italic">varies</span> over the
course of the execution of the method.</div></p><p>Now, we also use the term &ldquo;variable&rdquo; in mathematics to refer to
function parameters.  For instance, in <span class="relax">\(f(y) = y+3\)</span> we say that
<span class="relax">\(y\)</span> is a &ldquo;variable&rdquo;.  That is called a variable because it varies
<span style="font-style: italic">across invocations</span>; however, <span style="font-style: italic">within</span> each invocation, it
has the same value in its scope.  Our identifiers until now have
corresponded to this notion of a variable.<span class="refelem"><span class="refcolumn"><span class="refcontent">If the
identifier was bound to a box, then it remained bound to the same box
value.  It&rsquo;s the content of the box that changed, not which box the
identifier was bound to.</span></span></span>
In contrast, programming variables can vary even <span style="font-style: italic">within</span> each
invocation, like the Java <span class="stt">x</span> above.</p><p>Henceforth, we will use <span style="font-style: italic">variable</span> when we mean an identifier
whose value can change within its scope, and <span style="font-style: italic">identifier</span> when
this cannot happen.  If in doubt, we might play it safe and use
&ldquo;variable&rdquo;; if the difference doesn&rsquo;t really matter, we might use
either one.  It is less important to get caught up in these specific
terms than to understand that they represent a distinction that
matters [REF].</p><h5>8.2.2<tt>&nbsp;</tt><a name="(part._.Syntax)"></a>Syntax</h5><p>Whereas other languages overload the mutation syntax (<span class="stt">=</span> or
<span class="stt">:=</span>), in Racket they are kept distinct: <span class="stt">set!</span> is used to
mutate variables.  This forces Racket programmers to confront the
distinction we introduced at the beginning of
<a href="" data-pltdoc="x">Mutation: Structures and Variables</a>.  We will, of course, sidestep these
syntactic issues in our core language by using different constructs
for boxes and for variables.</p><p><div class="SIntrapara">The first thing to note about variable mutation is that, although it
too has two sub-terms like box mutation (<span class="stt">setboxC</span>), its syntax
is fundamentally different.  To understand why, let&rsquo;s return to our
Java fragment:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In this setting, we cannot write an arbitrary expression in place of
<span class="stt">x</span>: we must literally write the name of the identifier itself.
That is because, if it were an expression position, then we could
evaluate it, yielding a value: for instance, if <span class="stt">x</span> were
previously bound to <span class="stt">1</span>, this would be tantamout to writing the
following statement:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">But this is, of course, nonsensical!  We can&rsquo;t assign a new value to
<span class="stt">1</span>, and indeed <span class="stt">1</span> is pretty much the definition of
immutable.  Thus, what we instead want is to find <span style="font-style: italic">where</span>
<span class="stt">x</span> is in the store, and change the value held over there.</div></p><p><div class="SIntrapara">Here&rsquo;s another way to see this.  Suppose the local variable <span class="stt">o</span>
were bound to some <span class="stt">String</span> object; let&rsquo;s call this object <span class="relax">\(s\)</span>.
Say we write
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">o</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta">String</span><span class="RktPn">(</span><span class="RktVal">"a</span><span class="hspace">&nbsp;</span><span class="RktVal">new</span><span class="hspace">&nbsp;</span><span class="RktVal">string"</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Are we trying to change <span class="relax">\(s\)</span> in any way?  Certainly not: this
statement intends to leave <span class="relax">\(s\)</span> alone.  It only wants to change the
value that <span class="stt">o</span> is referring to, so that subsequent references
evaluate to this new <span class="stt">string</span> object instead.</div></p><h5>8.2.3<tt>&nbsp;</tt><a name="(part._.Interpreting_.Variables)"></a>Interpreting Variables</h5><p><div class="SIntrapara">We&rsquo;ll start by reflecting this in our syntax:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">varC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">s</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">appC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fun</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">plusC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">multC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">lamC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">body</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">setC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">var</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">seqC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">b1</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">b2</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Observe that we&rsquo;ve jettisoned the box operations, but kept sequencing
because it&rsquo;s handy around mutation.  Importantly, we&rsquo;ve now added the
<span class="stt">setC</span> case, and its first sub-term is not an expression but the
literal name of a variable.  We&rsquo;ve also renamed <span class="stt">idC</span> to
<span class="stt">varC</span>.</div></p><p><div class="SIntrapara">Because we&rsquo;ve gotten rid of boxes, we can also get rid of the special
box values.  When the only kind of mutation you have is variables, you
don&rsquo;t need new kinds of values.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Value</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">numV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">closV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">body</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Env</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>As you might imagine, to support variables we need the same
store-passing style that we&rsquo;ve seen before
(<a href="#%28part._store-passing-style%29" data-pltdoc="x">Interpreting Boxes</a>), and for the same reasons.  What
differs is in precisely how we use it.  Because sequencing is
interpreted in just the same way (observe that the code for it does
not depend on boxes versus variables), that leaves us just the
variable mutation case to handle.</p><p>First, we might as well evaluate the value expression and obtain the
updated store:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cset.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cset.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;setC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">setC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">sto</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v-val</span><span class="hspace">&nbsp;</span><span class="RktSym">s-val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3crest-of-set.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;rest-of-setC-case&gt;</a><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>What now?  Remember we just said that we don&rsquo;t want to fully evaluate
the variable, because that would just give the value it is bound to.
Instead, we want to know which memory location it corresponds to, and
update what is stored at that memory location; this <span style="font-style: italic">latter</span> part
is just the same thing we did when mutating boxes:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3crest-of-set.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3crest-of-set.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;rest-of-setC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">where</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lookup</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v*s</span><span class="hspace">&nbsp;</span><span class="RktSym">v-val</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">override-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cell</span><span class="hspace">&nbsp;</span><span class="RktSym">where</span><span class="hspace">&nbsp;</span><span class="RktSym">v-val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">s-val</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>The very interesting new pattern we have here is this.  When we added
boxes, in the <span class="stt">idC</span> case, we looked up an identifier in the
environment, and immediately fetched the value at that location from
the store; the composition yielded a value, just as it used to before
we added stores.  Now, however, we have a new pattern: looking up an
identifier in the environment <span style="font-style: italic">without</span> subsequently fetching its
value from the store.  The result of invoking just <span class="stt">lookup</span> is
traditionally called an <span style="font-style: italic">l-value</span>, for &ldquo;left-hand-side (of an
assignment) value&rdquo;.  This is a fancy way of saying &ldquo;memory address&rdquo;,
and stands in contast to the actual values that the store yields:
observe that it does not directly correspond to anything in
the type <span class="stt">Value</span>.</p><p>And we&rsquo;re done!  We did all the hard work when we implemented
store-passing style (and also in that application allocated new
locations for variables).</p><h4>8.3<tt>&nbsp;</tt><a name="(part._.The_.Design_of_.Stateful_.Language_.Operations)"></a>The Design of Stateful Language Operations</h4><p>Though most programming languages include one or both kinds of state
we have studied, their admission should not be regarded as a trivial
or foregone matter.  On the one hand, state brings some vital
benefits:</p><ul><li><p>State provides a form of <span style="font-style: italic">modularity</span>.  As our very
interpreter demonstrates, without explicit stateful operations, to
achieve the same effect:</p><ul><li><p>We would need to add explicit parameters and return values
that pass the equivalent of the store around.</p></li><li><p>These changes would have to be made to <span style="font-style: italic">all</span> procedures
that may be involved in a communication path between producers and
consumers of state.</p></li></ul><p>Thus, a different way to think of state in a programming language is
that it is an <span style="font-style: italic">implicit parameter already passed to and
returned from all procedures</span>, without imposing that burden on the
programmer.  This enables procedures to communicate &ldquo;at a
distance&rdquo; without all the intermediaries having to be aware of the
communication.</p></li><li><p>State makes it possible to construct dynamic, cyclic data
structures, or at least to do so in a relatively straightforward
manner (<a href="recursion.html" data-pltdoc="x">Recursion and Cycles: Procedures and Data</a>).</p></li><li><p>State gives procedures <span style="font-style: italic">memory</span>, such as <span class="stt">new-loc</span>
above.  If a procedure could not remember things for itself, the
callers would need to perform the remembering on its behalf,
employing the moral equivalent of store-passing.  This is not only
unwieldy, it creates the potential for a caller to interfere with
the memory for its own nefarious purposes (e.g., a caller might
purposely send back an old store, thereby obtaining a reference
already granted to some other party, through which it might launch a
correctness or security attack).</p></li></ul><p>On the other hand, state imposes real costs on programmers as well as
on programs that process programs (such as compilers).  One is
&ldquo;aliasing&rdquo;, which we discuss later [REF].  Another is &ldquo;referential
transparency&rdquo;, which too I hope to return to [REF].  Finally, we have
described above how state provides a form of modularity.  However,
this same description could be viewed as that of a back-channel of
communication that the intermediaries did not know and could not
monitor.  In some (especially security and distributed system)
settings, such back-channels can lead to collusion, and can hence be
extremely dangerous and undesirable.</p><p>Because there is no optimal answer, it is probably wise to include
mutation operators but to carefully delinate them.  In Standard ML,
for instance, there is no variable mutation, because it is considered
unnecessary.  Instead, the language has the equivalent of boxes
(called <span class="stt">ref</span>s).  One can easily simulate variables using boxes
(e.g., see <span class="stt">new-loc</span> and consider how it would be written with
variables instead), so no expressive power is lost, though it does
create more potential for aliasing than variables alone would have
([REF aliasing]) if the boxes are not used carefully.</p><p>In return, however, developers obtain expressive <span style="font-style: italic">types</span>: every
data structure is considered immutable unless it contains a
<span class="stt">ref</span>, and the presence of a <span class="stt">ref</span> is a warning to both
developers and programs (such as compilers) that the underlying value
may keep changing.  Thus, for instance, if <span class="stt">b</span> is a box, a
developer should be aware that replacing all instances of <span class="stt">(unbox
b)</span> with <span class="stt">v</span>, where <span class="stt">v</span> is bound to <span class="stt">(unbox b)</span>, is
unwise: the former always fetches the <span style="font-style: italic">current</span> value in the box,
while the latter may be referring to an older content.  (Conversely,
if the developer wants the value at a certain point in time, oblivious
to future mutations to the box, they should be sure to retrieve and
bind it rather than always use <span class="stt">unbox</span>.)</p><h4>8.4<tt>&nbsp;</tt><a name="(part._.Parameter_.Passing)"></a>Parameter Passing</h4><p><div class="SIntrapara">In our current implementation, on every function call, we allocate a
fresh location in the store for the parameter.  This means the
following program
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">y</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">evaluates to <span class="stt">5</span>, not <span class="stt">3</span>.  That is because the value of the
formal parameter <span class="stt">x</span> is held at a different location than that of
the actual parameter <span class="stt">y</span>, so the mutation affects the location of
<span class="stt">x</span>, leaving <span class="stt">y</span> unscathed.</div></p><p>Now suppose, instead, that application behaved as follows.  When the
actual parameter is a variable, and hence has a location in memory,
instead of allocating a new location for the value, it simply passes
along the existing one for the variable.  Now the formal parameter is
referring to the <span style="font-style: italic">same store location</span> as the actual: i.e., they
are <span style="font-style: italic">variable aliases</span>.  Thus any mutation on the formal will leak
back out into the calling context; the above program would evaluate to
<span class="stt">3</span> rather than <span class="stt">5</span>.  These is called a
<span style="font-style: italic">call-by-reference</span> parameter-passing
strategy.<span class="refelem"><span class="refcolumn"><span class="refcontent">Instead, our interpreter implements
<span style="font-style: italic">call-by-value</span>, and this is the same strategy followed by
languages like Java.  This causes confusion because <span style="font-style: italic">when the
value is itself mutable</span>, changes made to the value in the callee are
observed by the caller.  However, that is simply an artifact of
mutable values, not of the calling strategy.  Please avoid this
confusion!</span></span></span></p><p>For some years, this power was considered a good idea.  It was useful
because programmers could write abstractions such as <span class="stt">swap</span>,
which swaps the <span style="font-style: italic">value of two variables</span> in the caller.  However,
the disadvantages greatly outweigh the advantages:</p><ul><li><p>A careless programmer can alias a variable in the caller and
modify it without realizing they have done so, and the caller may
not even realize this has happened until some obscure condition
triggers it.</p></li><li><p>Some people thought this was necessary for efficiency: they
assumed the alternative was to <span style="font-style: italic">copy</span> large data structures.
However, call-by-value is compatible with passing just the address
of the data structure.  You only need make a copy if (a) the data
structure is mutable, (b) you do not want the caller to be able to
mutate it, and (c) the language does not itself provide immutability
annotations or other mechanisms.</p></li><li><p>It can force non-uniform and hence non-modular reasoning.  For
  instance, suppose we have the procedure:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta">g</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">g</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>If the language were to permit by-reference parameter passing, then
  the programmer cannot locally&#8212;<wbr></wbr>i.e., just from the above
  code&#8212;<wbr></wbr>determine what the value of <span class="stt">x</span> will be in the
  ellipses.</p></li></ul><p>At the very least, then, if the language is going to permit
by-reference parameters, it should let the <span style="font-style: italic">caller</span> determine
whether to pass the reference&#8212;<wbr></wbr>i.e., let the callee share the memory
address of the caller&rsquo;s variable&#8212;<wbr></wbr>or not.  However, even this option
is not quite as attractive as it may sound, because now the callee
faces a symmetric problem, not knowing whether its parameters are
aliased or not.  In traditional, sequential programs this is less of a
concern, but if the procedure is <span style="font-style: italic">reentrant</span>, the callee faces
precisely the same predicaments.</p><p>At some point, therefore, we should consider whether any of this fuss
is worthwhile.  Instead, callers who want the callee to perform a
mutation could simply send a boxed value to the callee.  The box
signals that the caller accepts&#8212;<wbr></wbr>indeed, invites&#8212;<wbr></wbr>the callee to
perform a mutation, and the caller can extract the value when it&rsquo;s
done.  This does obviate the ability to write a simple swapper, but
that&rsquo;s a small price to pay for genuine software engineering concerns.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="higher-order-functions.html" title="backward to &quot;7 Functions Anywhere&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="recursion.html" title="forward to &quot;9 Recursion and Cycles: Procedures and Data&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>