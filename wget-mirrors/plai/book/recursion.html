<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>9&nbsp;Recursion and Cycles: Procedures and Data</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Introduction.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Everything__We_Will_Say__About_Parsing.html" class="tocviewlink" data-pltdoc="x">Everything (We Will Say) About Parsing</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="first-interp.html" class="tocviewlink" data-pltdoc="x">A First Look at Interpretation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="first-desugar.html" class="tocviewlink" data-pltdoc="x">A First Taste of Desugaring</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="adding-functions.html" class="tocviewlink" data-pltdoc="x">Adding Functions to the Language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="From_Substitution_to_Environments.html" class="tocviewlink" data-pltdoc="x">From Substitution to Environments</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="higher-order-functions.html" class="tocviewlink" data-pltdoc="x">Functions Anywhere</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="mut-struct-vs-var.html" class="tocviewlink" data-pltdoc="x">Mutation:<span class="mywbr"> &nbsp;</span> Structures and Variables</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Recursion and Cycles:<span class="mywbr"> &nbsp;</span> Procedures and Data</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Objects.html" class="tocviewlink" data-pltdoc="x">Objects</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Memory_Management.html" class="tocviewlink" data-pltdoc="x">Memory Management</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Representation_Decisions.html" class="tocviewlink" data-pltdoc="x">Representation Decisions</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Desugaring_as_a_Language_Feature.html" class="tocviewlink" data-pltdoc="x">Desugaring as a Language Feature</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Control_Operations.html" class="tocviewlink" data-pltdoc="x">Control Operations</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="types.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Statically:<span class="mywbr"> &nbsp;</span> Types</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="contracts.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Dynamically:<span class="mywbr"> &nbsp;</span> Contracts</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Alternate_Application_Semantics.html" class="tocviewlink" data-pltdoc="x">Alternate Application Semantics</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>9&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Recursion and Cycles:<span class="mywbr"> &nbsp;</span> Procedures and Data</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">9.1&nbsp;</td><td><a href="#%28part._.Recursive_and_.Cyclic_.Data%29" class="tocviewlink" data-pltdoc="x">Recursive and Cyclic Data</a></td></tr><tr><td align="right">9.2&nbsp;</td><td><a href="#%28part._rec-fun%29" class="tocviewlink" data-pltdoc="x">Recursive Functions</a></td></tr><tr><td align="right">9.3&nbsp;</td><td><a href="#%28part._.Premature_.Observation%29" class="tocviewlink" data-pltdoc="x">Premature Observation</a></td></tr><tr><td align="right">9.4&nbsp;</td><td><a href="#%28part._.Without_.Explicit_.State%29" class="tocviewlink" data-pltdoc="x">Without Explicit State</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">9.1<tt>&nbsp;</tt></span><a href="#%28part._.Recursive_and_.Cyclic_.Data%29" class="tocsubseclink" data-pltdoc="x">Recursive and Cyclic Data</a></td></tr><tr><td><span class="tocsublinknumber">9.2<tt>&nbsp;</tt></span><a href="#%28part._rec-fun%29" class="tocsubseclink" data-pltdoc="x">Recursive Functions</a></td></tr><tr><td><span class="tocsublinknumber">9.3<tt>&nbsp;</tt></span><a href="#%28part._.Premature_.Observation%29" class="tocsubseclink" data-pltdoc="x">Premature Observation</a></td></tr><tr><td><span class="tocsublinknumber">9.4<tt>&nbsp;</tt></span><a href="#%28part._.Without_.Explicit_.State%29" class="tocsubseclink" data-pltdoc="x">Without Explicit State</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="mut-struct-vs-var.html" title="backward to &quot;8 Mutation: Structures and Variables&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Objects.html" title="forward to &quot;10 Objects&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>9<tt>&nbsp;</tt><a name="(part._recursion)"></a>Recursion and Cycles: Procedures and Data</h3><p><span style="font-style: italic">Recursion</span> is the act of self-reference.  When we speak of
recursion in programming languages, we may have one of (at least) two
meanings in mind: recursion in data, and recursion in control (i.e.,
of program behavior&#8212;<wbr></wbr>that is to say, of functions).</p><h4>9.1<tt>&nbsp;</tt><a name="(part._.Recursive_and_.Cyclic_.Data)"></a>Recursive and Cyclic Data</h4><p>Recursion in data can refer to one of two things.  It can mean
referring to something of the same <span style="font-style: italic">kind</span>, or referring to the
same <span style="font-style: italic">thing</span> itself.</p><p>Recursion of the same kind leads to what we traditionally call
<span style="font-style: italic">recursive data</span>.  For instance, a tree is a recursive data
structure: each vertex can have multiple children, each of which is
itself a tree.  But if we write a procedure to traverse the nodes of a
tree, we expect it to terminate without having to keep track of which
nodes it has already visited.  They are finite data structures.</p><p>In contrast, a graph is often a <span style="font-style: italic">cyclic</span> datum: a node refers to
another node, which may refer back to the original one.  (Or, for that
matter, a node may refer directly to itself.)  When we traverse a
graph, absent any explicit checks for what we have already visited, we
should expect a computation to <span style="font-style: italic">diverge</span>, i.e., not terminate.
Instead, graph algorithms need a memory of what they have visited to
avoid repeating traversals.</p><p><div class="SIntrapara">Adding recursive data, such as lists and trees, to our language is
quite straightforward.  We mainly require two things:
</div><div class="SIntrapara"><ol><li><p>The ability to create compound structures (such as nodes that
have references to children).</p></li><li><p>The ability to bottom-out the recursion (such as leaves).</p></li></ol></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Add lists and binary trees as built-in datatypes to the programming
language.</p></blockquote></div></p><p>Adding cyclic data is more subtle.  Consider the simplest form of
cyclic datum, a cell referring back to itself:</p><blockquote class="SCentered"><p><img style="vertical-align: -1px; margin: -3px -3px -3px -3px;" src="pict.png" alt="image" width="108" height="108"/></p></blockquote><p><div class="SIntrapara">Let&rsquo;s try to define this in Racket.  Here&rsquo;s one attempt:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">But this doesn&rsquo;t work: <span class="stt">b</span> on the right-hand side of the
<span class="stt">let</span> isn&rsquo;t bound.  It&rsquo;s easy to see if we desugar it:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and, for clarity, we can rename the <span class="stt">b</span> in the function:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Now it&rsquo;s patently clear that <span class="stt">b</span> is unbound.</div></p><p>Absent some magical Racket construct we haven&rsquo;t yet
seen<span class="refelem"><span class="refcolumn"><span class="refcontent">That construct would be <span class="stt">shared</span>, but virtually
no other language has this notational mechanism, so we won&rsquo;t dwell on
it here.  In fact, what we are studying is the main idea behind how
<span class="stt">shared</span> actually works.</span></span></span>, it becomes clear that we can&rsquo;t create
a cyclic datum in one shot.  Instead, we need to first create a
&ldquo;place&rdquo; for the datum, then refer to that place within itself.  The
use of &ldquo;then&rdquo;&#8212;<wbr></wbr>i.e., the introduction of time&#8212;<wbr></wbr>should suggest a
mutation operation.  Indeed, let&rsquo;s try it with boxes.</p><p><div class="SIntrapara">Our plan is as follows.  First, we want to create a box and bind it to
some identifier, say <span class="stt">b</span>.  Now, we want to mutate the content of
the box.  What do we want it to contain?  A reference to itself.  How
does it obtain that reference?  By using the name, <span class="stt">b</span>, that is
already bound to it.  In this way, the mutation creates the cycle:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">dummy</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Note that this program will <span style="font-style: italic">not</span> run in Typed PLAI as written.
We&rsquo;ll return to typing such programs later [REF].  For now, run it in
the untyped (<span class="stt">#lang plai</span>) language.</div></p><p>When the above program is Run, Racket prints this as:
<span class="stt">#0=</span><span class="stt">&rsquo;</span><span class="stt">#&amp;#0#</span>.  This notation is in fact precisely what we want.
Recall that <span class="stt">#&amp;</span> is how Racket prints boxes.  The <span class="stt">#0=</span> (and
similarly for other numbers) is how Racket names pieces of cyclic
data.  Thus, Racket is saying, &ldquo;<span class="stt">#0</span> is bound to a box whose
content is <span class="stt">#0#</span>, i.e., whatever is bound to <span class="stt">#0</span>, i.e.,
itself&rdquo;.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Run the equivalent program through your interpreter for boxes and make
sure it produces a <span style="font-style: italic">cyclic</span> value.  How do you check this?</p></blockquote></div></p><p>The idea above generalizes to other datatypes.  In this same way we
can also produce cyclic lists, graphs, and so on.  The central idea is
this two-step process: first name an vacant placeholder; then mutate
the placeholder so its content is itself; to obtain &ldquo;itself&rdquo;, use
the name previously bound.  Of course, we need not be limited to
&ldquo;self-cycles&rdquo;: we can also have mutually-cyclic data (where no one
element is cyclic but their combination is).</p><h4>9.2<tt>&nbsp;</tt><a name="(part._rec-fun)"></a>Recursive Functions</h4><p>In a shift in terminology, a recursive function is not a reference to
a same <span style="font-style: italic">kind</span> of function but rather to the same function
<span style="font-style: italic">itself</span>.  It&rsquo;s useful to first ensure we&rsquo;ve first extended our
language with conditionals (even of the kind that only check for
<span class="stt">0</span>, as described earlier: <a href="adding-functions.html" data-pltdoc="x">Adding Functions to the Language</a>), so we
can write non-trivial programs that terminate.</p><p><div class="SIntrapara">Let&rsquo;s now try to write a recursive factorial:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">fact</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if0</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fact</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">-</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fact</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">But this doesn&rsquo;t work at all!  The inner <span class="stt">fact</span> gives an unbound
identifier error, just as in our cyclic datum example.</div></p><p>It is no surprise that we should encounter the same error, because it
has the same cause.  Our traditional binding mechanism does not
automatically make function definitions cyclic (indeed, in some early
programming languages, they were not: misguidedly, recursion was
considered a special <span style="font-style: italic">feature</span>).<span class="refelem"><span class="refcolumn"><span class="refcontent">Because you
typically write <span style="font-style: italic">top-level</span> definitions, you don&rsquo;t encounter this
issue.  At the top-level, every binding is implicitly a variable or a
box.  As a result, the pattern below is more-or-less automatically put
in place for you.  This is why, when you want a recursive local
binding, you must use <span class="stt">letrec</span> or <span class="stt">local</span>, not <span class="stt">let</span>.</span></span></span>
Instead, if we want
recursion&#8212;<wbr></wbr>i.e., for a function definition to cyclically refer to
itself&#8212;<wbr></wbr>we must implement it by hand.</p><p><div class="SIntrapara">The means to do so is now clear: the problem is the same one we
diagnosed before, so we can reuse the same solution.  We again have to
follow a three-step process: first create a placeholder, then refer to
the placeholder where we want the cyclic reference, and finally mutate
the placeholder before use.  Thus:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">fact</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">dummy</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">fact-fun</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">zero?</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">fact</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">-</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">fact</span><span class="hspace">&nbsp;</span><span class="RktMeta">fact-fun</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">fact</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In fact, we don&rsquo;t even need <span class="stt">fact-fun</span>: I&rsquo;ve used that binding
just for clarity.  Observe that because it isn&rsquo;t recursive, and we
have identifiers rather than variables, its use can simply be
substituted with its value:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">fact</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">dummy</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">fact</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">zero?</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">fact</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">-</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">unbox</span><span class="hspace">&nbsp;</span><span class="RktMeta">fact</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">There is the small nuisance of having to repeatedly unbox
<span class="stt">fact</span>.  In a language with variables, this would be even more
seamless:<span class="refelem"><span class="refcolumn"><span class="refcontent">Indeed, one use for variables is that they
simplify the desugaring of the above pattern, instead of requiring
every use of a cyclically-bound identifier to be unboxed.  On the
other hand, with a little extra effort the desugaring process could
take care of doing the unboxing, too.</span></span></span>
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">fact</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">dummy</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">fact</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">zero?</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fact</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">-</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fact</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><h4>9.3<tt>&nbsp;</tt><a name="(part._.Premature_.Observation)"></a>Premature Observation</h4><p><div class="SIntrapara">Our preceding discussion of this pattern shows a clear temporal
sequencing: create, update, use.  We can capture it in a desugaring
rule.  Suppose we add the following new syntax:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">rec</span><span class="hspace">&nbsp;</span><span class="RktMeta">name</span><span class="hspace">&nbsp;</span><span class="RktMeta">value</span><span class="hspace">&nbsp;</span><span class="RktMeta">body</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">As an example of its use,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">rec</span><span class="hspace">&nbsp;</span><span class="RktMeta">fact</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fact</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">-</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fact</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">would evaluate to the factorial of <span class="stt">10</span>.  This new syntax would
desugar to:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">name</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">box</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">dummy</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set-box!</span><span class="hspace">&nbsp;</span><span class="RktMeta">name</span><span class="hspace">&nbsp;</span><span class="RktMeta">value</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">body</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Where we assume that all references to <span class="stt">name</span> in <span class="stt">value</span> and
<span class="stt">body</span> have been rewritten to <span class="stt">(unbox name)</span>, or
alternatively that we instead use variables:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">name</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">dummy</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">name</span><span class="hspace">&nbsp;</span><span class="RktMeta">value</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">body</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>This naturally inspires a question: what if we get these out of order?
Most interestingly, what if we try to use <span class="stt">name</span>
before we&rsquo;re done updating its true value into place?
Then we observe the state of the system right after creation,
i.e., we can see the placeholder in its raw form.</p><p><div class="SIntrapara">The simplest example that demonstrates this is as follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">letrec</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">or equivalently,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">local</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In most Racket variants, this <span style="font-style: italic">leaks</span> the initial value given to
the placeholder&#8212;<wbr></wbr>a value that was never meant for public
consumption.  This is troubling because it is, after all, a legitimate
<span style="font-style: italic">value</span>, which means it can probably be used in at least some
computations.  If a developer accesses and uses it inadvertently,
however, they are effectively computing with nonsense.</div></p><p><div class="SIntrapara">There are generally three solutions to this problem:
</div><div class="SIntrapara"><ol><li><p>Make sure the value is sufficiently obscure so that it can
never be used in a meaningful context.  This means values like
<span class="stt">0</span> are especially bad, and indeed most common datatypes should
be shunned.  Instead, the language might create a new type of value
just for use here.  Passed to any other operation, this will result
in an error.</p></li><li><p>Explicitly check every use of an identifier for belonging to
this special &ldquo;premature&rdquo; value.  While this is technically
feasible, it imposes an enormous performance penalty on a program.
Thus, it is usually only employed in teaching languages.</p></li><li><p>Allow the recursion constructor to be used only in the case of
binding functions, and then make sure that the right-hand side of
the binding is <span style="font-style: italic">syntactically</span> a function.  Unfortunately, this
solution can be a bit drastic because it precludes writing, for
instance, structures to create graphs.</p></li></ol></div></p><h4>9.4<tt>&nbsp;</tt><a name="(part._.Without_.Explicit_.State)"></a>Without Explicit State</h4><p>As you may be aware, there is another way to define recursive
functions (and hence recursive data) that does not leverage explicit
mutation operations.</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>You&rsquo;ve already seen what goes wrong when we try to use just <span class="stt">let</span>
to define a recursive function.  Try harder.  Hint: Substitute more.
And then some more.  And more!</p></blockquote></div></p><p>Obtaining recursion from just functions is an amazing idea, and I use
the term literally.  It&rsquo;s written up
well by Daniel P. Friedman and Matthias Felleisen in their book,
<span style="font-style: italic">The Little Schemer</span>.  Read about it in
<a href="http://www.ccs.neu.edu/home/matthias/BTLS/sample.pdf">their sample chapter online</a>.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Does the above solution use state anywhere?  Implicitly?</p></blockquote></div></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="mut-struct-vs-var.html" title="backward to &quot;8 Mutation: Structures and Variables&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Objects.html" title="forward to &quot;10 Objects&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>