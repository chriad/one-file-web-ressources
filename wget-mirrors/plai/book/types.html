<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>15&nbsp;Checking Program Invariants Statically: Types</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Introduction.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Everything__We_Will_Say__About_Parsing.html" class="tocviewlink" data-pltdoc="x">Everything (We Will Say) About Parsing</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="first-interp.html" class="tocviewlink" data-pltdoc="x">A First Look at Interpretation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="first-desugar.html" class="tocviewlink" data-pltdoc="x">A First Taste of Desugaring</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="adding-functions.html" class="tocviewlink" data-pltdoc="x">Adding Functions to the Language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="From_Substitution_to_Environments.html" class="tocviewlink" data-pltdoc="x">From Substitution to Environments</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="higher-order-functions.html" class="tocviewlink" data-pltdoc="x">Functions Anywhere</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="mut-struct-vs-var.html" class="tocviewlink" data-pltdoc="x">Mutation:<span class="mywbr"> &nbsp;</span> Structures and Variables</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="recursion.html" class="tocviewlink" data-pltdoc="x">Recursion and Cycles:<span class="mywbr"> &nbsp;</span> Procedures and Data</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Objects.html" class="tocviewlink" data-pltdoc="x">Objects</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Memory_Management.html" class="tocviewlink" data-pltdoc="x">Memory Management</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Representation_Decisions.html" class="tocviewlink" data-pltdoc="x">Representation Decisions</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Desugaring_as_a_Language_Feature.html" class="tocviewlink" data-pltdoc="x">Desugaring as a Language Feature</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Control_Operations.html" class="tocviewlink" data-pltdoc="x">Control Operations</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Checking Program Invariants Statically:<span class="mywbr"> &nbsp;</span> Types</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="contracts.html" class="tocviewlink" data-pltdoc="x">Checking Program Invariants Dynamically:<span class="mywbr"> &nbsp;</span> Contracts</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Alternate_Application_Semantics.html" class="tocviewlink" data-pltdoc="x">Alternate Application Semantics</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>15&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Checking Program Invariants Statically:<span class="mywbr"> &nbsp;</span> Types</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">15.1&nbsp;</td><td><a href="#%28part._.Types_as_.Static_.Disciplines%29" class="tocviewlink" data-pltdoc="x">Types as Static Disciplines</a></td></tr><tr><td align="right">15.2&nbsp;</td><td><a href="#%28part._.A_.Classical_.View_of_.Types%29" class="tocviewlink" data-pltdoc="x">A Classical View of Types</a></td></tr><tr><td align="right">15.3&nbsp;</td><td><a href="#%28part._.Extensions_to_the_.Core%29" class="tocviewlink" data-pltdoc="x">Extensions to the Core</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">15.1<tt>&nbsp;</tt></span><a href="#%28part._.Types_as_.Static_.Disciplines%29" class="tocsubseclink" data-pltdoc="x">Types as Static Disciplines</a></td></tr><tr><td><span class="tocsublinknumber">15.2<tt>&nbsp;</tt></span><a href="#%28part._.A_.Classical_.View_of_.Types%29" class="tocsubseclink" data-pltdoc="x">A Classical View of Types</a></td></tr><tr><td><span class="tocsublinknumber">15.2.1<tt>&nbsp;</tt></span><a href="#%28part._.A_.Simple_.Type_.Checker%29" class="tocsubseclink" data-pltdoc="x">A Simple Type Checker</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctc-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-take-1&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctc-take-1-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-take-1-numC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctc-take-1-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-take-1-idC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctc-take-1-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-take-1-appC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctc~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctc-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-numC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctc-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-idC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctc-plus.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-plusC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctc-mult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-multC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctc-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-appC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctc-lam.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-lamC-case&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">15.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Type-.Checking_.Conditionals%29" class="tocsubseclink" data-pltdoc="x">Type-<wbr></wbr>Checking Conditionals</a></td></tr><tr><td><span class="tocsublinknumber">15.2.3<tt>&nbsp;</tt></span><a href="#%28part._.Recursion_in_.Code%29" class="tocsubseclink" data-pltdoc="x">Recursion in Code</a></td></tr><tr><td><span class="tocsublinknumber">15.2.3.1<tt>&nbsp;</tt></span><a href="#%28part._.A_.First_.Attempt_at_.Typing_.Recursion%29" class="tocsubseclink" data-pltdoc="x">A First Attempt at Typing Recursion</a></td></tr><tr><td><span class="tocsublinknumber">15.2.3.2<tt>&nbsp;</tt></span><a href="#%28part._.Program_.Termination%29" class="tocsubseclink" data-pltdoc="x">Program Termination</a></td></tr><tr><td><span class="tocsublinknumber">15.2.3.3<tt>&nbsp;</tt></span><a href="#%28part._.Typing_.Recursion%29" class="tocsubseclink" data-pltdoc="x">Typing Recursion</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3ctc-lam.C-case~3e~3a2%29%29" class="plainlink" data-pltdoc="x">&lt;tc-lamC-case&gt;<span style="vertical-align: sub; font-size: 80%">2</span></a></span></td></tr><tr><td><span class="tocsublinknumber">15.2.4<tt>&nbsp;</tt></span><a href="#%28part._.Recursion_in_.Data%29" class="tocsubseclink" data-pltdoc="x">Recursion in Data</a></td></tr><tr><td><span class="tocsublinknumber">15.2.4.1<tt>&nbsp;</tt></span><a href="#%28part._.Recursive_.Datatype_.Definitions%29" class="tocsubseclink" data-pltdoc="x">Recursive Datatype Definitions</a></td></tr><tr><td><span class="tocsublinknumber">15.2.4.2<tt>&nbsp;</tt></span><a href="#%28part._.Introduced_.Types%29" class="tocsubseclink" data-pltdoc="x">Introduced Types</a></td></tr><tr><td><span class="tocsublinknumber">15.2.4.3<tt>&nbsp;</tt></span><a href="#%28part._.Pattern-.Matching_and_.Desugaring%29" class="tocsubseclink" data-pltdoc="x">Pattern-<wbr></wbr>Matching and Desugaring</a></td></tr><tr><td><span class="tocsublinknumber">15.2.5<tt>&nbsp;</tt></span><a href="#%28part._.Types__.Time__and_.Space%29" class="tocsubseclink" data-pltdoc="x">Types, Time, and Space</a></td></tr><tr><td><span class="tocsublinknumber">15.2.6<tt>&nbsp;</tt></span><a href="#%28part._.Types_and_.Mutation%29" class="tocsubseclink" data-pltdoc="x">Types and Mutation</a></td></tr><tr><td><span class="tocsublinknumber">15.2.7<tt>&nbsp;</tt></span><a href="#%28part._.The_.Central_.Theorem__.Type_.Soundness%29" class="tocsubseclink" data-pltdoc="x">The Central Theorem:<span class="mywbr"> &nbsp;</span> Type Soundness</a></td></tr><tr><td><span class="tocsublinknumber">15.3<tt>&nbsp;</tt></span><a href="#%28part._.Extensions_to_the_.Core%29" class="tocsubseclink" data-pltdoc="x">Extensions to the Core</a></td></tr><tr><td><span class="tocsublinknumber">15.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Explicit_.Parametric_.Polymorphism%29" class="tocsubseclink" data-pltdoc="x">Explicit Parametric Polymorphism</a></td></tr><tr><td><span class="tocsublinknumber">15.3.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Parameterized_.Types%29" class="tocsubseclink" data-pltdoc="x">Parameterized Types</a></td></tr><tr><td><span class="tocsublinknumber">15.3.1.2<tt>&nbsp;</tt></span><a href="#%28part._.Making_.Parameters_.Explicit%29" class="tocsubseclink" data-pltdoc="x">Making Parameters Explicit</a></td></tr><tr><td><span class="tocsublinknumber">15.3.1.3<tt>&nbsp;</tt></span><a href="#%28part._.Rank-1_.Polymorphism%29" class="tocsubseclink" data-pltdoc="x">Rank-<wbr></wbr>1 Polymorphism</a></td></tr><tr><td><span class="tocsublinknumber">15.3.1.4<tt>&nbsp;</tt></span><a href="#%28part._.Interpreting_.Rank-1_.Polymorphism_as_.Desugaring%29" class="tocsubseclink" data-pltdoc="x">Interpreting Rank-<wbr></wbr>1 Polymorphism as Desugaring</a></td></tr><tr><td><span class="tocsublinknumber">15.3.1.5<tt>&nbsp;</tt></span><a href="#%28part._.Alternate_.Implementations%29" class="tocsubseclink" data-pltdoc="x">Alternate Implementations</a></td></tr><tr><td><span class="tocsublinknumber">15.3.1.6<tt>&nbsp;</tt></span><a href="#%28part._.Relational_.Parametricity%29" class="tocsubseclink" data-pltdoc="x">Relational Parametricity</a></td></tr><tr><td><span class="tocsublinknumber">15.3.2<tt>&nbsp;</tt></span><a href="#%28part._.Type_.Inference%29" class="tocsubseclink" data-pltdoc="x">Type Inference</a></td></tr><tr><td><span class="tocsublinknumber">15.3.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Constraint_.Generation%29" class="tocsubseclink" data-pltdoc="x">Constraint Generation</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cconstr-gen~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cconstr-gen-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-numC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cconstr-gen-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-idC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cconstr-gen-plus.C%2Fmult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-plusC/multC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cconstr-gen-lam.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-lamC-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cconstr-gen-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-appC-case&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">15.3.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Constraint_.Solving_.Using_.Unification%29" class="tocsubseclink" data-pltdoc="x">Constraint Solving Using Unification</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cunify%2F~ce~98~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cunify%2F~ce~98-t.Var-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;-tVar-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cunify%2F~ce~98-t.Exp-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;-tExp-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cunify%2F~ce~98-t.Num-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;-tNum-case&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cunify%2F~ce~98-t.Arrow-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;-tArrow-case&gt;</a></span></td></tr><tr><td><span class="tocsublinknumber">15.3.2.3<tt>&nbsp;</tt></span><a href="#%28part._.Let-.Polymorphism%29" class="tocsubseclink" data-pltdoc="x">Let-<wbr></wbr>Polymorphism</a></td></tr><tr><td><span class="tocsublinknumber">15.3.3<tt>&nbsp;</tt></span><a href="#%28part._.Union_.Types%29" class="tocsubseclink" data-pltdoc="x">Union Types</a></td></tr><tr><td><span class="tocsublinknumber">15.3.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Structures_as_.Types%29" class="tocsubseclink" data-pltdoc="x">Structures as Types</a></td></tr><tr><td><span class="tocsublinknumber">15.3.3.2<tt>&nbsp;</tt></span><a href="#%28part._.Untagged_.Unions%29" class="tocsubseclink" data-pltdoc="x">Untagged Unions</a></td></tr><tr><td><span class="tocsublinknumber">15.3.3.3<tt>&nbsp;</tt></span><a href="#%28part._.Discriminating_.Untagged_.Unions%29" class="tocsubseclink" data-pltdoc="x">Discriminating Untagged Unions</a></td></tr><tr><td><span class="tocsublinknumber">15.3.3.4<tt>&nbsp;</tt></span><a href="#%28part._.Retrofitting_.Types%29" class="tocsubseclink" data-pltdoc="x">Retrofitting Types</a></td></tr><tr><td><span class="tocsublinknumber">15.3.3.5<tt>&nbsp;</tt></span><a href="#%28part._.Design_.Choices%29" class="tocsubseclink" data-pltdoc="x">Design Choices</a></td></tr><tr><td><span class="tocsublinknumber">15.3.4<tt>&nbsp;</tt></span><a href="#%28part._.Nominal_.Versus_.Structural_.Systems%29" class="tocsubseclink" data-pltdoc="x">Nominal Versus Structural Systems</a></td></tr><tr><td><span class="tocsublinknumber">15.3.5<tt>&nbsp;</tt></span><a href="#%28part._.Intersection_.Types%29" class="tocsubseclink" data-pltdoc="x">Intersection Types</a></td></tr><tr><td><span class="tocsublinknumber">15.3.6<tt>&nbsp;</tt></span><a href="#%28part._.Recursive_.Types%29" class="tocsubseclink" data-pltdoc="x">Recursive Types</a></td></tr><tr><td><span class="tocsublinknumber">15.3.7<tt>&nbsp;</tt></span><a href="#%28part._.Subtyping%29" class="tocsubseclink" data-pltdoc="x">Subtyping</a></td></tr><tr><td><span class="tocsublinknumber">15.3.7.1<tt>&nbsp;</tt></span><a href="#%28part._.Unions%29" class="tocsubseclink" data-pltdoc="x">Unions</a></td></tr><tr><td><span class="tocsublinknumber">15.3.7.2<tt>&nbsp;</tt></span><a href="#%28part._.Intersections%29" class="tocsubseclink" data-pltdoc="x">Intersections</a></td></tr><tr><td><span class="tocsublinknumber">15.3.7.3<tt>&nbsp;</tt></span><a href="#%28part._.Functions%29" class="tocsubseclink" data-pltdoc="x">Functions</a></td></tr><tr><td><span class="tocsublinknumber">15.3.7.4<tt>&nbsp;</tt></span><a href="#%28part._.Implementing_.Subtyping%29" class="tocsubseclink" data-pltdoc="x">Implementing Subtyping</a></td></tr><tr><td><span class="tocsublinknumber">15.3.8<tt>&nbsp;</tt></span><a href="#%28part._.Object_.Types%29" class="tocsubseclink" data-pltdoc="x">Object Types</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Control_Operations.html" title="backward to &quot;14 Control Operations&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="contracts.html" title="forward to &quot;16 Checking Program Invariants Dynamically: Contracts&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>15<tt>&nbsp;</tt><a name="(part._types)"></a>Checking Program Invariants Statically: Types</h3><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Types_as_.Static_.Disciplines%29" class="toclink" data-pltdoc="x">15.1<span class="hspace">&nbsp;</span>Types as Static Disciplines</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.A_.Classical_.View_of_.Types%29" class="toclink" data-pltdoc="x">15.2<span class="hspace">&nbsp;</span>A Classical View of Types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.A_.Simple_.Type_.Checker%29" class="toclink" data-pltdoc="x">15.2.1<span class="hspace">&nbsp;</span>A Simple Type Checker</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Type-.Checking_.Conditionals%29" class="toclink" data-pltdoc="x">15.2.2<span class="hspace">&nbsp;</span>Type-Checking Conditionals</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Recursion_in_.Code%29" class="toclink" data-pltdoc="x">15.2.3<span class="hspace">&nbsp;</span>Recursion in Code</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.A_.First_.Attempt_at_.Typing_.Recursion%29" class="toclink" data-pltdoc="x">15.2.3.1<span class="hspace">&nbsp;</span>A First Attempt at Typing Recursion</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Program_.Termination%29" class="toclink" data-pltdoc="x">15.2.3.2<span class="hspace">&nbsp;</span>Program Termination</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Typing_.Recursion%29" class="toclink" data-pltdoc="x">15.2.3.3<span class="hspace">&nbsp;</span>Typing Recursion</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Recursion_in_.Data%29" class="toclink" data-pltdoc="x">15.2.4<span class="hspace">&nbsp;</span>Recursion in Data</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Recursive_.Datatype_.Definitions%29" class="toclink" data-pltdoc="x">15.2.4.1<span class="hspace">&nbsp;</span>Recursive Datatype Definitions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Introduced_.Types%29" class="toclink" data-pltdoc="x">15.2.4.2<span class="hspace">&nbsp;</span>Introduced Types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Pattern-.Matching_and_.Desugaring%29" class="toclink" data-pltdoc="x">15.2.4.3<span class="hspace">&nbsp;</span>Pattern-Matching and Desugaring</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Types__.Time__and_.Space%29" class="toclink" data-pltdoc="x">15.2.5<span class="hspace">&nbsp;</span>Types, Time, and Space</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Types_and_.Mutation%29" class="toclink" data-pltdoc="x">15.2.6<span class="hspace">&nbsp;</span>Types and Mutation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_.Central_.Theorem__.Type_.Soundness%29" class="toclink" data-pltdoc="x">15.2.7<span class="hspace">&nbsp;</span>The Central Theorem: Type Soundness</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Extensions_to_the_.Core%29" class="toclink" data-pltdoc="x">15.3<span class="hspace">&nbsp;</span>Extensions to the Core</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Explicit_.Parametric_.Polymorphism%29" class="toclink" data-pltdoc="x">15.3.1<span class="hspace">&nbsp;</span>Explicit Parametric Polymorphism</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Parameterized_.Types%29" class="toclink" data-pltdoc="x">15.3.1.1<span class="hspace">&nbsp;</span>Parameterized Types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Making_.Parameters_.Explicit%29" class="toclink" data-pltdoc="x">15.3.1.2<span class="hspace">&nbsp;</span>Making Parameters Explicit</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Rank-1_.Polymorphism%29" class="toclink" data-pltdoc="x">15.3.1.3<span class="hspace">&nbsp;</span>Rank-1 Polymorphism</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Interpreting_.Rank-1_.Polymorphism_as_.Desugaring%29" class="toclink" data-pltdoc="x">15.3.1.4<span class="hspace">&nbsp;</span>Interpreting Rank-1 Polymorphism as Desugaring</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Alternate_.Implementations%29" class="toclink" data-pltdoc="x">15.3.1.5<span class="hspace">&nbsp;</span>Alternate Implementations</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Relational_.Parametricity%29" class="toclink" data-pltdoc="x">15.3.1.6<span class="hspace">&nbsp;</span>Relational Parametricity</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Type_.Inference%29" class="toclink" data-pltdoc="x">15.3.2<span class="hspace">&nbsp;</span>Type Inference</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Constraint_.Generation%29" class="toclink" data-pltdoc="x">15.3.2.1<span class="hspace">&nbsp;</span>Constraint Generation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Constraint_.Solving_.Using_.Unification%29" class="toclink" data-pltdoc="x">15.3.2.2<span class="hspace">&nbsp;</span>Constraint Solving Using Unification</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Let-.Polymorphism%29" class="toclink" data-pltdoc="x">15.3.2.3<span class="hspace">&nbsp;</span>Let-Polymorphism</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Union_.Types%29" class="toclink" data-pltdoc="x">15.3.3<span class="hspace">&nbsp;</span>Union Types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Structures_as_.Types%29" class="toclink" data-pltdoc="x">15.3.3.1<span class="hspace">&nbsp;</span>Structures as Types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Untagged_.Unions%29" class="toclink" data-pltdoc="x">15.3.3.2<span class="hspace">&nbsp;</span>Untagged Unions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Discriminating_.Untagged_.Unions%29" class="toclink" data-pltdoc="x">15.3.3.3<span class="hspace">&nbsp;</span>Discriminating Untagged Unions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Retrofitting_.Types%29" class="toclink" data-pltdoc="x">15.3.3.4<span class="hspace">&nbsp;</span>Retrofitting Types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Design_.Choices%29" class="toclink" data-pltdoc="x">15.3.3.5<span class="hspace">&nbsp;</span>Design Choices</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Nominal_.Versus_.Structural_.Systems%29" class="toclink" data-pltdoc="x">15.3.4<span class="hspace">&nbsp;</span>Nominal Versus Structural Systems</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Intersection_.Types%29" class="toclink" data-pltdoc="x">15.3.5<span class="hspace">&nbsp;</span>Intersection Types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Recursive_.Types%29" class="toclink" data-pltdoc="x">15.3.6<span class="hspace">&nbsp;</span>Recursive Types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Subtyping%29" class="toclink" data-pltdoc="x">15.3.7<span class="hspace">&nbsp;</span>Subtyping</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Unions%29" class="toclink" data-pltdoc="x">15.3.7.1<span class="hspace">&nbsp;</span>Unions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Intersections%29" class="toclink" data-pltdoc="x">15.3.7.2<span class="hspace">&nbsp;</span>Intersections</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Functions%29" class="toclink" data-pltdoc="x">15.3.7.3<span class="hspace">&nbsp;</span>Functions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Implementing_.Subtyping%29" class="toclink" data-pltdoc="x">15.3.7.4<span class="hspace">&nbsp;</span>Implementing Subtyping</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Object_.Types%29" class="toclink" data-pltdoc="x">15.3.8<span class="hspace">&nbsp;</span>Object Types</a></p></td></tr></table><p>As programs grow larger or more subtle, developers need tools to help
them describe and validate statements about program <span style="font-style: italic">invariants</span>.
Invariants, as the name suggests, are statements about program
elements that are expected to always hold of those elements.  For
example, when we write <span class="stt">x : number</span> in our typed language, we
mean that <span class="stt">x</span> will always hold a <span class="stt">number</span>, and that all
parts of the program that depend on <span class="stt">x</span> can rely on this
statement being enforced.  As we will see, types are just one point in
a spectrum of invariants we might wish to state, and static type
checking&#8212;<wbr></wbr>itself a diverse family of techniques&#8212;<wbr></wbr>is also a point in
a spectrum of methods we can use to enforce the invariants.</p><h4>15.1<tt>&nbsp;</tt><a name="(part._.Types_as_.Static_.Disciplines)"></a>Types as Static Disciplines</h4><p>In this chapter, we will focus especially on <span style="font-style: italic">static type
checking</span>: that is, checking (declared) types before the program even
executes.  We have already experienced a form of this in our programs
by virtue of using a typed programming language.  We will explore some
of the design space of types and their trade-offs.  Finally, though
static typing is an especially powerful and important form of
invariant enforcement, we will also examine some other techniques that
we have available.</p><p><div class="SIntrapara">Consider this program in our typed language:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"x"</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">We get a static type error before the program begins execution.  The
same program (without the type annotations) in ordinary Racket fails
only at runtime:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"x"</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>How would you test the assertions that one fails before the program
executes while the other fails during execution?</p></blockquote></div></p><p>Now consider the following Racket program:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>This too fails before program execution begins, with a parse error.
Though we think of parsing as being somehow distinct from
type-checking&#8212;<wbr></wbr>usually because the type-checker assumes it has a
parsed program to begin with&#8212;<wbr></wbr>it can be useful to think of parsing as
being simply the very simplest kind of type-checking: determining
(typically) whether the program obeys a context-<span style="font-style: italic">free</span> syntax.
Type-checking then asks whether it obeys a context-<span style="font-style: italic">sensitive</span>
(or richer) syntax.  In short, type-checking is a generalization of
parsing, in that both are concerned with <span style="font-style: italic">syntactic</span> methods for
enforcing disciplines on programs.</p><h4>15.2<tt>&nbsp;</tt><a name="(part._.A_.Classical_.View_of_.Types)"></a>A Classical View of Types</h4><p>We will begin by introducing a traditional core language of types.
Later, we will explore both extensions [REF] and variations [REF].</p><h5>15.2.1<tt>&nbsp;</tt><a name="(part._.A_.Simple_.Type_.Checker)"></a>A Simple Type Checker</h5><p>Before we can define a type checker, we have to fix two things: the
syntax of our <span style="font-style: italic">typed</span> core language and, hand-in-hand with that,
the syntax of types themselves.</p><p>To begin with, we&rsquo;ll return to our language with functions-as-values
[REF] but before we added mutation and other complications (some of
which we&rsquo;ll return to later).  To this language we have to add type
annotations.  Conventionally, we don&rsquo;t impose type annotations on
constants or on primitive operations such as addition; instead, we
impose them on the boundaries of functions or methods.  Over the
course of this study we will explore why this is a good locus for
annotations.</p><p><div class="SIntrapara">Given this decision, our typed core language becomes:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">TyExprC</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">numC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">idC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">s</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">appC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fun</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">TyExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">TyExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">plusC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">TyExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">TyExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">multC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">TyExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">TyExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">lamC</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">argT</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Type</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">retT</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Type</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">body</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">TyExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">That is, every procedure is annotated with the type of argument it
expects and type of argument it purports to produce.</div></p><p><div class="SIntrapara">Now we have to decide on a language of types.  To do so, we follow the
tradition that the types <span style="font-style: italic">abstract over the set of values</span>.  In
our language, we have two kinds of values:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Value</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">numV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">closV</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">body</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">TyExprC</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">env</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Env</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">It follows that we should have two kinds of types: one for numbers and
the other for functions.</div></p><p>Even numeric types may not be straightforward: What information does a
number type need to record?  In most languages, there are actually
<span style="font-style: italic">many</span> numeric types, and indeed there may not even be a single
one that represents &ldquo;numbers&rdquo;.  However, we have ignored these
gradations between numbers [REF], so it&rsquo;s sufficient for us to have
just one.  Having decided that, do we record additional information
about <span style="font-style: italic">which</span> number?  We could in principle, but we would soon
run into decidability problems.</p><p><div class="SIntrapara">As for functions, we have more information: the type of expected
argument, and the type of claimed result.  We might as well record
this information we have been given until and unless it has proven to
not be useful.  Combining these, we obtain the following abstract
language of types:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Type</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">numT</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">funT</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">arg</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Type</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">ret</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Type</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Now that we&rsquo;ve fixed both the term and type structure of the language,
let&rsquo;s make sure we agree on what constitute type errors in our
language (and, by fiat, everything not a type error must pass the type
checker).  There are three obvious forms of type errors:
</div><div class="SIntrapara"><ul><li><p>One or both arguments of <span class="stt">+</span> is not a number, i.e., is
not a <span class="stt">numT</span>.</p></li><li><p>One or both arguments of <span class="stt">*</span> is not a number.</p></li><li><p>The expression in the function position of an application is
not a function, i.e., is not a <span class="stt">funT</span>.</p></li></ul></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Any more?</p></blockquote></div></p><p><div class="SIntrapara">We&rsquo;re actually missing one:
</div><div class="SIntrapara"><ul><li><p>The expression in the function position of an application is a
function but the type of the actual argument does not match the type
of the formal argument expected by the function.</p></li></ul></div><div class="SIntrapara">It seems clear all other programs in our language ought to type-check.</div></p><p>A natural starting signature for the type-checker would be that it is
a procedure that consumes an expression and returns a boolean value
indicating whether or not the expression type-checked.  Because we
know expressions contain identifiers, it soon becomes clear that we
will want a <span style="font-style: italic">type environment</span>, which maps names to types,
analogous to the value environment we have seen so far.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Define the types and functions associated with type environments.</p></blockquote></div></p><p>Thus, we might begin our program as follows:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctc-take-1~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctc-take-1~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-take-1&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tc</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">expr</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">TyExprC</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tenv</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">TyEnv</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">boolean</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">TyExprC</span><span class="hspace">&nbsp;</span><span class="RktSym">expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3ctc-take-1-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-take-1-numC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3ctc-take-1-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-take-1-idC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3ctc-take-1-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-take-1-appC-case&gt;</a><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>As the abbreviated set of cases above suggests, this approach will not
work out.  We&rsquo;ll soon see why.</p><p>Let&rsquo;s begin with the easy case: numbers.  Does a number type-check?
Well, on its own, of course it does; it may be that the surrounding
context is not expecting a number, but that error would be signaled
elsewhere.  Thus:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctc-take-1-num.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctc-take-1-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-take-1-numC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">numC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">true</span><span class="RktPn">]</span></p></blockquote></div></p><p>Now let&rsquo;s handle identifiers.  Is an identifier well-typed?  Again, on
its own it would appear to be, provided it is actually a bound
identifier; it may not be what the context desires, but hopefully that
too would be handled elsewhere.  Thus we might write</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctc-take-1-id.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctc-take-1-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-take-1-idC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">idC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lookup</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">tenv</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">true</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">tc</span><span class="hspace">&nbsp;</span><span class="RktVal">"not a bound identifier"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>This should make you a little uncomfortable: <span class="stt">lookup</span> already
signals an error if an identifier isn&rsquo;t bound, so there&rsquo;s no need to
repeat it (indeed, we will never get to this <span class="stt">error</span> invocation).
But let&rsquo;s push on.</p><p>Now we tackle applications.  We should type-check both the function
part, to make sure it&rsquo;s a function, then ensure that the actual
argument&rsquo;s type is consistent with what the function declares to be
the type of its formal argument.  For instance, the function could be
a number and the application could itself be a function, or vice
versa, and in either case we want to prevent such mis-applications.</p><p>How does the code look?</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctc-take-1-app.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctc-take-1-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-take-1-appC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">appC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">ft</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tc</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>The recursive call to <span class="stt">tc</span> can only tell us whether the function
expression type-checks or not.  If it does, how do we know what type
it has?  If we have an immediate function, we could reach into its
syntax and pull out the argument (and return) types.  But if we have a
complex expression, we need some procedure that will <span style="font-style: italic">calculate</span>
the resulting type of that expression.  Of course, such a procedure
could only provide a type if the expression is well-typed; otherwise
it would not be able to provide a coherent answer.  In other words,
<span style="font-style: italic">our type &ldquo;calculator&rdquo; has type &ldquo;checking&rdquo; as a special
case</span>!  We should therefore strengthen the inductive invariant on
<span class="stt">tc</span>: that it not only tells us whether an expression is typed
but also what its type is.  Indeed, by giving any type at all it
confirms that the expression types, and otherwise it signals an error.</p><p>Let&rsquo;s now define this richer notion of a type &ldquo;checker&rdquo;.</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctc~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctc~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tc</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">expr</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">TyExprC</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tenv</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">TyEnv</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Type</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">TyExprC</span><span class="hspace">&nbsp;</span><span class="RktSym">expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3ctc-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-numC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3ctc-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-idC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3ctc-plus.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-plusC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3ctc-mult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-multC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3ctc-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-appC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3ctc-lam.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-lamC-case&gt;</a><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Now let&rsquo;s fill in the pieces.  Numbers are easy: they have the numeric
type.</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctc-num.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctc-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-numC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">numC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numT</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>Similarly, identifiers have whatever type the environment says they do
(and if they aren&rsquo;t bound, this signals an error).</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctc-id.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctc-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-idC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">idC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lookup</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>Observe, so far, the similarity to and difference from interpreting:
in the identifier case we did essentially the same thing (except we
returned a type rather than an actual value), whereas in the numeric
case we returned the abstract &ldquo;number&rdquo; rather than indicate which
specific number it was.</p><p>Let&rsquo;s now examine addition.  We must make sure both sub-expressions
have numeric type; only if they do will the overall expression
evaluate to a number itself.</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctc-plus.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctc-plus.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-plusC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">plusC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">lt</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tc</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">rt</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tc</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktSym">lt</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numT</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktSym">rt</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numT</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numT</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">tc</span><span class="hspace">&nbsp;</span><span class="RktVal">"+ not both numbers"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>We&rsquo;ve usually glossed over multiplication after considering addition,
but now it will be instructive to handle it explicitly:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctc-mult.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctc-mult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-multC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">multC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">lt</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tc</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">rt</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tc</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktSym">lt</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numT</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktSym">rt</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numT</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">numT</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">tc</span><span class="hspace">&nbsp;</span><span class="RktVal">"* not both numbers"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Did you see what&rsquo;s different?</p></blockquote></div></p><p>That&rsquo;s right: practically <span style="font-style: italic">nothing</span>!  (The <span class="stt">multC</span> instead
of <span class="stt">plusC</span> in the <span class="stt">type-case</span>, and the slightly different
error message, notwithstanding.)  That&rsquo;s because, from the perspective
of type-checking (in this type language), there is no difference
between addition and multiplication, or indeed between <span style="font-style: italic">any</span> two
functions that consume two numbers and return one.</p><p>Observe another difference between interpreting and type-checking.
Both care that the arguments be numbers.  The interpreter then returns
a precise sum or product, but the type-checker is indifferent to the
differences between them: therefore the expression that computes what
it returns (<span class="stt">(numT)</span>) is a constant, and the same constant in
both cases.</p><p>Finally, the two hard cases: application and funcions.  We&rsquo;ve already
discussed what application must do: compute the value of the function
and argument expressions; ensure the function expression has function
type; and check that the argument expression is of compatible type.
If all this holds up, then the type of the overall application is
whatever type the function body would return (because the value that
eventually returns at run-time is the result of evaluating the
function&rsquo;s body).</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctc-app.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctc-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-appC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">appC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">ft</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tc</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">at</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tc</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">not</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">funT?</span><span class="hspace">&nbsp;</span><span class="RktSym">ft</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">tc</span><span class="hspace">&nbsp;</span><span class="RktVal">"not a function"</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">not</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">funT-arg</span><span class="hspace">&nbsp;</span><span class="RktSym">ft</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">at</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">tc</span><span class="hspace">&nbsp;</span><span class="RktVal">"app arg mismatch"</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">else</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">funT-ret</span><span class="hspace">&nbsp;</span><span class="RktSym">ft</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>That leaves function definitions.  The function has a formal
parameter, which is presumably used in the body; unless this is bound
in the environment, the body most probably will not type-check
properly.  Thus we have to extend the type environment with the formal
name bound to its type, and in that extended environment type-check
the body.  Whatever value this computes must be the same as the
declared type of the body.  If that is so, then the function itself
has a function type from the type of the argument to the type of the
body.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Why do I say &ldquo;most probably&rdquo; above?</p></blockquote></div></p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctc-lam.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctc-lam.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-lamC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">lamC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">argT</span><span class="hspace">&nbsp;</span><span class="RktSym">retT</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tc</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-ty-env</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bind</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">argT</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">retT</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">funT</span><span class="hspace">&nbsp;</span><span class="RktSym">argT</span><span class="hspace">&nbsp;</span><span class="RktSym">retT</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">tc</span><span class="hspace">&nbsp;</span><span class="RktVal">"lam type mismatch"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>Observe another curious difference between the interpreter and
type-checker.  In the interpreter, application was responsible for
evaluating the argument expression, extending the environment, and
evaluating the body.  Here, the application case does check the
argument expression, but leaves the environment alone, and simply
returns the type of the body <span style="font-style: italic">without traversing it</span>.  Instead,
the body is actually traversed by the checker when checking a function
<span style="font-style: italic">definition</span>, so this is the point at which the environment
actually extends.</p><h5>15.2.2<tt>&nbsp;</tt><a name="(part._.Type-.Checking_.Conditionals)"></a>Type-Checking Conditionals</h5><p>Suppose we extend the above language with conditionals.  Even the
humble <span class="stt">if</span> introduces several design decisions.  We&rsquo;ll discuss
two here, and return to one of them later [REF].</p><ol><li><p>What should be the type of the test expression?  In some
languages it must evaluate to a boolean value, in which case we have
to enrich the type language to include booleans (which would
probably be a good idea anyway).  In other languages it can be any
value, and some values are considered &ldquo;truthy&rdquo; while others
&ldquo;falsy&rdquo;.</p></li><li><p>What should be the relationship between the then- and
else-branches?  In some languages they must be of the same type, so
that there is a single, unambiguous type for the overall expression
(which is that one type).  In other languages the two branches can
have distinct types, which greatly changes the design of the
type-language and -checker, but also of the nature of the
programming language itself.</p></li></ol><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Add booleans to the type language.  What does this entail at a
minimum, and what else might be expected in a typical language?</p></blockquote></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Add a type rule for conditionals, where the test expression is
expected to evaluate to a boolean and both then- and else-branches
must have the same type, which is the type of the overall expression.</p></blockquote></div></p><h5>15.2.3<tt>&nbsp;</tt><a name="(part._.Recursion_in_.Code)"></a>Recursion in Code</h5><p>Now that we&rsquo;ve obtained a basic programming language, let&rsquo;s add
recursion to it.  We saw earlier [REF] that this could be done easily
through desugaring.  It&rsquo;ll prove to be a more complex story here.</p><h5>15.2.3.1<tt>&nbsp;</tt><a name="(part._.A_.First_.Attempt_at_.Typing_.Recursion)"></a>A First Attempt at Typing Recursion</h5><p><div class="SIntrapara">Let&rsquo;s now try to express a simple recursive function.  The simplest
is, of course, one that loops forever.  Can we write an infinite loop
with just functions?  We already could simply with
this program&#8212;<wbr></wbr>
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">&#8212;<wbr></wbr>which we know we can represent in our language with functions as
values.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Why does this construct an infinite loop?  What subtle dependency is
it making about the nature of function calls?</p></blockquote></div></p><p>Now that we have a typed language, and one that forces us to annotate
all functions, let&rsquo;s annotate it.  For simplicity, from now on we&rsquo;ll
assume we&rsquo;re writing programs in a typed surface syntax, and that
desugaring takes care of constructing core language terms.</p><p>Observe, first, that we have two identical terms being applied to each
other.  Historically, the overall term is called &#937; (capital omega in
Greek) and each of the identical sub-terms is called &#969; (lower-case
omega in Greek).  It is not a given that identical terms must have
precisely the same type, because it depends on what invariants we want
to assert of the context of use.  In this case, however, observe that
<span class="stt">x</span> binds to &#969;, so the second &#969; goes into both the first and
second positions.  As a result, typing one effectively types both.</p><p>Therefore, let&rsquo;s try to type &#969;; let&rsquo;s call this type &#947;.  It&rsquo;s
clearly a function type, and the function takes one argument, so it
must be of the form <span class="stt">&#966; -&gt; &#968;</span>.  Now what is that argument?  It&rsquo;s
&#969; itself. That is, the type of the value going into <span class="stt">&#966;</span> is
itself &#947;.  Thus,
the type of &#969; is &#947;, which is
<span class="stt">&#966; -&gt; &#968;</span>, which expands into
<span class="stt">(&#966; -&gt; &#968;) -&gt; &#968;</span>, which further expands to
<span class="stt">((&#966; -&gt; &#968;) -&gt; &#968;) -&gt; &#968;</span>, and so on.  In other words, this type
cannot be written as any finite string!</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Did you notice the subtle but important leap we just made?</p></blockquote></div></p><h5>15.2.3.2<tt>&nbsp;</tt><a name="(part._.Program_.Termination)"></a>Program Termination</h5><p>We observed that the obvious typing of &#937;, which entails typing &#947;,
seems to run into serious problems.  From that, however, we jumped to
the conclusion that this type cannot be written as any finite string,
for which we&rsquo;ve given only an intuition, not a proof.  In fact,
something even stranger is true: in the type system we&rsquo;ve defined so
far, <span style="font-style: italic">we cannot type &#937; at all</span>!</p><p>This is a strong statement, but we can actually say something much
stronger.  The <span style="font-style: italic">typed</span> language we have so far has a property
called <span style="font-style: italic">strong normalization</span>: every expression that has a type
will terminate computation after a finite number of steps.  In other
words, this special (and peculiar) infinite loop program isn&rsquo;t the
only one we can&rsquo;t type; we can&rsquo;t type <span style="font-style: italic">any</span> infinite loop (or
even potential infinite loop).  A rough intuition that might help is
that any type&#8212;<wbr></wbr>which must be a finite string&#8212;<wbr></wbr>can have only a finite
number of <span class="stt">-&gt;</span>&rsquo;s in it, and each application discharges one, so
we can perform only a finite number of applications.</p><p>If our language permitted only straight-line programs, this would be
unsurprising.  However, we have conditionals and even functions being
passed around as values, and with those we can encode any datatype we
want.  Yet, we still get this guarantee!  That makes this a somewhat
astonishing result.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Try to encode lists using functions in the untyped and then in the
typed language.  What do you see?  And what does that tell you about
the impact of this type system on the encoding?</p></blockquote></div></p><p>This result also says something deeper.  It shows that, contrary to
what you may believe&#8212;<wbr></wbr>that a type system only prevents a few buggy
programs from running&#8212;<wbr></wbr>a type system can <span style="font-style: italic">change the semantics</span>
of a language.  Whereas previously we could write an infinite loop in
just one to two lines, now we cannot write one at all.  It also shows
that the type system can establish invariants not just about a
particular program, but <span style="font-style: italic">about the language itself</span>.  If we want
to absolutely ensure that a program will terminate, we simply need to
write it in this language and pass the type checker, and the guarantee
is ours!</p><p>What possible use is a language in which all programs terminate?  For
general-purpose programming, none, of course.  But in many specialized
domains, it&rsquo;s a tremendously useful guarantee to have.  For instance,
suppose you are implementing a complex scheduling algorithm; you would
like to know that your scheduler is guaranteed to terminate so that
the tasks being scheduled will actually run.  There are many other
domains, too, where we would benefit from such a guarantee: a
packet-filter in a router; a real-time event processor; a device
initializer; a configuration file; the callbacks in single-threaded
JavaScript; and even a compiler or linker.  In each case, we have an
almost unstated expectation that these programs will always terminate.
And now we have a language that can offer this guarantee&#8212;<wbr></wbr>something
it is impossible to test for, no less!<span class="refelem"><span class="refcolumn"><span class="refcontent">These are not
hypothetical examples.  In the Standard ML language, the language for
linking modules uses essentially this typed language for writing
module linking specifications.  This means developers can write quite
sophisticated abstractions&#8212;<wbr></wbr>they have functions-as-values, after
all!&#8212;<wbr></wbr>while still being guaranteed that linking will always
terminate, producing a program.</span></span></span></p><h5>15.2.3.3<tt>&nbsp;</tt><a name="(part._.Typing_.Recursion)"></a>Typing Recursion</h5><p><div class="SIntrapara">What this says is, whereas before we were able to handle <span class="stt">rec</span>
entirely through desugaring, now we must make it an explicit part of
the typed language.  For simplicity, we will consider a special case
of <span class="stt">rec</span>&#8212;<wbr></wbr>which nevertheless covers the common uses&#8212;<wbr></wbr>whereby
the recursive identifier is bound to a function.  Thus, in the surface
syntax, one might write
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">rec</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">&#931;</span><span class="hspace">&nbsp;</span><span class="RktMeta">num</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">num</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if0</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">&#931;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">-1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">&#931;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">for a summation function, where <span class="stt">&#931;</span> is the name of the function,
<span class="stt">n</span> its argument, and <span class="stt">num</span> the type consumed by and
returned from the function.  The expression <span class="stt">(&#931; 10)</span> represents
the use of this function to sum the number from <span class="stt">10</span> until
<span class="stt">0</span>.</div></p><p>How do we type such an expression?  Clearly, we must have <span class="stt">n</span>
bound in the body of the function as we type it (but not of course, in
the use of the function); this much we know from typing functions.
But what about <span class="stt">&#931;</span>?  Obviously it must be bound in the type
environment when checking the use (<span class="stt">(&#931; 10)</span>), and its type must
be <span class="stt">num -&gt; num</span>.  But it must <span style="font-style: italic">also</span> be bound, to the same
type, when checking the body of the function.  (Observe, too, that the
type returned by the body must match its declared return type.)</p><p>Now we can see how to break the shackles of the finiteness of the
type.  It is certainly true that we can write only a finite number of
<span class="stt">-&gt;</span>&rsquo;s in types in the program source.  However, this rule for
typing recursion duplicates the <span class="stt">-&gt;</span> in the body that refers to
itself, thereby ensuring that there is an inexhaustible supply of
applications.  It&rsquo;s our infinite quiver of arrows.</p><p>The code to implement this rule would be as follows.  Assuming
<span class="stt">f</span> is bound to the function&rsquo;s name, <span class="stt">aT</span> is the function&rsquo;s
argument type and <span class="stt">rT</span> is its return type, <span class="stt">b</span> is the
function&rsquo;s body, and <span class="stt">u</span> is the function&rsquo;s use:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3ctc-lam.C-case~3e~3a2))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3ctc-lam.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;tc-lamC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">recC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">aT</span><span class="hspace">&nbsp;</span><span class="RktSym">rT</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktSym">u</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">extended-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-ty-env</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bind</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">funT</span><span class="hspace">&nbsp;</span><span class="RktSym">aT</span><span class="hspace">&nbsp;</span><span class="RktSym">rT</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">not</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktSym">rT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tc</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-ty-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bind</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">aT</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">extended-env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">tc</span><span class="hspace">&nbsp;</span><span class="RktVal">"body return type not correct"</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">else</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tc</span><span class="hspace">&nbsp;</span><span class="RktSym">u</span><span class="hspace">&nbsp;</span><span class="RktSym">extended-env</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><h5>15.2.4<tt>&nbsp;</tt><a name="(part._.Recursion_in_.Data)"></a>Recursion in Data</h5><p>We have seen how to type recursive programs, but this doesn&rsquo;t yet
enable us to create recursive data.  We already have one kind of
recursive datum&#8212;<wbr></wbr>the function type&#8212;<wbr></wbr>but this is built-in.  We
haven&rsquo;t yet seen how developers can create their own recursive
datatypes.</p><h5>15.2.4.1<tt>&nbsp;</tt><a name="(part._.Recursive_.Datatype_.Definitions)"></a>Recursive Datatype Definitions</h5><p><div class="SIntrapara">When we speak of allowing programmers to create recursive data, we are
actually talking about three different facilities at once:
</div><div class="SIntrapara"><ul><li><p>Creating a new type.</p></li><li><p>Letting instances of the new type have one or more fields.</p></li><li><p>Letting some of these fields refer to instances of the same
type.</p></li></ul></div><div class="SIntrapara">In fact, once we allow the third, we must allow one more:
</div><div class="SIntrapara"><ul><li><p>Allowing non-recursive base-cases for the type.</p></li></ul></div><div class="SIntrapara">This confluence of design criteria leads to what is commonly called an
<span style="font-style: italic">algebraic datatype</span>, such as the types supported by our typed
language.  For instance, consider the following definition of a binary
tree of numbers:<span class="refelem"><span class="refcolumn"><span class="refcontent">Later [REF], we will discuss how types
can be parameterized.</span></span></span>
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">BTmt</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">BTnd</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Observe that without a name for the new datatype, <span class="stt">BTnum</span>, we
would not have been able to refer back ot it in <span class="stt">BTnd</span>.
Similarly, without the ability to have more than one kind of
<span class="stt">BTnum</span>, we would not have been able to define <span class="stt">BTmt</span>, and
thus wouldn&rsquo;t have been able to terminate the recursion.  Finally, of
course, we need multiple fields (as in <span class="stt">BTnd</span>) to construct
useful and interesting data.  In other words, all three mechanisms are
packaged together because they are most useful in conjunction.
(However, some langauges do permit the definition of stand-alone
structures.  We will return to the impact of this design decision on
the type system later [REF].)</div></p><p>This concludes our initial presentation of recursive types, but it has
a fatal problem.  We have not actually explained where this new type,
<span class="stt">BTnum</span>, comes from.  That is because we have had to pretend it
is baked into our type-checker.  However, it is simply impractical to
keep changing our type-checker for each new recursive type
definition&#8212;<wbr></wbr>it would be like modifying our interpreter each time the
program contains a recursive function!  Instead, we need to find a way
to make such definitions intrinsic to the type language.  We will
return to this problem later [REF].</p><p>This style of data definition is sometimes also known as a
<span style="font-style: italic">sum of products</span>.  &ldquo;Product&rdquo; refers to the way fields combine
in one variant: for instance, the legal values of a <span class="stt">BTnd</span> are
the cross-product of legal values in each of the fields, supplied to
the <span class="stt">BTnd</span> constructor.  The &ldquo;sum&rdquo; is the aggregate of all
these variants: any given <span class="stt">BTnum</span> value is just one of these.
(Think of &ldquo;product&rdquo; as being &ldquo;and&rdquo;, and &ldquo;sum&rdquo; as being &ldquo;or&rdquo;.)</p><h5>15.2.4.2<tt>&nbsp;</tt><a name="(part._.Introduced_.Types)"></a>Introduced Types</h5><p><div class="SIntrapara">Now, what impact does a datatype definition have?  First, it
introduces a new type; then it uses this to define
several constructors, predicates, and selectors.  For instance, in the
above example, it first introduces <span class="stt">BTnum</span>, then uses it to
ascribe the following types:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">BTmt</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span></td></tr><tr><td><span class="RktMeta">BTnd</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span></td></tr><tr><td><span class="RktMeta">BTmt?</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">boolean</span></td></tr><tr><td><span class="RktMeta">BTnd?</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">boolean</span></td></tr><tr><td><span class="RktMeta">BTnd-n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span></td></tr><tr><td><span class="RktMeta">BTnd-l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span></td></tr><tr><td><span class="RktMeta">BTnd-r</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span></td></tr></table></blockquote></div><div class="SIntrapara">Observe a few salient facts:
</div><div class="SIntrapara"><ul><li><p>Both the constructors create instances of <span class="stt">BTnum</span>, not
something more refined.  We will discuss this design tradeoff later
[REF].</p></li><li><p>Both predicates consume values of type <span class="stt">BTnum</span>, not
&ldquo;any&rdquo;.  This is because the type system can already tell us what
type a value is.  Thus, we only need to distinguish between the
variants of that one type.</p></li><li><p>The selectors really only work on instances of the relevant
variant&#8212;<wbr></wbr>e.g., <span class="stt">BTnd-n</span> can work only on instances of
<span class="stt">BTnd</span>, not on instances of <span class="stt">BTmt</span>&#8212;<wbr></wbr>but we don&rsquo;t have a
way to express this in the static type system for lack of a suitable
static type.  Thus, applying these can only result in a dynamic
error, not a static one caught by the type system.</p></li></ul></div><div class="SIntrapara">There is more to say about recursive types, which we will return to
shortly [REF].</div></p><h5>15.2.4.3<tt>&nbsp;</tt><a name="(part._.Pattern-.Matching_and_.Desugaring)"></a>Pattern-Matching and Desugaring</h5><p><div class="SIntrapara">Once we observe that these are the types, the only thing left is to
provide an account of pattern-matching.  For instance, we can write
the expression
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">type-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">BTmt</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">e1</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">BTnd</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">nv</span><span class="hspace">&nbsp;</span><span class="RktMeta">lt</span><span class="hspace">&nbsp;</span><span class="RktMeta">rt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">e2</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">We have already seen [REF] that this can be written in terms of the
functions defined above.  We can simulate the binding done by this
pattern-matcher using <span class="stt">let</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">cond</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">BTmt?</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">e1</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">BTnd?</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">nv</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">BTnd-n</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">lt</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">BTnd-l</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">rt</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">BTnd-r</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">e2</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In short, this can be done by a macro, so pattern-matching does not
need to be in the core language and can instead be delegated to
desugaring.  This, in turn, means that one language can have many
different pattern-matching mechanisms.</div></p><p>Except, that&rsquo;s not quite true.  Somehow, the macro that generates the
code above in terms of <span class="stt">cond</span> needs to know that the three
positional selectors for a <span class="stt">BTnd</span> are <span class="stt">BTnd-n</span>,
<span class="stt">BTnd-l</span>, and <span class="stt">BTnd-r</span>, respectively.  This information is
explicit in the type definition but only implicitly present in the use
of the pattern-matcher (that, indeed, being the point).  Thus, somehow
this information must be communicated from definition to use.  Thus
the macro expander needs something akin to the type environment to
accomplish its task.</p><p>Observe, furthermore, that expressions such as <span class="stt">e1</span> and <span class="stt">e2</span>
cannot be type-checked&#8212;<wbr></wbr>indeed, cannot even be reliable identified as
<span style="font-style: italic">expressions</span>&#8212;<wbr></wbr>until macro expansion expands the use of
<span class="stt">type-case</span>.  Thus, expansion depends on the type environment,
while type-checking depends on the result of expansion.  In other
words, the two are symbiotic and need to happen, not quite in
&ldquo;parallel&rdquo;, but rather in lock-step.  Thus, building desugaring for
a typed language, where the syntactic sugar makes assumptions about
types, is a little more intricate than doing so for an untyped
language.</p><h5>15.2.5<tt>&nbsp;</tt><a name="(part._.Types__.Time__and_.Space)"></a>Types, Time, and Space</h5><p>It is evident that types already bestow a performance benefit in safe
languages.  That is because the checks that would have been performed
at run-time&#8212;<wbr></wbr>e.g., <span class="stt">+</span> checking that both its arguments are
indeed numbers&#8212;<wbr></wbr>are now performed statically.  In a typed language,
an annotation like <span class="stt">: number</span> already answers the question of
whether or not something is of a particular a type; there is nothing
to ask at run-time.  As a result, these type-level predicates can (and
need to) disappear entirely, and with them any need to use them in
programs.</p><p>This is at some cost to the developer, who must convince the static
type system that their program does not induce type errors; due to the
limitations of decidability, even programs that might have run without
error might run afoul of the type system.  Nevertheless, for programs
that meet this requirement, types provide a notable execution time
saving.</p><p>Now let&rsquo;s discuss space.  Until now, the language run-time system has
needed to store information attached to every value indicating what
its type is.  This is how it can implement type-level predicates such
as <span class="stt">number?</span>, which may be used both by developers and by
primitives.  If those predicates disappear, so does the space needed
to hold information to implement them.  Thus, type-tags are no longer
necessary.<span class="refelem"><span class="refcolumn"><span class="refcontent">They would, however, still be needed by the
garbage collector, though other representations such as BIBOP can
greatly reduce their space impact.</span></span></span></p><p><div class="SIntrapara">The type-like predicates still left are those for variants:
<span class="stt">BTmt?</span> and <span class="stt">BTnd?</span>, in the example above.  These must
indeed be applied at run-time.  For instance, as we have noted,
selectors like <span class="stt">BTnd-n</span> must perform this check.  Of course, some
more optimizations are possible.  Consider the code generated by
desugaring the pattern-matcher: there is no need for the three
selectors to implement this check, because control could only have
gotten to them after <span class="stt">BTnd?</span> returned a true vlaue.
Thus, the run-time system could provide just the desugaring
level access to special <span style="font-style: italic">unsafe</span> primitives that do not perform
the check, resulting in generated code such as this:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">cond</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">BTmt?</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">e1</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">BTnd?</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">nv</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">BTnd-n/no-check</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">lt</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">BTnd-l/no-check</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">rt</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">BTnd-r/no-check</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">e2</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>The net result, however, is that the run-time representation must
still store enough information to accurately answer these questions.
However, previously it needed to use enough bits to record every
possible type (and variant).  Now, because the types have been
statically segregated, for a type with no variants (e.g., there is
only one kind of string), there is no need to store any variant
information at all; that means the run-time system can use all
available bits to store actual dynamic values.</p><p>In contrast, when variants are present, the run-time system must
sacrifice bits to distinguish between the variants, but the number of
<span style="font-style: italic">variants within a type</span> is obviously far smaller than the number
of variants and types <span style="font-style: italic">across all types</span>.  In the <span class="stt">BTnum</span>
example above, there are only two variants, so the run-time system
needs to use only one bit to record which variant of <span class="stt">BTnum</span> a
value represents.</p><p>Observe, in particular, that the type system&rsquo;s segregation prevents
confusion.  If there are two different datatypes that each have two
variants, in the untyped world all these four variants require
distinct representations.  In contrast, in the typed world these
representations can overlap across types, because the static type
system will ensure one type&rsquo;s variants are never confused for that the
another.  Thus, types have a genuine space (saving representation) and
time (eliminating run-time checks) performance benefit for programs.</p><h5>15.2.6<tt>&nbsp;</tt><a name="(part._.Types_and_.Mutation)"></a>Types and Mutation</h5><p><div class="SIntrapara">We have now covered most of the basic features of our core language
other than mutation.  In some ways, types have a simple interaction
with mutation, and this is because in a classical setting, they don&rsquo;t
interact at all.  Consider, for instance, the following untyped
program:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">begin</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"something"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">What is &ldquo;the type&rdquo; of <span class="stt">x</span>?  It doesn&rsquo;t really have one: for some
time it&rsquo;s a number, and <span style="font-style: italic">later</span> (note the temporal word) it&rsquo;s a
string.  We simply can&rsquo;t give it a type.  In general, type checking is
an <span style="font-style: italic">atemporal</span> activity: it is done once, before the program
runs, and must hence be independent of the specific order in which
programs execute.  Keeping track of the precise values in the store is
hence beyond the reach of a type-checker.</div></p><p><div class="SIntrapara">The example above is, of course, easy to statically understand, but we
should never be mislead by simple examples.  Suppose instead we had a
program like
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">even?</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">read-number</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"Enter</span><span class="hspace">&nbsp;</span><span class="RktVal">a</span><span class="hspace">&nbsp;</span><span class="RktVal">number"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">set!</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"something"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Now it is literally impossible to reach any static conclusion about
the type of <span class="stt">x</span> after the conditional finishes, because only at
run-time can we know what the user might have entered.</div></p><p>To avoid this morass, traditional type checkers adopt a simple policy:
types must be <span style="font-style: italic">invariant</span> across mutation.  That is, a mutation
operation&#8212;<wbr></wbr>whether variable mutation or structure mutation&#8212;<wbr></wbr>cannot
change the type of the mutant.  Thus, the above examples would not
type in our type language so far.  How much flexibility this gives the
programmer is, however, a function of the type language.  For
instance, if we were to admit a more flexible type that stands for
&ldquo;number or string&rdquo;, then the examples above would type, but <span class="stt">x</span>
would always have this, less precise, type, and all uses of <span class="stt">x</span>
would have to contend with its reduced specificity, an issue we will
return to later [REF].</p><p>In short, mutation is easy to account for in a traditional type system
because its rule is simply that, while the value can change in ways
below the level of specificity of the type system, the type cannot
change.  In the case of an operation like <span class="stt">set!</span> (or our core
language&rsquo;s <span class="stt">setC</span>), this means the type of the assigned value
must match that of the variable.  In the case of structure mutation,
such as boxes, it means the assigned value must match that the box&rsquo;s
contained type.</p><h5>15.2.7<tt>&nbsp;</tt><a name="(part._.The_.Central_.Theorem__.Type_.Soundness)"></a>The Central Theorem: Type Soundness</h5><p>We have seen earlier [REF] that certain type languages can offer very
strong theorems about their programs: for instance, that all programs
in the language terminate.  In general, of course, we cannot obtain
such a guarantee (indeed, we added general recursion precisely to let
ourselves write unbounded loops).  However, a meaningful type
system&#8212;<wbr></wbr>indeed, anything to which we wish to bestow the noble title
of a <span style="font-style: italic">type system</span><span class="refelem"><span class="refcolumn"><span class="refcontent">We have repeatedly used the term
&ldquo;type <span style="font-style: italic">system</span>&rdquo;.  A type system is usually a combination of
three components: a language of types, a set of type rules, and an
algorithm that applies these rules to programs.  By largely presenting
our type rules embedded in a function, we have blurred the distinction
between the second and third of these, but can still be thought of as
intellectually distinct.</span></span></span>&#8212;<wbr></wbr>ought to provide some kind of meaningful
guarantee that all typed programs enjoy.  This is the payoff for the
programmer: by typing this program, she can be certain that certain
bad things will certainly not happen.  Short of this, we have just a
bug-finder; while it may be useful, it is not a sufficient basis for
building any higher-level tools (e.g., for obtaining security or
privacy or robustness guarantees).</p><p>What theorem might we want of a type system?  Remember that the type
checker runs over the static program, before execution.  In doing so,
it is essentially making a <span style="font-style: italic">prediction</span> about the program&rsquo;s
behavior: for instance, when it states that a particular complex term
has type <span class="stt">num</span>, it is effectively predicting that when run, that
term will produce a numeric value.  How do we know this prediction is
sound, i.e., that the type checker never lies?  Every type system
should be accompanied by a theorem that proves this.</p><p><div class="SIntrapara">There is a good reason to be suspicious of a type system, beyond
general skepticism.  There are many differences between the way a type
checker and a program evaluator work:
</div><div class="SIntrapara"><ul><li><p>The type checker only sees program text, whereas the evaluator
runs over actual stores.</p></li><li><p>The type environment binds identifiers to types, whereas the
evaluator&rsquo;s environment binds identifiers to values or locations.</p></li><li><p>The type checker compresses (even infinite) sets of values
into types, whereas the evaluator treats these distinctly.</p></li><li><p>The type checker always terminates, whereas the evaluator
might not.</p></li><li><p>The type checker passes over the body of each expression only
once, whereas the evaluator might pass over each body anywhere from
zero to infinite times.</p></li></ul></div><div class="SIntrapara">Thus, we should not assume that these will always correspond!</div></p><p>The central result we wish to have for a given type-system is called
<span style="font-style: italic">soundness</span>.  It says this.  Suppose we are given an expression
(or program) <span class="stt">e</span>.  We type-check it and conclude that its type is
<span class="stt">t</span>.  When we run <span class="stt">e</span>, let us say we obtain the value
<span class="stt">v</span>.  Then <span class="stt">v</span> will also have type <span class="stt">t</span>.</p><p>The standard way of proving this theorem is to prove it in two parts,
known as <span style="font-style: italic">progress</span> and <span style="font-style: italic">preservation</span>.  Progress says that if
a term passes the type-checker, it will be able to make a step of
evaluation (unless it is already a value); preservation says that the
result of this step will have the same type as the original.  If we
interleave these steps (first progress, then preservation; repeat), we
can conclude that the final answer will indeed have the same type as
the original, so the type system is indeed sound.</p><p>For instance, consider this expression: <span class="stt">(+ 5 (* 2 3))</span>.  It has
the type <span class="stt">num</span>.  In a sound type system, progress offers a proof
that, because this term types, and is not already a value, it can take
a step of execution&#8212;<wbr></wbr>which it clearly can.  After one step the
program reduces to <span class="stt">(+ 5 6)</span>.  Sure enough, as preservation
proves, this has the same type as the original: <span class="stt">num</span>.  Progress
again says this can take a step, producing <span class="stt">11</span>.  Preservation
again shows that this has the same type as the previous (intermediate)
expressions: <span class="stt">num</span>.  Now progress finds that we are at an answer,
so there are no steps left to be taken, and our answer is of the same
type as that given for the original expression.</p><p><div class="SIntrapara">However, this isn&rsquo;t the entire story.  There are two caveats:
</div><div class="SIntrapara"><ol><li><p>The program may not produce an answer at all; it might loop
forever.  In this case, the theorem strictly speaking does not
apply.  However, we can still observe that every intermediate term
still has the same type, so the program is computing meaningfully
even if it isn&rsquo;t producing a value.</p></li><li><p>Any rich enough language has properties that cannot be decided
statically (and others that perhaps could be, but the language
designer chose to put off until run-time).  When one of these
properties fails&#8212;<wbr></wbr>e.g., the array index being within bounds&#8212;<wbr></wbr>there
is no meaningful type for the program.  Thus, implicit in every type
soundness theorem is some set of published, permitted exceptions or
error conditions that may occur.  The developer who uses a type
system implicitly signs on to accepting this set.</p></li></ol></div><div class="SIntrapara">As an example of the latter set, the user of a typical typed language
acknowledges that vector dereference, list indexing, and so on may all
yield exceptions.</div></p><p>The latter caveat looks like a cop-out.  In fact, it is easy to forget
that it is really a statement about what <span style="font-style: italic">cannot</span> happen at
run-time: any exception not in this set will provably not be raised.
Of course, in languages designed with static types in the first place,
it is not clear (except by loose analogy) what these exceptions might
be, because there would be no need to define them.  But when we
retrofit a type system onto an existing programming
language&#8212;<wbr></wbr>especially languages with only dynamic enforcement, such as
Racket or Python&#8212;<wbr></wbr>then there is already a well-defined set of
exceptions, and the type-checker is explicitly stating that some set
of those exceptions (such as &ldquo;non-function found in application
position&rdquo; or &ldquo;method not found&rdquo;) will simply never occur.  This is
therefore the payoff that the programmer receives in return for
accepting the type system&rsquo;s syntactic restrictions.</p><h4>15.3<tt>&nbsp;</tt><a name="(part._.Extensions_to_the_.Core)"></a>Extensions to the Core</h4><p>Now that we have a basic typed language, let&rsquo;s explore how we can
extend it to obtain a more useful programming language.</p><h5>15.3.1<tt>&nbsp;</tt><a name="(part._.Explicit_.Parametric_.Polymorphism)"></a>Explicit Parametric Polymorphism</h5><p><div class="SIntrapara"><span style="font-weight: bold">Which of these is the same?</span></div><div class="SIntrapara"><blockquote><ul><li><p><span class="stt">List&lt;String&gt;</span></p></li><li><p><span class="stt">List&lt;String&gt;</span></p></li><li><p><span class="stt">(listof string)</span></p></li></ul></blockquote></div></p><p>Actually, none of these is quite the same.  But the first and third are
very alike, because the first is in Java and the third in our typed
language, whereas the second, in C++, is different.  All clear?  No?
Good, read on!</p><h5>15.3.1.1<tt>&nbsp;</tt><a name="(part._.Parameterized_.Types)"></a>Parameterized Types</h5><p><div class="SIntrapara">The language we have been programming in already demonstrates the
value of parametric polymorphism.  For instance, the type of
<span class="stt">map</span> is given as
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">which says that for all types <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a</span> and <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">b</span>, <span class="stt">map</span>
consumes a function that generates <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">b</span> values from <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a</span>
values, and a list of <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a</span> values, and generates the
corresponding list of <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">b</span> values.  Here, <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a</span> and <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">b</span>
are not concrete types; rather, they are <span style="font-style: italic">type variables</span> (in our
terminology, these should properly be called &ldquo;type identifiers&rdquo;
because they don&rsquo;t change within the course of an instantiation;
however, we will stick to the traditional terminology).</div></p><p><div class="SIntrapara">A different way to understand this is that there is actually an
infinite family of <span class="stt">map</span> functions.  For instance, there is a
<span class="stt">map</span> that has this type:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and another one of this type (nothing says the types have to be base types):
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and yet another one of this type (nothing says <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a</span> and <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">b</span>
can&rsquo;t be the same):
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">string</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and so on.  Because they have different types, they would need
different names: <span class="stt">map_num_str</span>, <span class="stt">map_num_num-&gt;num</span>,
<span class="stt">map_str_str</span>, and so on.  But that would make them different
functions, so we&rsquo;d have to always refer to a specific <span class="stt">map</span>
rather than each of the generic ones.</div></p><p>Obviously, it is impossible to load all these functions into our
standard library: there&rsquo;s an infinite number of these!  We&rsquo;d rather
have a way to obtain each of these functions on demand.  Our naming
convention offers a hint: it is as if <span class="stt">map</span> takes two
<span style="font-style: italic">parameters</span>, which are <span style="font-style: italic">types</span>.  Given the pair of types as
arguments, we can then obtain a <span class="stt">map</span> that is customized to that
particular type.  This kind of <span style="font-style: italic">parameterization over types</span> is
called <span style="font-style: italic">parametric polymorphism</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">Not to be confused
with the &ldquo;polymorphism&rdquo; of objects, which we will discuss below
[REF].</span></span></span></p><h5>15.3.1.2<tt>&nbsp;</tt><a name="(part._.Making_.Parameters_.Explicit)"></a>Making Parameters Explicit</h5><p><div class="SIntrapara">In other words, we&rsquo;re effectively saying that <span class="stt">map</span> is actually a
function of perhaps four arguments, two of them types and two of them
actual values (a function and a list).  In a language with explicit
types, we might try to write
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">map</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">???</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">???</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">but this raises some questions.  First, what goes in place of the
<span class="stt">???</span>?  These are the types of <span class="stt">a</span> and <span class="stt">b</span>.  But if
<span class="stt">a</span> and <span class="stt">b</span> are themselves going to be replaced with
<span style="font-style: italic">types</span>, then what is the type of a type?  Second, do we really
want to be calling <span class="stt">map</span> with four arguments on every
instantiation?  Third, do we really mean to take the type parameters
first before any actual values?  The answers to these questions
actually lead to a very rich space of polymorphic type systems, most
of which we will <span style="font-style: italic">not</span> explore here.<span class="refelem"><span class="refcolumn"><span class="refcontent">I recommend
reading Pierce&rsquo;s <span style="font-style: italic">Types and Programming Languages</span> for a modern,
accessible introduction.</span></span></span></div></p><p>Observe that once we start parameterizing, more code than we expect
ends up being parameterized.  For instance, consider the type of the
humble <span class="stt">cons</span>.  Its type really is parametric over the type of
values in the list (even though it doesn&rsquo;t actually depend on those
values!&#8212;<wbr></wbr>more on that in a bit [REF]) so every use of <span class="stt">cons</span>
must be instantiated at the appropriate type.  For that matter, even
<span class="stt">empty</span> must be instantiated to create an empty list of the
correct type!  Of course, Java and C++ programmers are familiar with
this pain.</p><h5>15.3.1.3<tt>&nbsp;</tt><a name="(part._.Rank-1_.Polymorphism)"></a>Rank-1 Polymorphism</h5><p>Instead, we will limit ourselves to one particularly useful and
tractable point in this space, which is the type system of Standard
ML, of the typed language of this book, of earlier versions of
Haskell, roughly that of Java and C# with generics, and roughly that
obtained using templates in C++.  This language defines what is called
<span style="font-style: italic">predicative</span>, <span style="font-style: italic">rank-1</span>, or <span style="font-style: italic">prenex</span> polymorphism.  It
answers the above questions thus: nothing, no, and yes.  Let&rsquo;s explore
this below.</p><p><div class="SIntrapara">We first divide the world of types into two groups.  The first group
consists of the type language we&rsquo;ve used until, but extended to
include type variables; these are called <span style="font-style: italic">monotypes</span>.  The second
group, known as <span style="font-style: italic">polytypes</span>, consists of parameterized types;
these are conventionally written with a &#8704; prefix, a list of type
variables, and then a type expression that might use these variables.
Thus, the type of <span class="stt">map</span> would be:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">&#8704;</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktMeta">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Since &ldquo;&#8704;&rdquo; is the logic symbol for &ldquo;for all&rdquo;, you would read this
as: &ldquo;for all types <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a</span> and <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">b</span>, the type of <span class="stt">map</span>
is...&rdquo;.</div></p><p>In rank-1 polymorphism, the type variables can only be substituted
with monotypes.  (Furthermore, these can only be concrete types,
because there would be nothing left to substitute any remaining type
variables.)  As a result, we obtain a clear separation between the
type variable-parameters and regular parameters.  We don&rsquo;t need to
provide a &ldquo;type annotation&rdquo; for the type variables because we know
precisely what kind of thing they can be.  This produces a relatively
clean language that still offers considerable expressive
power.<span class="refelem"><span class="refcolumn"><span class="refcontent"><span style="font-style: italic">Impredicative</span> languages erase the
distinction between monotypes and polytypes, so a type variable can be
instantiated with another polymorphic type.</span></span></span></p><p>Observe that because type variables can only be replaced with
monotypes, they are all independent of each other.  As a result, all
type parameters can be brought to the front of the parameter list.
This is what enables us to write types in the form
<span class="stt">&#8704; tv, ... : t</span> where the <span class="stt">tv</span> are type variables and
<span class="stt">t</span> is a monotype (that might refer to those variables).  This
justifies not only the syntax but also the name &ldquo;prenex&rdquo;.  It will
prove to also be useful in the implementation.</p><h5>15.3.1.4<tt>&nbsp;</tt><a name="(part._.Interpreting_.Rank-1_.Polymorphism_as_.Desugaring)"></a>Interpreting Rank-1 Polymorphism as Desugaring</h5><p><div class="SIntrapara">The simplest implementation of this feature is to view it as a form of
desugaring: this is essentially the interpretation taken by C++.  (Put
differently, because C++ has a macro system in the form of templates,
by a happy accident it obtains a form of rank-1 polymorphism through
the use of templates.)  For instance, imagine we had a new syntactic form,
<span class="stt">define-poly</span>, which takes a name, a type variable, and a body.
On every provision of a type to the name, it replaces the type
variable with the given type in the body.  Thus:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-poly</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">defines an identity function by first defining <span class="stt">id</span> to be
polymorphic: given a concrete type for <span class="stt">t</span>, it yields a procedure
of one argument of type <span class="stt">(t -&gt; t)</span> (where <span class="stt">t</span> is
appropriately substituted).  Thus we can instantiate <span class="stt">id</span> at many
different types&#8212;<wbr></wbr>
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">id_num</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">id_str</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">&#8212;<wbr></wbr>thereby obtaining identity functions at each of those types:
<span class="stt">(test (id_num 5) 5)
(test (id_str "x") "x")</span>
In contrast, expressions like
<span class="stt">(id_num "x")
(id_str 5)</span>
will, as we would expect, <span style="font-style: italic">fail to type-check</span> (rather than fail
at run-time).</div></p><p><div class="SIntrapara">In case you&rsquo;re curious, here&rsquo;s the implementation.  For simplicity, we
assume there is only one type parameter; this is easy to generalize
using <span class="stt">...</span>.  We will not only define a macro for
<span class="stt">define-poly</span>, <span style="font-style: italic">it</span> will in turn define a macro:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta">define-poly</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">syntax-rules</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">_</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">name</span><span class="hspace">&nbsp;</span><span class="RktMeta">tyvar</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">body</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">name</span><span class="hspace">&nbsp;</span><span class="RktMeta">stx</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">syntax-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">stx</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">_</span><span class="hspace">&nbsp;</span><span class="RktMeta">type</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">with-syntax</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">tyvar</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktMeta">type</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#'</span><span class="RktMeta">body</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Thus, given a definition such as
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-poly</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">the language creates a <span style="font-style: italic">macro</span> named <span class="stt">id</span>: the part that
begins with <span class="stt">(define-syntax (name ...) ...)</span> (where, in this
example, <span class="stt">name</span> is <span class="stt">id</span>).  An instantiation of <span class="stt">id</span>,
such as <span class="stt">(id number)</span>, replaces <span class="stt">t</span> the type variable,
<span class="stt">tyvar</span>, with the given type.  To circumvent hygiene, we use
<span class="stt">with-syntax</span> to force all uses of the type variable
(<span class="stt">tyvar</span>) to actually be replaced with the given type.  Thus, in
effect,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">id_num</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">turns into
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">id_num</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>However, this approach has two important limitations.</p><ol><li><p><div class="SIntrapara">Let&rsquo;s try to define a recursive polymorphic function, such as
  <span class="stt">filter</span>.  Earlier we have said that we ought to instantiate
  every single polymorphic value (such as even <span class="stt">cons</span> and
  <span class="stt">empty</span>) with types, but to keep our code concise we&rsquo;ll rely on
  the fact that the underlying typed language already does this, and
  focus just on type parameters for <span class="stt">filter</span>.  Here&rsquo;s the code:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-poly</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">filter</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">t</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">boolean</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">cond</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">empty?</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">empty</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">cons?</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">cons</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">filter</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rest</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">filter</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rest</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Observe that at the recursive uses of <span class="stt">filter</span>, we must
  instantiate it with the appropriate type.</div></p><p><div class="SIntrapara">This is a perfectly good definition.  There&rsquo;s just one problem.
  When we try to use it&#8212;<wbr></wbr>e.g.,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta">filter_num</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">filter</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">DrRacket does not terminate.  Specifically, macro expansion does not
  terminate, because it is repeatedly trying to make new <span style="font-style: italic">copies
of the code of</span> <span class="stt">filter</span>.  If, in contrast, we write the
  function as follows, expansion terminates&#8212;<wbr></wbr>
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-poly</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">filter2</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">letrec</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">fltr</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">t</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">boolean</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">cond</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">empty?</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">empty</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">cons?</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">cons</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fltr</span><span class="hspace">&nbsp;</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rest</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">fltr</span><span class="hspace">&nbsp;</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rest</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">fltr</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">but this needlessly pushes pain onto the user.  Indeed, some
  template expanders will cache previous values of expansion and avoid
  re-generating code when given the same parameters.  (Racket cannot
  do this because, in general, the body of a macro can depend on
  mutable variables and values and even perform input-output, so
  Racket cannot guarantee that a given input will always generate the
  same output.)</div></p></li><li><p><div class="SIntrapara">Consider two instantiations of the identity function.  We
  cannot compare <span class="stt">id_num</span> and <span class="stt">id_str</span> because they are of
  different types, but even if they are of the same type, they are not
  <span class="stt">eq?</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">test</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">eq?</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This is because each use of <span class="stt">id</span> creates a new copy of the
  body.  Now even if the optimization we mentioned above were applied,
  so for the <span style="font-style: italic">same</span> type there is only one code body, there would
  still be different code bodies for different
  types<span class="refelem"><span class="refcolumn"><span class="refcontent">Indeed, C++ templates are notorious for creating
code bloat; this is one of the reasons.</span></span></span>&#8212;<wbr></wbr>but even this is
  unnecessary!  There&rsquo;s absolutely nothing in the body of <span class="stt">id</span>,
  for instance, that actually depends on the type of the argument.
  Indeed, the entire infinite family of <span class="stt">id</span> functions can share
  just one implementation.  The simple desugaring strategy fails to
  provide this.</div></p></li></ol><p>In other words, the desugaring based strategy, which is essentially an
implementation by substitution, has largely the same problems we saw
earlier with regards to substitution as an implementation of parameter
instantiation.  However, in other cases substitution also gives us a
ground truth for what we expect as the program&rsquo;s behavior.  The same
will be true with polymorphism, as we will soon see [REF].</p><p>Observe that one virtue to the desugaring strategy is that it does not
require our type checker to &ldquo;know&rdquo; about polymorphism.  Rather, the
core type language can continue to be monomorphic, and all the
(rank-1) polymorphism is handled entirely through expansion.  This
offers a cheap strategy for adding polymorphism to a language,
though&#8212;<wbr></wbr>as C++ shows&#8212;<wbr></wbr>it also introduces significant overheads.</p><p>Finally, though we have only focused on functions, the preceding
discussions applies equally well to data structures.</p><h5>15.3.1.5<tt>&nbsp;</tt><a name="(part._.Alternate_.Implementations)"></a>Alternate Implementations</h5><p>There are other implementation strategies that don&rsquo;t suffer from these
problems.  We won&rsquo;t go into them here, but the essence of at least
some of them is the &ldquo;caching&rdquo; approach we sketched above.  Because
we can be certain that, for a given set of type parameters, we will
always get the same typed body, we never need to instantiate a
polymorphic function at the same type twice.  This avoids the infinite
loop.  If we type-check the instantiated body once, we can avoid
checking at other instantiations of the same type (because the body
will not have changed).  Furthermore, we do not need to retain the
instantiated sources: once we have checked the expanded program, we
can dispose of the expanded terms and retain just one copy at
run-time.  This avoids all the problems discussed in the pure
desugaring strategy shown above, while retaining the benefits.</p><p>Actually, we are being a little too glib.  One of the benefits of
static types is that they enable us to pick more precise run-time
representations.  For instance, a static type can tell us whether we
have a 32-bit or 64-bit number, or for that matter a 32-bit value or a
1-bit value (effectively, a boolean).  A compiler can then generate
specialized code for each representation, taking advantage of how the
bits are laid out (for example, 32 booleans can be <span style="font-style: italic">packed</span> into a
single 32-bit word).  Thus, after type-checking at each used type, the
polymorphic instantiator may keep track of all the special types at
which a function or data structure was used, and provide this
information to the compiler for code-generation.  This will then
result in several copies of the function, none of which are <span class="stt">eq?</span>
with each other&#8212;<wbr></wbr>but for good reason and, because their operations
are truly different, rightly so.</p><h5>15.3.1.6<tt>&nbsp;</tt><a name="(part._.Relational_.Parametricity)"></a>Relational Parametricity</h5><p>There&rsquo;s one last detail we must address regarding polymorphism.</p><p>We earlier said that a function like <span class="stt">cons</span> doesn&rsquo;t depend on the
specific values of its arguments.  This is also true of <span class="stt">map</span>,
<span class="stt">filter</span>, and so on.  When <span class="stt">map</span> and <span class="stt">filter</span> want to
operate on individual elements, they take as a parameter another
function which in turn is responsible for making decisions about how
to treat the elements; <span class="stt">map</span> and <span class="stt">filter</span> themselves simply
obey their parameter functions.</p><p>One way to &ldquo;test&rdquo; whether this is true is to substitute some
different values in the argument list, and a correspondingly different
parameter function.  That is, imagine we have a relation between two
sets of values; we convert the list elements according to the
relation, and the parameter function as well.  The question is, will
the output from <span class="stt">map</span> and <span class="stt">filter</span> also be predictable by
the relation?  If, for some input, this was not true of the output of
<span class="stt">map</span>, then it must be that <span class="stt">map</span> inspected the actual
values and did something with that information.  But in fact this
won&rsquo;t happen for <span class="stt">map</span>, or indeed most of the standard
polymorphic functions.</p><p>Functions that obey this relational rule are called
<span style="font-style: italic">relationally parametric</span><span class="refelem"><span class="refcolumn"><span class="refcontent">Read Wadler&rsquo;s
<span style="font-style: italic">Theorems for Free!</span> and Reynolds&rsquo;s <span style="font-style: italic">Types, Abstraction and
Parametric Polymorphism</span>.</span></span></span>.  This is another very powerful property
that types give us, because they tell us there is a strong limit on
the kinds of operations such polymorphic functions can perform:
essentially, that they can drop, duplicate, and rearrange elements,
but not directly inspect and make decisions on them.</p><p>At first this sounds very impressive (and it is!), but on inspection
you might realize this doesn&rsquo;t square with your experience.  In Java,
for instance, a polymorphic method can still use <span class="stt">instanceof</span> to
check which particular kind of value it obtained at run-time, and
change its behavior accordingly.  Such a method would indeed not be
relationally parametric!<span class="refelem"><span class="refcolumn"><span class="refcontent">On the Web, you will often find
this property described as the inability of a function to inspect the
argument&#8212;<wbr></wbr>which is not quite right.</span></span></span>  Indeed, relational
parametricity can equally be viewed as a statement of the weakness of
the language: that it permits only a very limited set of operations.
(You could still inspect the type&#8212;<wbr></wbr>but not act upon what you learned,
which makes the inspection pointless.  Therefore, a run-time system
that wants to simulate relational parametricity would have to remove
operations like <span class="stt">instanceof</span> as well as various proxies to it:
for instance, adding <span class="stt">1</span> to a value and catching exceptions would
reveal whether the value is a number.)  Nevertheless, it is a very
elegant and surprising result, and shows the power of program
reasoning possible with rich type systems.</p><h5>15.3.2<tt>&nbsp;</tt><a name="(part._.Type_.Inference)"></a>Type Inference</h5><p><div class="SIntrapara">Writing polymorphic type instantiations everywhere can be an awfully
frustrating process, as users of many versions of Java and C++ can
attest.  Imagine if in our programs, every single time we wrote
<span class="stt">first</span> or <span class="stt">rest</span>, we had to also instantiate it at a type!
The reason we have been able to avoid this fate is because our
language implements <span style="font-style: italic">type inference</span>.  This is what enables us to
write the definition
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mapper</span><span class="hspace">&nbsp;</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">cond</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">empty?</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">empty</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">cons?</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">cons</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">first</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">mapper</span><span class="hspace">&nbsp;</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rest</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and have the programming environment <span style="font-style: italic">automatically</span> declare that
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; mapper</span></p></td></tr><tr><td><p><span class="stt">- (('a -&gt; 'b) (listof 'a) -&gt; (listof 'b))</span></p></td></tr></table></div><div class="SIntrapara">Not only is this the correct type, this is a very general type!  The
process of being able to derive such general types just from the
program structure feels almost magical.  Now let&rsquo;s look behind the
curtain.</div></p><p>First, let&rsquo;s understand what type inference is doing.  Some people
mistakenly think of languages with inference as having no type
declarations, with inference taking their place.  This is confused at
multiple levels.  For one thing, even in languages with inference,
programmers are free (and for documentation purposes, often
encouraged&#8212;<wbr></wbr>as you have been)<span class="refelem"><span class="refcolumn"><span class="refcontent">Sometimes, inference is
also undecidable and programmers have no choice but to declare some of
the types.  Finally, writing explicit annotations can greatly reduce
indecipherable error messages.</span></span></span>  to declare types.  Furthemore, in the
absence of such declarations, it is not quite clear what inference
actually <span style="font-style: italic">means</span>.</p><p>Instead, it is better to think of the underlying language as being
fully, explicitly typed&#8212;<wbr></wbr>just like the polymorphic language we have
just studied [REF].  We will simply say that we are free to leave the
type annotations after the <span class="stt">:</span>&rsquo;s blank, and assume some
programming environment feature will fill them in for us.  (And if we
can go that far, we can drop the <span class="stt">:</span>&rsquo;s and extra embellishments
as well, and let them all be inserted automatically.  Thus, inference
becomes simply a user convenience for alleviating the burden of
writing type annotations, but the language underneath is explicitly
typed.</p><p>How do we even think about what inference does?  Suppose we have an
expression (or program) <span class="stt">e</span>, written in an explicitly typed
language: i.e., <span class="stt">e</span> has type annotations everywhere they are
required.  Now suppose we erase all annotations in <span class="stt">e</span>, and use a
procedure <span class="stt">infer</span> to deduce them back.</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>What property do we expect of <span class="stt">infer</span>?</p></blockquote></div></p><p>We could demand many things of it.  One might be that it produces
precisely those annotations that <span class="stt">e</span> originally had.  This is
problematic for many reasons, not least that <span class="stt">e</span> might not even
type-check, in which case how could <span class="stt">infer</span> possibly know what
they were (and hence should be)?  This might strike you as a pedantic
trifle: after all, if <span class="stt">e</span> didn&rsquo;t type-check, how can erasing its
annotations and filling them back in make it do so?  Since neither
program type-checks, who cares?</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Is this reasoning correct?</p></blockquote></div></p><p><div class="SIntrapara">Suppose <span class="stt">e</span> is
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This procedure obviously fails to type-check.  But if we erase the
type annotations&#8212;<wbr></wbr>obtaining
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">&#8212;<wbr></wbr>we equally obviously obtain a typeable function!  Therefore, a more
reasonable demand might be that if the original <span class="stt">e</span> type-checks,
then so must the version with annotations replaced by inferred types.
This one-directional implication is useful in two ways:
</div><div class="SIntrapara"><ol><li><p>It does not say what must happen if <span class="stt">e</span> fails to
type-check, i.e., it does not preclude the type inference algorithm
we have, which makes the faultily-typed identity function above
typeable.</p></li><li><p>More importantly, it assures us that we lose nothing by
employing type inference: no program that was previously typeable
will now cease to be so.  That means we can focus on using explicit
annotations where we want to, but will not be forced to do
so.<span class="refelem"><span class="refcolumn"><span class="refcontent">Of course, this only holds if inference is
decidable.</span></span></span></p></li></ol></div><div class="SIntrapara">We might also expect that both versions type to the same type, but
that is not a given: the function
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">types to <span class="stt">(number -&gt; number)</span>, whereas applying inference to it
after erasing types yields a much more general type.  Therefore,
relating these types and giving a precise definition of type equality
is not trivial, though we will briefly return to this issue later
[REF].</div></p><p>With these preliminaries out of the way, we are now ready to delve
into the mechanics of type inference.  The most important thing to
note is that our simple, recursive-descent type-checking algorithm
[REF] will no longer work.  That was possible because we already had
annotations on all function boundaries, so we could descend into
function bodies carrying information about those annotations in the
type environment.  Sans these annotations, it is not clear how to
descend.</p><p>In fact, it is not clear that there is any particular direction that
makes more sense than another.  In a definition like <span class="stt">mapper</span>
above, each fragment of code influences the other.  For instance,
applying <span class="stt">empty?</span>, <span class="stt">cons?</span>, <span class="stt">first</span>, and <span class="stt">rest</span> to
<span class="stt">l</span> all point to its being a list.  But a list of what?  We can&rsquo;t
tell from any of those operations.  However, the fact that we apply
<span class="stt">f</span> to each (or indeed, any) <span class="stt">first</span> element means the list
members must be of a type that can be passed to <span class="stt">f</span>.  Similarly,
we know the output must be a list because of <span class="stt">cons</span> and
<span class="stt">empty</span>.  But what are its elements?  They must be the return
type of <span class="stt">f</span>.  Finally, note something very subtle: when the
argument list is empty, we return <span class="stt">empty</span>, not <span class="stt">l</span> (which we
know is bound to <span class="stt">empty</span> at that point).  Using the former leaves
the type of the return free to be any kind of list at all (constrained
only by what <span class="stt">f</span> returns); using the latter would force it to be
the same type as the argument list.</p><p>All this information is in the function.  But how do we extract it
systematically and in an algorithm that terminates and enjoys the
property we have stated above?  We do this in two steps.  First we
<span style="font-style: italic">generate constraints</span>, based on program terms, on what the types
must be.  Then we <span style="font-style: italic">solve constraints</span> to identify inconsistencies
and join together constraints spread across the function body.  Each
step is relatively simple, but the combination creates magic.</p><h5>15.3.2.1<tt>&nbsp;</tt><a name="(part._.Constraint_.Generation)"></a>Constraint Generation</h5><p>Our goal, ultimately, is to find a type to fill into every type
annotation position.  It will prove to be just as well to find a type
for every <span style="font-style: italic">expression</span>.  A moment&rsquo;s thought will show that this
is likely necessary anyway: for instance, how can we determine the
type to put on a function without knowing the type of its body?  It is
also sufficient, in that if every expression has had its type
calculated, this will include the ones that need annotations.</p><p>First, we must generate constraints to (later) solve.  Constraint
generation walks the program source, emitting appropriate constraints
on each expression, and returns this set of constraints.  It works by
recursive descent mainly for simplicity; it really computes a
<span style="font-style: italic">set</span> of constraints, so the order of traversal and generation
really does not matter in principle&#8212;<wbr></wbr>so we may as well pick recursive
descent, which is easy&#8212;<wbr></wbr>though for simplicity we will use a list to
represent this set.</p><p><div class="SIntrapara">What are constraints?  They are simply statements about the types of
expressions.  In addition, though the binding instances of variables
are not expressions, we must calculate their types too (because a
function requires both argument and return types).  In general, what
can we say about the type of an expression?
</div><div class="SIntrapara"><ol><li><p>That it is related to the type of some identifier.</p></li><li><p>That it is related to the type of some other expression.</p></li><li><p>That it is a number.</p></li><li><p>That it is a function, whose domain and range types are
presumably further constrained.</p></li></ol></div><div class="SIntrapara">Thus, we define the following two datatypes:</div></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Constraints</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">eqCon</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lhs</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Term</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rhs</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Term</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Term</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">tExp</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">e</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">ExprC</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">tVar</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">s</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">tNum</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">tArrow</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">dom</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Term</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rng</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Term</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Now we can define the process of generating constraints:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cconstr-gen~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cconstr-gen~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cg</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">listof</span><span class="hspace">&nbsp;</span><span class="RktSym">Constraints</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprC</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cconstr-gen-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-numC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cconstr-gen-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-idC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cconstr-gen-plus.C%2Fmult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-plusC/multC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cconstr-gen-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-appC-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cconstr-gen-lam.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-lamC-case&gt;</a><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>When the expression is a number, all we can say is that we expect the
type of the expression to be numeric:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cconstr-gen-num.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cconstr-gen-num.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-numC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">numC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">_</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eqCon</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tExp</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tNum</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>This might sound trivial, but what we don&rsquo;t know is what other
expectations are being made of this expression by those containing
it.  Thus, there is the possibility that some outer expression will
contradict the assertion that this expression&rsquo;s type must be numeric,
leading to a type error.</p><p>For an identifier, we simply say that the type of the expression is
whatever we expect to be the type of that identifier:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cconstr-gen-id.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cconstr-gen-id.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-idC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">[</span><span class="RktSym">idC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eqCon</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tExp</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tVar</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></p></blockquote></div></p><p>If the context limits its type, then this expression&rsquo;s type will
automatically be limited, and must then be consistent with what its
context expects of it.</p><p>Addition gives us our first look at a contextual constraint.  For an
addition expression, we must first make sure we generate (and return)
constraints in the two sub-expressions, which might be complex.  That
done, what do we expect?  That each of the sub-expressions be of
numeric type.  (If the form of one of the sub-expressions demands a
type that is not numeric, this will lead to a type error.)  Finally,
we assert that the entire expression&rsquo;s type is itself
numeric.<span class="refelem"><span class="refcolumn"><span class="refcontent"><span class="stt">append3</span> is just a three-argument version
of <span class="stt">append</span>.</span></span></span></p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cconstr-gen-plus.C/mult.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cconstr-gen-plus.C%2Fmult.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-plusC/multC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">plusC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">append3</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cg</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cg</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eqCon</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tExp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tNum</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eqCon</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tExp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tNum</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eqCon</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tExp</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tNum</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>The case for <span class="stt">multC</span> is identical other than the variant name.</p><p>Now we get to the other two interesting cases, function declaration
and application.  In both cases, we must remember to generate and
return constraints of the sub-expressions.</p><p>In a function definition, the type of the function is a function
(&ldquo;arrow&rdquo;) type, whose argument type is that of the formal parameter,
and whose return type is that of the body:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cconstr-gen-lam.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cconstr-gen-lam.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-lamC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">lamC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">append</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cg</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eqCon</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tExp</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tArrow</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tVar</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tExp</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>Finally, we have applications.  We cannot directly state a constraint
on the type of the application.  Rather, we can say that the function
in the application position must consume arguments of the actual
parameter expression&rsquo;s type, and return types of the application
expression&rsquo;s type:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cconstr-gen-app.C-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cconstr-gen-app.C-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;constr-gen-appC-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">appC</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">append3</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cg</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cg</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eqCon</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tExp</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tArrow</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tExp</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tExp</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>And that&rsquo;s it!  We have finished generating constraints; now we just
have to solve them.</p><h5>15.3.2.2<tt>&nbsp;</tt><a name="(part._.Constraint_.Solving_.Using_.Unification)"></a>Constraint Solving Using Unification</h5><p>The process used to solve constraints is known as <span style="font-style: italic">unification</span>.
A unifier is given a set of equations.  Each equation maps a variable
to a term, whose datatype is above.  Note one subtle point: we
actually have <span style="font-style: italic">two</span> kinds of variables.  Both <span class="stt">tvar</span> and
<span class="stt">tExp</span> are &ldquo;variables&rdquo;, the former evidently so but the latter
equally so because we need to solve for the types of these
expressions.  (An alternate formulation would introduce fresh type
variables for each expression, but we would still need a way to
identify which ones correspond to which expression, which <span class="stt">eq?</span>
on the expressions already does automatically.  Also, this would
generate far larger constraint sets, making visual inspection
daunting.)</p><p>For our purposes, the goal of unification is generate a
<span style="font-style: italic">substitution</span>, or mapping from variables to terms that do not
contain any variables.  This should sound familiar: we have a set of
simultaneous equations in which each variable is used linearly; such
equations are solved using <span style="font-style: italic">Gaussian elimination</span>.  In that
context, we know that we can end up with systems that are both under-
and over-constrained.  The same thing can happen here, as we will soon
see.</p><p>The unification algorithm works iteratively over the set of
constraints.  Because each constraint equation has two terms and each
term can be one of four kinds, there are essentially sixteen cases to
consider.  Fortunately, we can cover all sixteen with fewer actual
code cases.</p><p>The algorithm begins with the set of all constraints, and the empty
substitution.  Each constraint is considered once and removed from the
set, so in principle the termination argument should be utterly
simple, but it will prove to be only slightly more tricky in reality.
As constraints are disposed, the substitution set tends to grow.
When all constraints have been disposed, unification returns the final
substitution set.</p><p>For a given constraint, the unifier examines the left-hand-side of the
equation.  If it is a variable, it is now ripe for elimination.  The
unifier adds the variable&rsquo;s right-hand-side to the substitution and,
to truly eliminate it, replaces all occurrences of the variable in the
substitution with the this right-hand-side.  In practice this needs to
be implemented efficiently; for instance, using a mutational
representation of these variables can avoid having to
search-and-replace all occurrences.  However, in a setting where we
might need to backtrack (as we will, in the presence of unification
[REF]), the mutational implementation has its own disadvantages.</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Did you notice the subtle error above?</p></blockquote></div></p><p>The subtle error is this.  We said that the unifier <span style="font-style: italic">eliminates</span>
the variable by replacing all instances of it in the substitution.
However, that assumes that the right-hand-side does not contain any
instances of the same variable.  Otherwise we have a circular
definition, and it becomes impossible to perform this particular
substitution.  For this reason, unifiers include a <span style="font-style: italic">occurs check</span>:
a check for whether the same variable occurs on both sides and, if it
does, decline to unify.</p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>Construct a term whose constraints would trigger the occurs check.</p></blockquote></div></p><p>Do you remember &#969;?</p><p>Let us now consider the implementation of unification.  It is
traditional to denote the substitution by the Greek letter &#920;.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type-alias</span><span class="hspace">&nbsp;</span><span class="RktMeta">Subst</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">Substitution</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Substitution</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">sub</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">var</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Term</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">is</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Term</span><span class="RktPn">]</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unify</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">cs</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">Constraints</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Subst</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">unify/&#920;</span><span class="hspace">&nbsp;</span><span class="RktMeta">cs</span><span class="hspace">&nbsp;</span><span class="RktMeta">empty</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Let&rsquo;s get the easy parts out of the way:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cunify/~ce~98~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cunify%2F~ce~98~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">unify/&#920;</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">cs</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">listof</span><span class="hspace">&nbsp;</span><span class="RktSym">Constraints</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">&#920;</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Subst</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Subst</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">empty?</span><span class="hspace">&nbsp;</span><span class="RktSym">cs</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#920;</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cons?</span><span class="hspace">&nbsp;</span><span class="RktSym">cs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eqCon-lhs</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">first</span><span class="hspace">&nbsp;</span><span class="RktSym">cs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eqCon-rhs</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">first</span><span class="hspace">&nbsp;</span><span class="RktSym">cs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Term</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cunify%2F~ce~98-t.Var-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;-tVar-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cunify%2F~ce~98-t.Exp-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;-tExp-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cunify%2F~ce~98-t.Num-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;-tNum-case&gt;</a></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28elem._%28chunk._~3cunify%2F~ce~98-t.Arrow-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;-tArrow-case&gt;</a><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Now we&rsquo;re ready for the heart of unification.  We will depend on a
function, <span class="stt">extend+replace</span>, with this signature:
<span class="stt">(Term Term Subst -&gt; Subst)</span>.
We expect this to perform the occurs test and, if it fails (i.e.,
there is no circularity), extends the substituion and replaces all
existing instances of the first term with the second in the
substitution.  Similarly, we will assume the existence of
<span class="stt">lookup</span>:
<span class="stt">(Term subst -&gt; (optionof Term))</span></p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Define <span class="stt">extend+replace</span> and <span class="stt">lookup</span>.</p></blockquote></div></p><p>If the left-hand of a constraint equation is a variable, we first look
it up in the substitution.  If it is present, we replace the current
constraint with a new one; otherwise, we extend the substitution:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cunify/~ce~98-t.Var-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cunify%2F~ce~98-t.Var-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;-tVar-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tVar</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">optionof</span><span class="hspace">&nbsp;</span><span class="RktSym">Term</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lookup</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">&#920;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">some</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bound</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">unify/&#920;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eqCon</span><span class="hspace">&nbsp;</span><span class="RktSym">bound</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest</span><span class="hspace">&nbsp;</span><span class="RktSym">cs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#920;</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">none</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">unify/&#920;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest</span><span class="hspace">&nbsp;</span><span class="RktSym">cs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend+replace</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">&#920;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>The same logic applies when it is an expression designator:</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cunify/~ce~98-t.Exp-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cunify%2F~ce~98-t.Exp-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;-tExp-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tExp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">optionof</span><span class="hspace">&nbsp;</span><span class="RktSym">Term</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lookup</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">&#920;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">some</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bound</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">unify/&#920;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eqCon</span><span class="hspace">&nbsp;</span><span class="RktSym">bound</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest</span><span class="hspace">&nbsp;</span><span class="RktSym">cs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#920;</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">none</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">unify/&#920;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest</span><span class="hspace">&nbsp;</span><span class="RktSym">cs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend+replace</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">&#920;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">If it is a base type, such as a number, then we examine the right-hand
side.  There are four possibilities, for the four different kinds of
terms:
</div><div class="SIntrapara"><ul><li><p>If it is a number, then we have an equation that claims that
the type <span class="stt">num</span> is the same as the type <span class="stt">num</span>, which is
patently true.  We can therefore ignore this constraint&#8212;<wbr></wbr>because it
tells us nothing new&#8212;<wbr></wbr>and move on to the remainder.</p><p>You should, of course, question why such a constraint would have
come about in the first place.  Clearly, our constraint generator
did not generate such constraints.  However, a prior extension to
the current substitution might have resulted in this situation.
Indeed, in practice we will encounter several of these.</p></li><li><p>If it is a function type, then we clearly have a type error,
because numeric and function types are disjoint.  Again, we would
never have generated such a constraint directly, but it must have
resulted from a prior substitution.</p></li><li><p>It could have been one of the two variable kinds.  However, we
have carefully arranged our constraint generator to never put these
on the right-hand-side.  Furthermore, substitution will not
introduce them on the right-hand-side, either.  Therefore, these two
cases cannot occur.</p></li></ul></div><div class="SIntrapara">This results in the following code:</div></p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cunify/~ce~98-t.Num-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cunify%2F~ce~98-t.Num-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;-tNum-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tNum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Term</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tNum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">unify/&#920;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest</span><span class="hspace">&nbsp;</span><span class="RktSym">cs</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#920;</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">else</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">unify</span><span class="hspace">&nbsp;</span><span class="RktVal">"number and something else"</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>Finally, we left with function types.  Here the argument is almost
exactly the same as for numeric types.</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cunify/~ce~98-t.Arrow-case~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cunify%2F~ce~98-t.Arrow-case~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;unify/&#920;-tArrow-case&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktSym">tArrow</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">d</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Term</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">tArrow</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">d2</span><span class="hspace">&nbsp;</span><span class="RktSym">r2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">unify/&#920;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eqCon</span><span class="hspace">&nbsp;</span><span class="RktSym">d</span><span class="hspace">&nbsp;</span><span class="RktSym">d2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eqCon</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">r2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">cs</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#920;</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">else</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">unify</span><span class="hspace">&nbsp;</span><span class="RktVal">"arrow and something else"</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr></table></blockquote></div></p><p>Note that we do not always shrink the size of the constraint set, so a
simple argument does not suffice for proving termination.  Instead, we
must make an argument based on the size of the constraint set, and on
the size of the substitution (including the number of variables in it).</p><p>The algorithm above is very general in that it works for all sorts of
type terms, not only numbers and functions.  We have used numbers as a
stand-in for all form of base types; functions, similarly, stand for
all constructed types, such as <span class="stt">listof</span> and <span class="stt">vectorof</span>.</p><p>With this, we are done.  Unification produces a substitution.  We can
now traverse the substitution and find the types of all the
expressions in the program, then insert the type annotations
accordingly.  A theorem, which we will not prove here, dictates that
the success of the above process implies that the program would have
typed-checked, so we need not explicitly run the type-checker over this
program.</p><p>Observe, however, that the nature of a type error has now changed
dramatically.  Previously, we had a recursive-descent algorithm that
walked a expressions using a type environment.  The bindings in the
type environment were programmer-declared types, and could hence be
taken as (intended) authoritative <span style="font-style: italic">specifications</span> of types.  As a
result, any mismatch was blamed on the expressions, and reporting type
errors was simple (and easy to understand).  Here, however, a type
error is a <span style="font-style: italic">failure to notify</span>.  The unification failure is based
on events that occur at the confluence of two smart
algorithms&#8212;<wbr></wbr>constraint generation and unification&#8212;<wbr></wbr>and hence are not
necessarily comprehensible to the programmer.  In particular, the
equational nature of these constraints means that the location
reported for the error, and the location of the &ldquo;true&rdquo; error, could
be quite far apart.  As a result, producing better error messages
remains an active research area.<span class="refelem"><span class="refcolumn"><span class="refcontent">In practice the algorithm
will maintain metadata on which program source terms were involved and
probably on the history of unification, to be able to trace errors
back to the source program.</span></span></span></p><p>Finally, remember that the constraints may not precisely dictate the
type of all variables.  If the system of equations is
<span style="font-style: italic">over</span>-constrained, then we get clashes, resulting in type
errors.  If instead the system is <span style="font-style: italic">under</span>-constrained, that means
we don&rsquo;t have enough information to make definitive statements about
all expressions.  For instance, in the expression
<span class="stt">(lambda (x) x)</span>
we do not have enough constraints to indicate what the type of
<span class="stt">x</span>, and hence of the entire expression, must be.  This is not an
error; it simply means that <span class="stt">x</span> is free to be <span style="font-style: italic">any</span> type at
all.  In other words, its type is &ldquo;the type of <span class="stt">x</span> <span class="stt">-&gt;</span> the
type of <span class="stt">x</span>&rdquo; with no other constraints.  The types of these
underconstrained identifiers are presented as type variables, so the
above expression&rsquo;s type might be reported as <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a)</span>.</p><p>The unification algorithm actually has a wonderful property: it
automatically computes the <span style="font-style: italic">most general types</span> for an
expression, also known as <span style="font-style: italic">principal types</span>.  That is, any actual
type the expression can have can be obtained by instantiating the
inferred type variables with actual types.  This is a remarkable
result: in another example of computers beating humans, it says that
no human can generate a more general type than the above algorithm
can!</p><h5>15.3.2.3<tt>&nbsp;</tt><a name="(part._.Let-.Polymorphism)"></a>Let-Polymorphism</h5><p><div class="SIntrapara">Unfortunately, though these type variables are superficially similar
to the polymorphism we had earlier [REF], they are not.  Consider the
following program:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lambda</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta">true</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">6</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">If we write it with explicit type annotations, it type-checks:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta">boolean</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">true</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">id</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">6</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">However, if we use type inference, it does not!  That is because the
<span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a</span>&rsquo;s in the type of <span class="stt">id</span> unify either with <span class="stt">boolean</span>
or with <span class="stt">number</span>, depending on the order in which the constraints
are processed.  At that point <span class="stt">id</span> effectively becomes either a
<span class="stt">(boolean -&gt; boolean)</span> or <span class="stt">(number -&gt; number)</span> function.  At
the use of <span class="stt">id</span> of the other type, then, we get a type error!</div></p><p>The reason for this is because the types we have inferred through
unification are not actually <span style="font-style: italic">polymorphic</span>.  This is important to
remember: just because you type variables, you haven&rsquo;t seen
polymorphism!  The type variables could be unified at the next use, at
which point you end up with a mere monomorphic function.  Rather, true
polymorphism only obtains when you have true <span style="font-style: italic">instantiation</span> of
type variables.</p><p>In languages with true polymorphism, then, constraint generation and
unification are not enough.  Instead, languages like ML, Haskell, and
even our typed programming language, implement something colloquially
called <span style="font-style: italic">let-polymorphism</span>.  In this strategy, when a term with
type variables is bound in a lexical context, the type is
automatically promoted to be a quantified one.  At each use, the term
is effectively automatically instantiated.</p><p>There are many implementation strategies that will accomplish this.
The most naive (and unsatisfying) is to merely <span style="font-style: italic">copy the code</span> of
the bound identifier; thus, each use of <span class="stt">id</span> above gets its own
copy of <span class="stt">(lambda (x) x)</span>, so each gets its own type variables.
The first might get the type <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a)</span>, the second <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">b</span><span class="stt">
</span><span class="stt">-&gt; </span><span class="stt">&rsquo;</span><span class="stt">b)</span>, the third <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">c -&gt; </span><span class="stt">&rsquo;</span><span class="stt">c)</span>, and so on.  None of these type
variables clash, so we get the effect of polymorphism.  Obviously,
this not only increases program size, it also does not work in the
presence of recursion.  However, it gives us insight into a better
solution: instead of copying the code, why not just copy the
<span style="font-style: italic">type</span>?  Thus at each use, we create a renamed copy of the
inferred type: <span class="stt">id</span>&rsquo;s <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a)</span> becomes <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">b -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b)</span>
at the first use, and so on, thus achieving the same effect as copying
code but without its burdens.  Because all these strategies
effectively mimic copying code, however, they only work within a
lexical context.</p><h5>15.3.3<tt>&nbsp;</tt><a name="(part._.Union_.Types)"></a>Union Types</h5><p><div class="SIntrapara">Suppose we want to construct a list of zoo animals, of which there are
many kinds: armadillos, boa constrictors, and so on.  Currently, we
are forced to create a new datatype:
<span class="refelem"><span class="refcolumn"><span class="refcontent">&ldquo;In Texas, there ain&rsquo;t nothing in the middle of the
                road but a yellow line and dead armadillos.&rdquo;&#8212;<wbr></wbr>Jim Hightower</span></span></span>
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Animal</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">armadillo</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">alive?</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">boolean</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">boa</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">length</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and make a list of these: <span class="stt">(listof Animal)</span>.  The type
<span class="stt">Animal</span> therefore represents a &ldquo;union&rdquo; of <span class="stt">armadillo</span> and
<span class="stt">boa</span>, except the only way to construct such unions is to make a
new type every time: if we want to represent the union of animals and
plants, we need
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">LivingThings</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">animal</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Animal</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">plant</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">p</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Plant</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">so an actual animal is now one extra &ldquo;level&rdquo; deep.  These datatypes
are called <span style="font-style: italic">tagged unions</span> or <span style="font-style: italic">discriminated unions</span>, because
we must introduce explicit tags (or <span style="font-style: italic">discriminators</span>), such as
<span class="stt">animal</span> and <span class="stt">plant</span>, to tell them apart.  In turn, a
structure can only reside inside a datatype declaration; we have had
to create datatypes with just one variant, such as
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Constraints</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">eqCon</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">lhs</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Term</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">rhs</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Term</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">to hold the datatype, and everywhere we&rsquo;ve had to use the type
<span class="stt">Constraints</span> because <span class="stt">eqCon</span> is not itself a type, only a
variant that can be distinguished at run-time.</div></p><p>Either way, the point of a union type is to represent a disjunction,
or &ldquo;or&rdquo;.  A value&rsquo;s type is one of the types in the union.  A value
usually belongs to only one of the types in the union, though this is
a function of precisely how the union types are defined, whether there
are rules for normalizing them, and so on.</p><h5>15.3.3.1<tt>&nbsp;</tt><a name="(part._.Structures_as_.Types)"></a>Structures as Types</h5><p><div class="SIntrapara">A natural reaction to this might be, why not lift this restriction?
Why not allow each structure to exist on its own, and define a type to
be a union of some collection of structures?  After all, in languages
ranging from C to Racket, programmers can define stand-alone
structures without having to wrap them in some other type with a tag
constructor!  For instance, in raw Racket, we can write
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">struct</span><span class="hspace">&nbsp;</span><span class="RktMeta">armadillo</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">alive?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">struct</span><span class="hspace">&nbsp;</span><span class="RktMeta">boa</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">length</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and a comment that says
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">An</span><span class="hspace">&nbsp;</span><span class="RktCmt">Animal</span><span class="hspace">&nbsp;</span><span class="RktCmt">is</span><span class="hspace">&nbsp;</span><span class="RktCmt">either</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">-</span><span class="hspace">&nbsp;</span><span class="RktCmt">(armadillo</span><span class="hspace">&nbsp;</span><span class="RktCmt">&lt;boolean&gt;)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">-</span><span class="hspace">&nbsp;</span><span class="RktCmt">(boa</span><span class="hspace">&nbsp;</span><span class="RktCmt">&lt;number&gt;)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">but without enforced static types, the comparison is messy.  However,
we can more directly compare with <span style="font-style: italic">Typed Racket</span>, a typed form of
Racket that is built into DrRacket.  Here is the same typed code:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><a href="http://docs.racket-lang.org/ts-reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">typed/racket</span></a><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">struct:</span><span class="hspace">&nbsp;</span><span class="RktMeta">armadillo</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">alive?</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Boolean</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">struct:</span><span class="hspace">&nbsp;</span><span class="RktMeta">boa</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">length</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Real</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">feet</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">We can now define functions that consume values of type <span class="stt">boa</span>
without any reference to <span class="stt">armadillo</span>s:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">http://en.wikipedia.org/wiki/Boa_constrictor#Size_and_weight</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">big-one?</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">boa</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Boolean</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">boa-length</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">8</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In fact, if we apply this function to any other type, including an
armadillo&#8212;<wbr></wbr><span class="stt">(big-one? (armadillo true))</span>&#8212;<wbr></wbr>we get a
<span style="font-style: italic">static</span> error.  This is because armadillos are no more related
to boas than numbers or strings are.</div></p><p><div class="SIntrapara">Of course, we can still define a union of these types:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">Animal</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">armadillo</span><span class="hspace">&nbsp;</span><span class="RktMeta">boa</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and functions over it:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">safe-to-transport?</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Animal</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Boolean</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">cond</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">boa?</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">not</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">big-one?</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">armadillo?</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">armadillo-alive?</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Whereas before we had <span style="font-style: italic">one type with two variants</span>, now we have
<span style="font-style: italic">three types</span>.  It just so happens that two of the types form a
union of convenience to define a third.</div></p><h5>15.3.3.2<tt>&nbsp;</tt><a name="(part._.Untagged_.Unions)"></a>Untagged Unions</h5><p><div class="SIntrapara">It might appear that we still need to have discriminative tags, but we
don&rsquo;t.  In languages with union types, the effect of the
<span class="stt">optionof</span> type constructor is often obtained by combining the
intended return type with a disjoint one representing failure or
<span class="stt">none</span>ness.  For instance, here is the moral equivalent of
<span class="stt">(optionof number)</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">MaybeNumber</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">Number</span><span class="hspace">&nbsp;</span><span class="RktMeta">Boolean</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">For that matter, <span class="stt">Boolean</span> may itself be a union of <span class="stt">True</span>
and <span class="stt">False</span>, as it is in Typed Racket, so a more accurate
simulation of the option type would be:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">MaybeNumber</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">Number</span><span class="hspace">&nbsp;</span><span class="RktMeta">False</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">More generally, we could define
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">struct:</span><span class="hspace">&nbsp;</span><span class="RktMeta">none</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">Maybeof</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="hspace">&nbsp;</span><span class="RktMeta">none</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">which would work for all types, because <span class="stt">none</span> is a new, distinct
type that cannot be confused for any other.  This gives us the same
benefit as the <span class="stt">optionof</span> type, except the value we want is not
buried one level deep inside a <span class="stt">some</span> structure, but is rather
available immediately.  For instance, consider <span class="stt">member</span>, which
has this Typed Racket type:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">All</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">Listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">False</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">Listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">If the element is not found, <span class="stt">member</span> returns <span class="stt">false</span>.
Otherwise, it returns the list starting from the element onward (i.e.,
the first element of the list will be the desired element):
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (member 2 (list 1 2 3))</span></p></td></tr><tr><td><p><span class="stt">'(2 3)</span></p></td></tr></table></div><div class="SIntrapara">To convert this to use <span class="stt">Maybeof</span>, we can write
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">in-list?</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">e</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">Listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">Maybeof</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">Listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">let</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">member</span><span class="hspace">&nbsp;</span><span class="RktMeta">e</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">v</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">none</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">which, if the element is not found, returns the value <span class="stt">(none)</span>,
but if it is found, still returns a list
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (in-list? 2 (list 1 2 3))</span></p></td></tr><tr><td><p><span class="stt">'(2 3)</span></p></td></tr></table></div><div class="SIntrapara">so that there is no need to remove the list from a <span class="stt">some</span>
wrapper.</div></p><h5>15.3.3.3<tt>&nbsp;</tt><a name="(part._.Discriminating_.Untagged_.Unions)"></a>Discriminating Untagged Unions</h5><p><div class="SIntrapara">It&rsquo;s one thing to put values into unions; we have to also consider how
to take them out, in a well-typed manner.  In our ML-like type system,
we use a stylized notation&#8212;<wbr></wbr><span class="stt">type-case</span> in our language,
pattern-matching in ML&#8212;<wbr></wbr>to identify and pull apart the pieces.  In
particular, when we write
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">safe-to-transport?</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Animal</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">boolean</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">type-case</span><span class="hspace">&nbsp;</span><span class="RktMeta">Animal</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">armadillo</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">a?</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">a?</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">boa</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">not</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">big-one?</span><span class="hspace">&nbsp;</span><span class="RktMeta">l</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">the type of <span class="stt">a</span> remains the same in the entire expression.  The
identifiers <span class="stt">a?</span> and <span class="stt">l</span> are bound to a boolean and numeric
value, respectively, and <span class="stt">big-one?</span>  must now be written to
consume those types, not <span class="stt">armadillo</span> and <span class="stt">boa</span>.  Put in
different terms, we cannot have a function <span class="stt">big-one?</span> that
consumes <span class="stt">boa</span>s, because there is no such type.</div></p><p><div class="SIntrapara">In contrast, with union types, we do have the <span class="stt">boa</span> type.
Therefore, we follow the principle that the act of asking predicates
of a value <span style="font-style: italic">narrows the type</span>.  For instance, in the <span class="stt">cond</span>
case
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktMeta">boa?</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">not</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">big-one?</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">though <span class="stt">a</span> begins as type <span class="stt">Animal</span>, after it passes the
<span class="stt">boa?</span> test, the type checker is expected to narrow its type to
just the <span class="stt">boa</span> branch, so that the application of <span class="stt">big-one?</span>
is well-typed.  In turn, in the rest of the conditional its type is
<span style="font-style: italic">not</span> <span class="stt">boa</span>&#8212;<wbr></wbr>in this case, that leaves only one
possibility, <span class="stt">armadillo</span>.  This puts greater pressure on the
type-checker&rsquo;s ability to test and recognize certain patterns&#8212;<wbr></wbr>known
as <span style="font-style: italic">if-splitting</span>&#8212;<wbr></wbr>without which it would be impossible to
program with union types; but it can always default to recognizing
just those patterns that the ML-like system would have recognized,
such as pattern-matching or <span class="stt">type-case</span>.</div></p><h5>15.3.3.4<tt>&nbsp;</tt><a name="(part._.Retrofitting_.Types)"></a>Retrofitting Types</h5><p>It is unsurprising that Typed Racket uses union types.  They are
especially useful when <span style="font-style: italic">retrofitting</span> types onto existing
programming languages whose programs were not defined with an ML-like
type discipline in mind, such as in scripting languages.  A common
principle of such retrofitted types is to statically catch as many
dynamic exceptions as possible.  Of course, the checker must
ultimately reject some programs,<span class="refelem"><span class="refcolumn"><span class="refcontent">Unless it implements an
interesting idea called <span style="font-style: italic">soft typing</span>, which rejects no programs
but provides information about points where the program would not have
been typeable.</span></span></span> and if it rejects too many programs that would have
run without an error, developers are unlikely to adopt it.  Because
these programs were written without type-checking in mind, the type
checker may therefore need to go to heroic lengths to accept what are
considered reasonable idioms in the language.</p><p><div class="SIntrapara">Consider the following JavaScript function:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">var slice = function (arr, start, stop) {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">var result = [];</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">for (var i = 0; i &lt;= stop - start; i++) {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">result[i] = arr[start + i];</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return result;</span></p></td></tr><tr><td><p><span class="stt">}</span></p></td></tr></table></div><div class="SIntrapara">It consumes an array and two indices, and produces the sub-array
between those indices.  For instance,
<span class="stt">slice([5, 7, 11, 13], 0, 2)</span> produces
<span class="stt">[5, 7, 11]</span>.</div></p><p><div class="SIntrapara">In JavaScript, however, developers are free to leave out any or all
trailing arguments to a function.  Every elided argument is given a
special value, <span class="stt">undefined</span>, and it is up to the function to cope
with this.  For instance, a typical implementation of <span class="stt">splice</span>
would let the user drop the third argument; the following definition
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">var slice = function (arr, start, stop) {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">if (typeof stop == "undefined")</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">stop = arr.length - 1;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">var result = [];</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">for (var i = 0; i &lt;= stop - start; i++) {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">result[i] = arr[start + i];</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return result;</span></p></td></tr><tr><td><p><span class="stt">}</span></p></td></tr></table></div><div class="SIntrapara">automatically returns the subarray until the end of the array: thus,
<span class="stt">slice([5, 7, 11, 13], 2)</span> returns <span class="stt">[11, 13]</span>.</div></p><p><div class="SIntrapara">In Typed JavaScript,<span class="refelem"><span class="refcolumn"><span class="refcontent">Built at Brown by Arjun
Guha and others.  See
<a href="http://www.jswebtools.org/">our Web site</a>.</span></span></span>
a programmer can explicitly indicate a function&rsquo;s willingness to
accept fewer arguments by giving a parameter the type
<span class="stt">U Undefined</span>, giving it the type
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">&#8704;</span><span class="hspace">&nbsp;</span><span class="RktMeta">t</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">Array</span><span class="RktPn">[</span><span class="RktMeta">t</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta">Int</span><span class="hspace">&nbsp;</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">Int</span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">Undefined</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">Array</span><span class="RktPn">[</span><span class="RktMeta">t</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In principle, this means there is a potential type error at the
expression <span class="stt">stop - start</span>, because <span class="stt">stop</span> may not be a
number.  However, the assignment to <span class="stt">stop</span> sets it to a numeric
type precisely when it was elided by the user.  In other words, in all
control paths, <span class="stt">stop</span> will eventually have a numeric type before
the subtraction occurs, so this function is well-typed.  Of course,
this requires the type-checker to be able to reason about both
control-flow (through the conditional) and state (through the
assignment) to ensure that this function is well-typed; but Typed
JavaScript can, and can thus bless functions such as this.</div></p><h5>15.3.3.5<tt>&nbsp;</tt><a name="(part._.Design_.Choices)"></a>Design Choices</h5><p><div class="SIntrapara">In languages with union types, it is common to have
</div><div class="SIntrapara"><ul><li><p>Stand-alone structure types (often represented using classes),
rather than datatypes with variants.</p></li><li><p>Ad hoc collections of structures to represent particular
types.</p></li><li><p>The use of sentinel values to represent
failure.</p></li></ul></div><div class="SIntrapara">To convert programs written in this style to an ML-like type
discipline would be extremely onerous.  Therefore, many retrofitted
type systems adopt union types to ease the process of typing.</div></p><p><div class="SIntrapara">Of the three properties above, the first seems morally neutral, but
the other two warrant more discussion.  We will address them in
reverse order.
</div><div class="SIntrapara"><ul><li><p>Let&rsquo;s tackle sentinels first.  In many cases, sentinels ought
to be replaced with exceptions, but in many languages, exceptions
can be very costly.  Thus, developers prefer to make a distinction
between truly exceptional situations&#8212;<wbr></wbr>that ought not occur&#8212;<wbr></wbr>and
situations that are expected in the normal course of operation.
Checking whether an element is in a list and failing to find it is
clearly in the latter category (if we already knew the element was
or wasn&rsquo;t present, there would be no need to run this predicate).
In the latter case, using sentinels is reasonable.</p><p>However, we must square this with the observation that failure to
check for exceptional sentinel values is a common source of
error&#8212;<wbr></wbr>and indeed, security flaws&#8212;<wbr></wbr>in C programs.  This is easy to
reconcile.  In C, the sentinel is of the <span style="font-style: italic">same type</span> (or at
least, effectively the same type) as the regular return value, and
furthermore, there are no run-time checks.  Therefore, the sentinel
can be used as a legitimate value without a type error.  As a
result, a sentinel of <span class="stt">0</span> can be treated as an address into
which to allocate data, thus potentially crashing the system.  In
contrast, our sentinel is of a truly new type that cannot be used in
any computation.  We can easily reason about this by observing that
no existing functions in our language consume values of type
<span class="stt">none</span>.</p></li><li><p><div class="SIntrapara">Setting aside the use of &ldquo;ad hoc&rdquo;, which is pejorative, are
  different groupings of a set of structures a good idea?  In fact,
  such groupings occur even in programs using an ML-like discipline,
  when programmers want to carve different sub-universes of a larger
  one.  For instance, ML programmers use a type like
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">SExp</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">numSexp</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">strSexp</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">s</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">listSexp</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">listof</span><span class="hspace">&nbsp;</span><span class="RktMeta">SExp</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">to represent s-expressions.  If a function now operates on just some
  subset of these terms&#8212;<wbr></wbr>say just numbers and lists of numbers&#8212;<wbr></wbr>they
  must create a fresh type, and convert values between the two types
  even though their underlying representations are essentially
  identical.  As another example, consider the set of <span class="Smaller">CPS</span>
  expressions.  This is clearly a subset of all possible expressions,
  but if we were to create a fresh datatype for it, we would not be
  able to use any existing programs that process expressions&#8212;<wbr></wbr>such as
  the interpreter.</div></p></li></ul></div></p><p><div class="SIntrapara">In other words, union types appear to be a reasonable variation on the
ML-style type system we have seen earlier.  However, even within union
types there are design variations, and these have consequences.  For
instance, can the type system create new unions, or are user-defined
(and named) unions permitted?  That is, can an expression like this
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">phase-of-the-moon</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">true</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">be allowed to type (to <span class="stt">(U Number Boolean)</span>), or is it a type
error to introduce unions that have not previously been named and
explicitly identified?  Typed Racket provides the former: it will
construct truly ad hoc unions.  This is arguably better for importing
existing code into a typed setting, because it is more flexible.
However, it is less clear whether this is a good design for writing
new code, because unions the programmer did not intend can occur and
there is no way to prevent them.  This offers an unexplored corner in
the design space of programming languages.</div></p><h5>15.3.4<tt>&nbsp;</tt><a name="(part._.Nominal_.Versus_.Structural_.Systems)"></a>Nominal Versus Structural Systems</h5><p>In our initial type-checker, two types were considered equivalent if
they had the same structure.  In fact, we offered no mechanism for
naming types at all, so it is not clear what alternative we had.</p><p><div class="SIntrapara">Now consider Typed Racket.  A developer can write
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">NB1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">Number</span><span class="hspace">&nbsp;</span><span class="RktMeta">Boolean</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">NB2</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">Number</span><span class="hspace">&nbsp;</span><span class="RktMeta">Boolean</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">followed by
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define:</span><span class="hspace">&nbsp;</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">NB1</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Suppose the developer also defines the function
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">define:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">f</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">NB2</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">NB2</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and tries to apply <span class="stt">f</span> to <span class="stt">v</span>, i.e., <span class="stt">(f v)</span>: should
this application type or not?</div></p><p>There are two perfectly reasonable interpretations.  One is to say
that <span class="stt">v</span> was declared to be of type <span class="stt">NB1</span>, which is a
different <span style="font-style: italic">name</span> than <span class="stt">NB2</span>, and hence should be considered
a different <span style="font-style: italic">type</span>, so the above application should result in an
error.  Such a system is called <span style="font-style: italic">nominal</span>, because the name of a
type is paramount for determining type equality.</p><p>In contrast, another interpretation is that because the
<span style="font-style: italic">structure</span> of <span class="stt">NB1</span> and <span class="stt">NB2</span> are identical, there is
no way for a developer to write a program that behaves differently on
values of these two types, so these two types should be considered
identical.<span class="refelem"><span class="refcolumn"><span class="refcontent">If you want to get especially careful, you
would note that there is a difference between being considered the
same and actually being the same.  We won&rsquo;t go into this issue here,
but consider the implication for a compiler writer choosing
representations of values, especially in a language that allows
run-time inspection of the static types of values.</span></span></span>  Such a type
system is called <span style="font-style: italic">structural</span>, and would successfully type the above
expression.  (Typed Racket follows a structural discipline, again to
reduce the burden of importing existing untyped code, which&#8212;<wbr></wbr>in
Racket&#8212;<wbr></wbr>is usually written with a structural interpretation in mind.
In fact, Typed Racket not only types <span class="stt">(f v)</span>, it prints the
result as having type <span class="stt">NB1</span>, despite the return type annotation
on <span class="stt">f</span>!)</p><p>The difference between nominal and structural typing is most commonly
contentious in object-oriented languages, and we will return to this
issue briefly later [REF].  However, the point of this section is to
illustrate that these questions are not intrinsically about
&ldquo;objects&rdquo;.  Any language that permits types to be named&#8212;<wbr></wbr>as all
must, for programmer sanity&#8212;<wbr></wbr>must contend with this question: is
naming merely a convenience, or are the choices of names intended to
be meaningful?  Choosing the former answer leads to structural typing,
while choosing the latter leads down the nominal path.</p><h5>15.3.5<tt>&nbsp;</tt><a name="(part._.Intersection_.Types)"></a>Intersection Types</h5><p>Since we&rsquo;ve just explored union types, you must naturally wonder
whether there are also <span style="font-style: italic">intersection</span> types.  Indeed there are.</p><p>If a union type means that a value (of that type) belongs to one of
the types in the union, an intersection type clearly means the value
belongs to <span style="font-style: italic">all</span> the types in the intersection: a conjunction, or
&ldquo;and&rdquo;.  This might seem strange: how can a value belong to more than
one type?</p><p><div class="SIntrapara">As a concrete answer, consider <span style="font-style: italic">overloaded functions</span>.  For
instance, in some languages <span class="stt">+</span> operates on both numbers and
strings; given two numbers it produces a number, and given two strings
it produces a string.  In such a language, what is the proper type for
<span class="stt">+</span>?  It is not <span class="stt">(number number -&gt; number)</span> alone, because
that would reject its use on strings.  By the same reasoning, it is
not <span class="stt">(string string -&gt; string)</span> alone either.  It is not even
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">string</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">because <span class="stt">+</span> is not just one of these functions: it truly is both
of them.  We could ascribe the type
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">reflecting the fact that each argument, and the result, can be only
one of these types, not both.  Doing so, however, leads to a loss of
precision.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p>In what way does this type lose precision?</p></blockquote></div></p><p>Observe that with this type, the return type on <span style="font-style: italic">all</span> invocations
is <span class="stt">(number U string)</span>.  Thus, on every return we must
distinguish beween numeric and string returns, or else we will get a
type error.  Thus, even though we know that if given two numeric
arguments we will get a numeric result, this information is lost to
the type system.</p><p>More subtly, this type permits each argument&rsquo;s type to be chosen
independently of the other.  Thus, according to this type, the
invocation <span class="stt">(+ 3 "x")</span> is perfectly valid (and produces a value
of type <span class="stt">(number U string)</span>).  But of course the addition
operation we have specified is not defined for these inputs at all!</p><p><div class="SIntrapara">Thus the proper type to ascribe this form of addition is
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">string</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">where <span class="stt">&#8743;</span> should be reminiscent of the conjunction operator in
logic.  This permits invocation with two numbers or two strings, but
nothing else.  An invocation with two numbers has a numeric result
type; one with two strings has a string result type; and nothing
else.  This corresponds precisely to our intended behavior for
overloading (sometimes also called <span style="font-style: italic">ad hoc polymorphism</span>).
Observe that this only handles a finite number of overloaded cases.</div></p><h5>15.3.6<tt>&nbsp;</tt><a name="(part._.Recursive_.Types)"></a>Recursive Types</h5><p><div class="SIntrapara">Now that we&rsquo;ve seen union types, it pays to return to our original
recursive datatype formulation.  If we accept the variants as type
constructors, can we write the recursive type as a union over these?
For instance, returning to <span class="stt">BTnum</span>, shouldn&rsquo;t we be able to
describe it as equivalent to
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">BTmt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">BTnd</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">thereby showing that <span class="stt">BTmt</span> is a zero-ary constructor, and
<span class="stt">BTnd</span> takes three parameters?  Except, what are the types of
those three parameters?  In the type we&rsquo;ve written above, <span class="stt">BTnum</span>
is either built into the type language (which is unsatisfactory) or
unbound.  Perhaps we mean
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">BTmt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">BTnd</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Except now we have an equation that has no obvious solution (remember
&#969;?).</div></p><p><div class="SIntrapara">This situation should be familiar from recursion in values [REF].
Then, we invented a recursive function constructor (and showed its
implementation) to circumvent this problem.  We similarly need a
recursive <span style="font-style: italic">type</span> constructor.  This is conventionally called &#956;
(the Greek letter &ldquo;mu&rdquo;).  With it, we would write the above type as
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">&#956;</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">BTmt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">BTnd</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">&#956; is a binding construct; it binds <span class="stt">BTnum</span> to the entire type
written after it, including the recursive binding of <span class="stt">BTnum</span>
itself.  In practice, of course, this entire recursive type is the one
we wish to call <span class="stt">BTnum</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">&#956;</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">BTmt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">BTnd</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">BTnum</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Though this looks like a circular definition, notice that the name
<span class="stt">BTnum</span> on the right does not depend on the one to the left of
the equation: i.e., we could rewrite this as
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">BTnum</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">&#956;</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">BTmt</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">BTnd</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">In other words, this definition of <span class="stt">BTnum</span> truly can be thought
of as syntactic sugar and replaced everywhere in the program without
fear of infinite regress.</div></p><p><div class="SIntrapara">At a semantic level, there are usually two very different ways of
thinking about the meaning of types bound by &#956;: they can be
interpreted as <span style="font-style: italic">isorecursive</span> or <span style="font-style: italic">equirecursive</span>.  The
distinction between these is, however, subtle and beyond the scope of
this chapter.<span class="refelem"><span class="refcolumn"><span class="refcontent">This material is covered especially well in
Pierce&rsquo;s book.</span></span></span>  It suffices to note that a recursive type can be
treated as equivalent to its unfolding.  For instance, if we define
a numeric list type as
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">NumL</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">&#956;</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">MtL</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">ConsL</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">then
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">&#956;</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">MtL</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">ConsL</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">MtL</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">ConsL</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">&#956;</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">MtL</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">ConsL</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">MtL</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">ConsL</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">MtL</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">ConsL</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">ConsL</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">&#956;</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktMeta">MtL</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">ConsL</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">and so on (iso- and equi-recursiveness differ in precisely what the
notion of equality is: definitional equality or isomorphism).  At each
step we simply replace the <span class="stt">T</span> parameter with the entire type.
As with value recursion, this means we can &ldquo;get another&rdquo; <span class="stt">ConsL</span>
constructor upon demand.  Put differently, the <span style="font-style: italic">type</span> of a list
can be written as the union of zero or arbitrarily many elements; this
is the same as the <span style="font-style: italic">type</span> that consists of zero, one, or
arbitrarily many elements; and so on.  Any lists of numbers fits all
(and precisely) these types.</div></p><p>Observe that even with this informal understanding of &#956;, we can now
provide a type to &#969;, and hence to &#937;.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Ascribe types to &#969; and &#937;.</p></blockquote></div></p><h5>15.3.7<tt>&nbsp;</tt><a name="(part._.Subtyping)"></a>Subtyping</h5><p><div class="SIntrapara">Imagine we have a typical binary tree definition; for simplicity,
we&rsquo;ll assume that all the values are numbers.  We will write this
in Typed Racket to illustrate a point:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><a href="http://docs.racket-lang.org/ts-reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">typed/racket</span></a><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define-struct:</span><span class="hspace">&nbsp;</span><span class="RktMeta">mt</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define-struct:</span><span class="hspace">&nbsp;</span><span class="RktMeta">nd</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktMeta">v</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">Number</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">l</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">BT</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktMeta">r</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">BT</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">define-type</span><span class="hspace">&nbsp;</span><span class="RktMeta">BT</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">mt</span><span class="hspace">&nbsp;</span><span class="RktMeta">nd</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Now consider some concrete tree values:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (mt)</span></p></td></tr><tr><td><p><span class="stt">- : mt</span></p></td></tr><tr><td><p><span class="stt">#&lt;mt&gt;</span></p></td></tr><tr><td><p><span class="stt">&gt; (nd 5 (mt) (mt))</span></p></td></tr><tr><td><p><span class="stt">- : nd</span></p></td></tr><tr><td><p><span class="stt">#&lt;nd&gt;</span></p></td></tr></table></div><div class="SIntrapara">Observe that each structure constructor makes a value of its own type,
not a value of type <span class="stt">BT</span>.  But consider the expression
<span class="stt">(nd 5 (mt) (mt))</span>: the definition of <span class="stt">nd</span> declares that the
sub-trees must be of type <span class="stt">BT</span>, and yet we are able to
successfully give it values of type <span class="stt">mt</span>.</div></p><p>Obviously, it is not coincidental that we have defined <span class="stt">BT</span> in
terms of <span class="stt">mt</span> and <span class="stt">nd</span>.  However, it does indicate that when
type-checking, we cannot simply be checking for function equality, at
least not as we have so far.  Instead, we must be checking that one
type &ldquo;fits into&rdquo; the other.  This notion of fitting is called
<span style="font-style: italic">subtyping</span> (and the act of being fit, <span style="font-style: italic">subsumption</span>).</p><p>The essence of subtyping is to define a relation, usually denoted by
<span class="stt">&lt;:</span>, that relates pairs of types.  We say <span class="stt">S &lt;: T</span> if a
value of type <span class="stt">S</span> can be given where a value of type <span class="stt">T</span> is
expected: in other words, subtyping formalizes the notion of
<span style="font-style: italic">substitutability</span> (i.e., anywhere a value of type <span class="stt">T</span> was
expected, it can be replaced with&#8212;<wbr></wbr>substituted by&#8212;<wbr></wbr>a value of type
<span class="stt">S</span>).  When this holds, <span class="stt">S</span> is called the <span style="font-style: italic">subtype</span> and
<span class="stt">T</span> the <span style="font-style: italic">supertype</span>.  It is useful (and usually accurate) to
take a subset interpretation: if the values of <span class="stt">S</span> are a subset
of <span class="stt">T</span>, then an expression expecting <span class="stt">T</span> values will not be
unpleasantly surprised to receive only <span class="stt">S</span> values.</p><p>Subtyping has a pervasive effect on the type system.  We have to
reexamine every kind of type and understand its interaction with
subtyping.  For base types, this is usually quite obvious: disjoint
types like <span class="stt">number</span>, <span class="stt">string</span>, etc., are all unrelated to
each other.  (In languages where one base type is used to represent
another&#8212;<wbr></wbr>for instance, in some scripting languages numbers are merely
strings written with a special syntax, and in other languages,
booleans are merely numbers&#8212;<wbr></wbr>there might be subtyping relationships
even between base types, but these are not common.)  However, we do
have to consider how subtyping interacts with every single compound
type constructor.</p><p>In fact, even our very diction about types has to change.  Suppose we
have an expression of type <span class="stt">T</span>.  Normally, we would say that it
produces values of type <span class="stt">T</span>.  Now, we should be careful to say
that it produces values of <span style="font-style: italic">up to</span> or <span style="font-style: italic">at most</span> <span class="stt">T</span>,
because it may only produce values of a subtype of <span class="stt">T</span>.  Thus
every reference to a type should implicitly be cloaked in a reference
to the potential for subtyping.  To avoid pestering you I will refrain
from doing this, but be wary that it is possible to make reasoning
errors by not keeping this implicit interpretation in mind.</p><h5>15.3.7.1<tt>&nbsp;</tt><a name="(part._.Unions)"></a>Unions</h5><p><div class="SIntrapara">Let us see how unions interact with subtyping.  Clearly, every
sub-union is a subtype of the entire union.  In our running example,
clearly every <span class="stt">mt</span> value is also a <span class="stt">BT</span>; likewise for
<span class="stt">nd</span>.  Thus,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">mt</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;:</span><span class="hspace">&nbsp;</span><span class="RktMeta">BT</span></td></tr><tr><td><span class="RktMeta">nd</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;:</span><span class="hspace">&nbsp;</span><span class="RktMeta">BT</span></td></tr></table></blockquote></div><div class="SIntrapara">As a result, <span class="stt">(mt)</span> also has type <span class="stt">BT</span>, thus enabling the
expression <span class="stt">(nd 5 (mt) (mt))</span> to itself type, and to have the
type <span class="stt">nd</span>&#8212;<wbr></wbr>and hence, also the type <span class="stt">BT</span>.  In general,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">S</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">S</span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">T</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">S</span><span class="hspace">&nbsp;</span><span class="RktMeta">U</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">(we write what seems to be the same rule twice just to make clear it
doesn&rsquo;t matter which &ldquo;side&rdquo; of the union the subtype is on).  This
says that a value of <span class="stt">S</span> can be thought of as a value of
<span class="stt">S U T</span>, because any expression of type <span class="stt">S U T</span> can indeed
contain a value of type <span class="stt">S</span>.</div></p><h5>15.3.7.2<tt>&nbsp;</tt><a name="(part._.Intersections)"></a>Intersections</h5><p><div class="SIntrapara">While we&rsquo;re at it, we should also briefly visit intersections.  As you
might imagine, intersections behave dually:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">S</span><span class="hspace">&nbsp;</span><span class="RktMeta">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;:</span><span class="hspace">&nbsp;</span><span class="RktMeta">S</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">S</span><span class="hspace">&nbsp;</span><span class="RktMeta">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;:</span><span class="hspace">&nbsp;</span><span class="RktMeta">T</span></td></tr></table></blockquote></div><div class="SIntrapara">To convince yourself of this, take the subset interpretation: if a
value is both <span class="stt">S</span> and <span class="stt">T</span>, then clearly it is either one of
them.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Do Now!</span></div><div class="SIntrapara"><blockquote><p><div class="SIntrapara">Why are the following two <span style="font-style: italic">not</span> valid subsumptions?
</div><div class="SIntrapara"><ol><li><p><span class="stt">(S U T) &lt;: S</span></p></li><li><p><span class="stt">T &lt;: (S &#8743; T)</span></p></li></ol></div></p></blockquote></div></p><p>The first is not valid because a value of type <span class="stt">T</span> is a perfectly
valid element of type <span class="stt">(S U T)</span>.  For instance, a number is a
member of type <span class="stt">(string U number)</span>.  However, a number cannot be
supplied where a value of type <span class="stt">string</span> is expected.</p><p>As for the second, in general, a value of type <span class="stt">T</span> is not also a
value of type <span class="stt">S</span>.  Any consumer of a <span class="stt">(S &#8743; T)</span> value is
expecting to be able to treat it as both a <span class="stt">T</span> and a <span class="stt">S</span>,
and the latter is not justified.  For instance, given our overloaded
<span class="stt">+</span> from before, if <span class="stt">T</span> is <span class="stt">(number number -&gt; number)</span>,
then a function of this type will not know how to operate on strings.</p><h5>15.3.7.3<tt>&nbsp;</tt><a name="(part._.Functions)"></a>Functions</h5><p><div class="SIntrapara">We have seen one more constructor: functions.<span class="refelem"><span class="refcolumn"><span class="refcontent">We have
also seen parametric datatypes.  In this edition, exploring subtyping
for them is left as an exercise for the reader.</span></span></span>  We must therefore
determine the rules for subtyping when either type can be a function.
Since we usually assume functions are disjoint from all other types,
we therefore only need to consider when one function type is a subtype
of another: i.e., when is
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">S1</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">T1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">S2</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">T2</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">?
For convenience, let us call the type <span class="stt">(S1 -&gt; T1)</span> as <span class="stt">f1</span>,
and <span class="stt">(S2 -&gt; T2)</span> as <span class="stt">f2</span>.  The question then is, if an
expression is expecting functions of the <span class="stt">f2</span> type, when can we
safely give it functions with the <span class="stt">f1</span> type?  It is easiest to
think through this using the subset interpretation.</div></p><p>Consider a use of the <span class="stt">f2</span> type.  It returns values of type
<span class="stt">T2</span>.  Thus, the context surrounding the function application is
satisfied with values of type <span class="stt">T2</span>.  Clearly, if <span class="stt">T1</span> is the
same as <span class="stt">T2</span>, the use of <span class="stt">f2</span> would continue to type;
similarly, if <span class="stt">T1</span> consists of a subset of <span class="stt">T2</span> values, it
would still be fine.  The only problem is if <span class="stt">T1</span> has more values
than <span class="stt">T2</span>, because the context would then encounter unexpected
values that would result in undefined behavior.  In other words, we
need that <span class="stt">T1 &lt;: T2</span>.  Observe that the &ldquo;direction&rdquo; of
containment is the same as that for the entire function type; this is
called <span style="font-style: italic">covariance</span> (both vary in the same direction).  This is
perhaps precisely what you expected.</p><p>By the same token, you might expect covariance in the argument
position as well: namely, that <span class="stt">S1 &lt;: S2</span>.  This would be
predictable, and wrong.  Let&rsquo;s see why.</p><p>An application of a function with <span class="stt">f2</span> type is providing
parameter values of type <span class="stt">S2</span>.  Suppose we instead substitute the
function with one of type <span class="stt">f1</span>.  If we had that <span class="stt">S1 &lt;: S2</span>,
that would mean that the new function accepts only values of
type<span class="stt">S1</span>&#8212;<wbr></wbr>a strictly smaller set.  That means there may be some
inputs&#8212;<wbr></wbr>specifically those in <span class="stt">S2</span> that are not in
<span class="stt">S1</span>&#8212;<wbr></wbr>that the application is free to provide on which the
substituted function is not defined, again resulting in undefined
behavior.  To avoid this, we have to make the subsumption go in the
other direction: the substituting function should accept at least as
many inputs as the one it replaces.  Thus we need <span class="stt">S2 &lt;: S1</span>, and
say the function position is <span style="font-style: italic">contravariant</span>: it goes against the
direction of subtyping.</p><p><div class="SIntrapara">Putting together these two observations, we obtain a subtyping rule
for functions (and hence also methods):
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktMeta">S2</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;:</span><span class="hspace">&nbsp;</span><span class="RktMeta">S1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">and</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">T1</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;:</span><span class="hspace">&nbsp;</span><span class="RktMeta">T2</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">=&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">S1</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">T1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">S2</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">T2</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><h5>15.3.7.4<tt>&nbsp;</tt><a name="(part._.Implementing_.Subtyping)"></a>Implementing Subtyping</h5><p><div class="SIntrapara">Of course, these rules assume that we have modified the type-checker
to respect subtyping.  The essence of subtyping is a rule that says,
if an expression <span class="stt">e</span> is of type <span class="stt">S</span>, and <span class="stt">S &lt;: T</span>, then
<span class="stt">e</span> also has type <span class="stt">T</span>.  While this sounds intuitive, it is
also immediately problematic for two reasons:
</div><div class="SIntrapara"><ul><li><p>Until now all of our type rules have been syntax-driven, which
is what enabled us to write a recursive-descent type-checker.  Now,
however, we have a rule that applies to <span style="font-style: italic">all</span> expressions, so
we can no longer be sure when to apply it.</p></li><li><p>There could be many levels of subtyping.  As a result, it is
no longer obvious when to &ldquo;stop&rdquo; subtyping.  In particular,
whereas before type-checking was able to calculate the type of an
expression, now we have many possible types for each expression; if
we return the &ldquo;wrong&rdquo; one, we might get a type error (due to that
not being the type expected by the context) even though there exists
some other type that was the one expected by the context.</p></li></ul></div><div class="SIntrapara">What these two issues point to is that the description of subtyping we
are giving here is fundamentally <span style="font-style: italic">declarative</span>: we are saying
what must be true, but not showing how to turn it into an algorithm.
For each actual type language, there is a less or more interesting
problem in turning this into <span style="font-style: italic">algorithmic subtyping</span>: an actual
algorithm that realizes a type-checker (ideally one that types exactly
those programs that would have typed under the declarative regime,
i.e., one that is both sound and complete).</div></p><h5>15.3.8<tt>&nbsp;</tt><a name="(part._.Object_.Types)"></a>Object Types</h5><p><div class="SIntrapara">As we&rsquo;ve mentioned earlier, types for objects are typically riven into
two camps: nominal and structural.  Nominal types are familiar to most
programmers through Java, so I won&rsquo;t say much about them here.
Structural types for objects dictate that an object&rsquo;s type is itself a
structured object, consisting of names of fields and their types.  For
instance, an object with two methods, <span class="stt">add1</span> and <span class="stt">sub1</span>
[REF], would have the type
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">{</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">sub1</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">(For future reference, let&rsquo;s call this type <span class="stt">addsub</span>.)
Type-checking would then follow along predictable lines: for field
access we would simply ensure the field exists and would use its
declared type for the dereference expression; for method invocation we
would have to ensure not only that the member exists but that it has a
function type.  So far, so straightforward.</div></p><p><div class="SIntrapara">Object types become complicated for many reasons:<span class="refelem"><span class="refcolumn"><span class="refcontent">Whole
books are therefore devoted to this topic.  Abadi and Carelli&rsquo;s
<span style="font-style: italic">A Theory of Objects</span> is important but now somewhat dated.
Bruce&rsquo;s <span style="font-style: italic">Foundations of Object-Oriented Languages: Types and
Semantics</span> is more modern, and also offers more gentle exposition.
Pierce covers all the necessary theory beautifully.</span></span></span>
</div><div class="SIntrapara"><ul><li><p>Self-reference.  What is the type of <span class="stt">self</span>?  It must the
same type as the object itself, since any operation that can be
applied to the object from the &ldquo;outside&rdquo; can also be applied to it
from the &ldquo;inside&rdquo; using <span class="stt">self</span>.  This means object types are
recursive types.</p></li><li><p>Access controls: private, public, and other restrictions.
These lead to a distinction in the type of an object from
&ldquo;outside&rdquo; and &ldquo;inside&rdquo;.</p></li><li><p>Inheritance.  Not only do we have to give a type to the parent
object(s), what is visible along inheritance paths may, again,
differ from what is visible from the &ldquo;outside&rdquo;.</p></li><li><p>The interplay between multiple-inheritance and subtyping.</p></li><li><p>The relationship between classes and interfaces in languages
like Java, which has a run-time cost.</p></li><li><p>Mutation.</p></li><li><p>Casts.</p></li><li><p>Snakes on a plane.</p></li></ul></div><div class="SIntrapara">and so on.  Some of these problems simplify in the presence of nominal
types, because given a type&rsquo;s name we can determine everything about
its behavior (the type declarations effectively become a dictionary
through which the object&rsquo;s description can be looked up on demand),
which is one argument in favor of nominal typing.<span class="refelem"><span class="refcolumn"><span class="refcontent">Note
that Java&rsquo;s approach is not the only way to build a nominal type
system.  We have already argued that Java&rsquo;s class system needlessly
restricts the expressive power of programmers [REF]; in turn, Java&rsquo;s
nominal type system needlessly conflates types (which are interface
descriptions) and implementations.  It is, therefore, possible to have
much better nominal type systems than Java&rsquo;s.  Scala, for instance,
takes significant steps in this direction.</span></span></span></div></p><p>A full exposition of these issues will take much more room than we
have here.  For now, we will limit ourselves to one interesting
question.  Remember that we said subtyping forces us to consider every
type constructor?  The structural typing of objects introduces one
more: the object type constructor.  We therefore have to understand
its interaction with subtyping.</p><p>Before we do, let&rsquo;s make sure we understand what an object type even
means.  Consider the type <span class="stt">addsub</span> above, which lists two
methods.  What objects can be given this type?  Obviously, an object
with just those two methods, with precisely those two types, is
eligible.  Equally obviously, an object with only one and not the
other of those two methods, no matter what else it has, is not.  But
the phrase &ldquo;no matter what else it has&rdquo; is meant to be leading.
What if an object represents an arithmetic package that also contains
methods <span class="stt">+</span> and <span class="stt">*</span>, in addition to the above two (all of
the appropriate type)?  In that case we certainly have an object that
can supply those two methods, so the arithmetic package certainly has
type <span class="stt">addsub</span>.  Its other methods are simply inaccessible using
type <span class="stt">addsub</span>.</p><p><div class="SIntrapara">Let us write out the type of this package, in full, and call this type
<span class="stt">as+*</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">{</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">sub1</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">+</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">*</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">What we have just argued is that an object of type <span class="stt">as+*</span> should
also be allowed to claim the type <span class="stt">addsub</span>, which means it can be
substituted in any context expecting a value of type <span class="stt">addsub</span>.
In other words, we have just said that we want <span class="stt">as+* &lt;: addsub</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">{</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta">add1</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">sub1</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">&lt;:</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">sub1</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">+</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktMeta">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">*</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">number</span><span class="RktPn">)</span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">This may momentarily look confusing: we&rsquo;ve said that subtyping follows
set inclusion, so we would expect the smaller set on the left and the
larger set on the right.  Yet, it looks like we have a &ldquo;larger type&rdquo;
(certainly in terms of character count) on the left and a &ldquo;smaller
type&rdquo; on the right.</div></p><p>To understand why this is sound, it helps to develop the intuition
that the &ldquo;larger&rdquo; the type, the fewer values it can have.  Every
object that has the four methods on the left clearly also has the two
methods on the right.  However, there are many objects that have the
two methods on the right that fail to have all four on the left.  If
we think of a type as a constraint on acceptable value shapes, the
&ldquo;bigger&rdquo; type imposes more constraints and hence admits fewer
values.  Thus, though the <span style="font-style: italic">types</span> may appear to be of the wrong
sizes, everything is well because the sets of values they subscribe
are of the expected sizes.</p><p>More generally, this says that by dropping fields from an object&rsquo;s
type, we obtain a supertype.  This is called <span style="font-style: italic">width subtyping</span>,
because the subtype is &ldquo;wider&rdquo;, and we move up the subtyping
hierarchy by adjusting the object&rsquo;s &ldquo;width&rdquo;.  We see this even in
the nominal world of Java: as we go up the inheritance chain a class
has fewer and fewer methods and fields, until we reach <span class="stt">Object</span>,
the supertype of all classes, which has the fewest.  Thus for all
class types <span class="stt">C</span> in Java,
<span class="stt">C &lt;: Object</span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">Somewhat confusingly, the terms
<span style="font-style: italic">narrowing</span> and <span style="font-style: italic">widening</span> are sometimes used, but with what
some might consider the opposite meaning.  To widen is to go
from subtype to supertype, because it goes from a &ldquo;narrower&rdquo;
(smaller) to a &ldquo;wider&rdquo; (bigger) set.  These terms evolved
independently, but unfortunately not consistently.</span></span></span></p><p>As you might expect, there is another important form of subtyping,
which is <span style="font-style: italic">within</span> a given member.  This simply says that any
particular member can be subsumed to a supertype in its corresponding
position.  For obvious reasons, this form is called
<span style="font-style: italic">depth subtyping</span>.</p><p><div class="SIntrapara"><span style="font-weight: bold">Exercise</span></div><div class="SIntrapara"><blockquote><p>Construct two examples of depth subtyping.  In one, give the field
itself an object type, and use width subtyping to subtype that field.
In the other, give the field a function type.</p></blockquote></div></p><p>Java has limited depth subtyping, preferring types to be
<span style="font-style: italic">invariant</span> down the object hierarchy because this is a safe
option for conventional mutation.</p><p>The combination of width and depth subtyping cover the most
interesting cases of object subtyping.  A type system that implemented
only these two would, however, needlessly annoy programmers.  Other
convenient (and mathematically necessary) rules include the ability to
permute names, reflexivity (every type is a subtype of itself, because
it is more convenient to interpret the subtype relationship as &#8838;), and
transitivity.  Languages like Typed JavaScript employ all these
features to provide maximum flexibility to programmers.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Control_Operations.html" title="backward to &quot;14 Control Operations&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="contracts.html" title="forward to &quot;16 Checking Program Invariants Dynamically: Contracts&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>