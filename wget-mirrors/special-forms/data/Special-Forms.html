<html>
<head>
<TITLE>``Special Forms in Lisp'' by Kent Pitman (August, 1980)</title>
<META NAME="ROBOTS" CONTENT="INDEX, NOFOLLOW">
</head>
<body BGCOLOR="#eeeeff" TEXT="#440077"
      LINK="#7700bb" VLINK="#7700bb" ALINK="#ff0000">

<FONT color="green">

<H1 ALIGN=CENTER>Special Forms in Lisp</h1>

<P ALIGN=CENTER>
<b>This paper appears in the<br />
<i>Conference Record of the 1980 Lisp Conference</i>,<br />
Stanford University, August 25-27, 1980.</B>
</p>

<p>
The substance of the original text appears in normal fonting,
 though a small number of out-and-out typos were corrected.
 Oddities of spelling that were the custom of the time
 (either generally, or just for me) were left alone.
 Some formatting of headings and tables was adjusted slightly for HTML.
 Any new text that has been added appears
 bracketed and in color green; such text is intended to
 help clarify the historical context, since considerable time 
 passed between the time this paper was published and the time I 
 converted it to HTML.<br />
--<a href="http://www.nhplace.com/kent/contact-kent.html"><i>Kent Pitman</i></a>, 11-Oct-1998.
</p>


<P ALIGN=CENTER>
<a href="Special-Forms.html#ORIGINAL-START">Annotated original document follows.</a><br />
<a href="https://www.nhplace.com/kent/Papers/index.html"><i>Click here for an index 
of other titles by Kent Pitman.</i></a>
</p>

</FONT>


<hr />

<A NAME="ORIGINAL-START"><H1 ALIGN=CENTER>Special Forms in Lisp</h1></a>

<P ALIGN=CENTER><b>Kent Pitman</B></p>

<P ALIGN=CENTER>
<FONT SIZE=2 color="green">[address at time of publication]</FONT><br />
MIT Laboratory for Computer Science<br />
545 Technology Square<br />
Cambridge, MA 02139</p>

<H2 ALIGN=CENTER>Abstract</h2>

<p>
Special forms are those expressions in the Lisp language which 
do not follow normal rules for evaluation.
Some such forms are necessary as primitives of the language, while others
may be desirable in order to improve readability, control the evaluation
environment, implement abstraction and modularity, affect the flow of control,
allow extended scoping mechanisms, define functions which accept a variable
number of arguments, or achieve greater efficiency.  There exist several
long-standing mechanisms for specifying the definition of special forms: 
<tt>FEXPR</tt>'s, <tt>NLAMBDA</tt>'s, and <tt>MACRO</tt>'s.
</p>

<p>
In this paper, the motivations for using special forms are discussed, followed
by a summary of the advantages and disadvantages of employing 
<tt>MACRO</tt>'s, <tt>FEXPR</tt>'s, and <tt>NLAMBDA</tt>'s as tools for their
implementation.  It is asserted that <tt>MACRO</tt>'s offer an adequate
mechanism for specifying special form definitions and that <tt>FEXPR</tt>'s
do not.  Evidence is given which supports the author's contention that 
<tt>FEXPR</tt>'s interfere with the correct operation of code-analyzing 
programs such as the compiler.  Finally, it is suggested that, in the 
design of future Lisp dialects, serious consideration be given to the 
proposition that <tt>FEXPR</tt>'s should be omitted from the language 
altogether.
</p>

<H2 ALIGN=CENTER>Introduction</h2>

<p>
In the past decade
<FONT color="green">[1970's]</FONT>,
Lisp has evolved as the clear favorite among languages used by 
members of the AI community for implementing programs and systems.
The sophistication of such systems, however, is not necessarily reflected
in the code which holds them together.  The underlying code may be a 
patchwork of very low-level constructs which when examined individually
offer little information about the high-level problem they are attempting
to solve.
</p>

<p> 
Many modern programs <FONT color="green">[in 1980]</FONT> are still
written in terms of <tt>CAR</tt>, <tt>CDR</tt> and <tt>CONS</tt>
rather than high-level primitives that insulate the main program from
the representation of its data.  The justifications may vary, but in
many cases it just comes down to an ignorance of the options
available.  Some programmers may claim that use of the more sophisticated
programming constructs of the language are unnecessary, and that use of these
constructs introduces a level of complexity to the code which is unnecessary.
Others may fear that their desire for efficiency must preclude any attempts
at elegance of coding style.
</p>

<p>
<A NAME="RETURN-POINT-1">Over</a>
the past two years <FONT color="green">[1978-1980]</FONT>,
there has been a great increase in the expressive power 
of the Lisp dialects used in the MIT community
<a href="Special-Forms.html#FOOTNOTE-1">[1]</a>--owing to a large degree 
to the development of a large number of sophisticated general-purpose
software packages which allow a programmer to quickly and efficiently 
bootstrap high-level data and program structures to use as ``primitives''
for programming at an even higher level.
In the course of this development, a number of issues have been raised
about what low level primitives should be used to implement these
software packages.
</p>

<p>
In the course of this boom in software development,
<tt>MACRO</tt>'s have demonstrated their power as tools for the
implementation of new systems.  More importantly, 
it has become clear that such programming constructs as
<tt>NLAMBDA</tt>'s and <tt>FEXPR</tt>'s are undesirable 
for reasons which extend beyond mere questions of aesthetics,
for which they are forever under attack.  Indeed, the presence of these 
constructs in the language make it impossible to develop general-purpose
program-manipulation software (<i>e.g.,</i> compilers and macro packages)
which can function with any reasonable degree of reliability.
There exists an inherent potential for error which means that certain
programs, no matter how carefully conceived, must in the end function
only heuristically.  It is with these issues that this 
paper will attempt to deal.
</p>

<H2 ALIGN=CENTER>Terminology</h2>

<p>
<A NAME="RETURN-POINT-2">Non-atomic,</a>
evaluable Lisp expressions may be divided into two fundamental
classes: <b>functional applications</B> and <b>special forms</B>.
Functional applications involve `normal' evaluation--arguments are evaluated
from left to right in most dialects <a href="Special-Forms.html#FOOTNOTE-2">[2]</a>,
followed by an application of a functional object to the result of the
evaluations.  Special forms involve any syntactic or semantic deviation
from this description.
</p>

<blockquote>
<p>
<FONT color="green">
[Common Lisp (1984) later partitioned the same set of expressions
  into three groups, not two.  In Common Lisp, ``macros'' are not ``special
  forms.''  But at the time of this paper, we were still calling ``macros''
  a kind of ``special form''; and what Common Lisp calls ``special forms''
  we were calling ``primitive special forms.''
  Personally, I still prefer the older definition used in this paper.]
</FONT>
</p>
</blockquote>

<p>
For simplicity, we shall use the term <b>operator</B> to mean the
functional description of how any Lisp form is to be evaluated.  It
will be used as the generic term to refer to any object which may
legitimately appear in the <tt>CAR</tt> of an evaluable expression.
By this definition, <tt>CAR</tt>, <tt>COND</tt>, and
<img height=12 WIDTH=12 src="https://www.nhplace.com/kent/Papers/lambda-tr.gif" alt="lambda">-expressions
may all be referred to as operators, despite the
obvious differences in their semantics.  An evaluable expression, the
<tt>CAR</tt> of which is an operator, will be referred to as that
operator's <b>form</B>.
</p>

<H2 ALIGN=CENTER>The Case for Special Forms</h2>

<p>
Before embarking on a discussion of how special forms are or
should be implemented, we should first take a look at the various ways
in which it may be desirable to use them in a real programming
environment, in an attempt to identify the issues with which an
implementation of special forms must attempt to deal.
</p>

<h3>NECESSITY: Basic Primitives</h3>

<p>
In order to do symbolic programming there is a need for at least one
special form which does no argument evaluation.  For this purpose,
Lisp has <tt>QUOTE</tt>.  Having the ability to say <tt>(QUOTE (A B C))</tt>
to refer to a piece of structure rather than the result of evaluating
that piece of structure is fundamental to many forms of Lisp programming.
</p>

<p>
In addition, a small number of special forms that make up primitive 
control structure are also useful (<i>e.g.,</i> <tt>LAMBDA</tt>
expressions to describe functions and <tt>COND</tt> to provide
conditional branching).
</p>

<p>
These fundamentally important forms, out of which the rest of the language is constructed,
will be called <b>primitive special forms</B>.  They may be handled
in special ways by the interpreter or compiler in order
to accomplish their function.
</p>

<h3>CONVENIENCE: Implicit Quoting</h3>

<p>
There are situations in Lisp in which it is so rare that one would
like the argument to a function to evaluate, that one might wish to
define a function which inhibited the evaluation of its arguments
rather than have to manually quote them every time the function was
used.</p>


<blockquote>
<p>
<FONT color="green">
[At the time this paper was written, the Lisp read-eval-print loop <i>was</i>
the interface to Lisp.  Computers didn't have `window systems' in the modern
sense of the word, nor had the term GUI come into existence yet, nor was
there even the notion of a command interface in Lisp separate from program
interfaces.  As such, we're really talking here about the `abuse' of 
linguistic terms, like TRACE and DESCRIBE, to accomodate what later came to
be seen as user interface needs.]
</FONT>
</p>
</blockquote>

<p>
For example, suppose we have a friendly system that offers
a function named <tt>DESCRIBE</tt>, which can be called in order to have
documentation on a function typed out on the console.  That
function might be defined as:

<blockquote>
<pre>
(DEFUN DESCRIBE (ITEM)
       (PRINC (LOOKUP-DOCUMENTATION ITEM)))
</pre>
</blockquote>

<p>
and a typical call to the function might look like
</p>

<blockquote>
<pre>
(DESCRIBE 'CDR).
</pre>
</blockquote>

<p>
After repeated use a Lisp user is likely to tire of having to explicitly
quote the argument.  It may be that he never wants documentation on a
topic which is the value of a variable or the result of evaluating
an expression.  He may find himself omitting the quote unconsciously
and grumbling angrily when an error is generated trying to evaluate an
unbound symbol.  Why shouldn't he be able to have a function which 
had the syntax
</p>

<blockquote>
<pre>
(DESCRIBE CDR)
</pre>
</blockquote>

<p>
if that's the way he will always wish to type it in?  Flexibility in syntax,
if it does not lead to ambiguity, would seem a reasonable thing to ask
of an interactive programming language.
</p>

<h3>COSMETICS: Making things readable</h3>

<p>
In addition to having a language which was easy to work with interactively,
a programmer might like the ability to lay out his program in a way that is
visually comfortable for him to read or edit later on.
</p>

<p>
Let us suppose that we would like to compute the value of the expression
</p>

<P ALIGN=CENTER>
<img alt="Gamma^2(x)+Psi(x)Gamma(x)+pi*Psi^2(x)"
     WIDTH=251 height=37 src="https://www.nhplace.com/kent/Papers/gamma-psi-exp-tr.gif">
</p>

<p>
To avoid the expense of recomputing the 
<img alt="Psi" WIDTH=21 height=19 src="https://www.nhplace.com/kent/Papers/psi-tr.gif">
and
<img alt="Gamma" WIDTH=21 height=19 src="https://www.nhplace.com/kent/Papers/gamma-tr.gif">
functions, we might wish to employ <tt>LAMBDA</tt> variables
to store the result of the calls.  In primitive Lisp code, this would
look like

<blockquote>
<pre>
((LAMBDA (G P)
         (+ (* (+ G P) G)
            (* 3.14159265 P P)))
 (GAMMA X)
 (PSI X))
</pre>
</blockquote>

<p>
As the size of the <tt>LAMBDA</tt>'s body increases, however, the formal and
actual parameters are pushed father and farther apart due to the nature of
this syntax.  Hence we would like some way of laying
things out so that they are easy to read and yet can be recognized by the 
evaluator as ``just another way of specifying a <tt>LAMBDA</tt> combination.''
The following syntax, for example, might express the same meaning as 
our previous <tt>LAMBDA</tt> combination:
</p>

<blockquote>
<pre>
(LET ((G (GAMMA X)) (P (PSI X)))
     (+ (* (+ G P) G)
        (* 3.14159265 P P)))
</pre>
</blockquote>

<h3>ENVIRONMENT: Delaying Evaluation</h3>

<p>
Another use of special forms arises in the case where we have a
function and would like its arguments evaluated--but not immediately.
We might first wish to create some sort of special environment for the
evaluation.
</p>

<p>
Consider the case of a Lisp which supports arbitrary handlers for
interrupts received from the terminal or the operating system.  If an
interrupt is received, the Lisp suspends any work currently executing
and passes control to the handler.  Upon return from the handler, the
suspended computation is resumed from the point where it was
executing prior to the interrupt.  Given an environment in which code
may be expected to be interrupted at any point, it may become necessary
to protect certain pieces of critical code which if suspended at a
wrong point would leave the environment in an inconsistent state.
</p>

<p>
Suppose that 
there exists some reserved variable named <tt>DEFER-INTERRUPTS</tt>
which will be checked by the Lisp when an interrupt is received and,
if bound to a non-null value, will cause the Lisp to queue that
interrupt for processing at a later time when the scope of that 
binding has been popped.  Almost invariably, we would want to bind this value
to T, run some code, and then unbind it.  It might be useful, therefore,
to give the user a primitive with syntax such as
</p>

<blockquote>
<pre>
(WITHOUT-INTERRUPTS <i>form1</i> <i>form2</i> ...),
</pre>
</blockquote>

<p>
which would behave just like <tt>PROGN</tt>, except that the evaluation
of the list of <i>forms</i> would be delayed long enough to establish
an environment in which interrupt-handling would be inhibited.  This is
equivalent in practice to saying
</p>

<blockquote>
<pre>
((LAMBDA (DEFER-INTERRUPTS)
          <i>form1</i> <i>form2</i> ...)
 T)
</pre>
</blockquote>

<p>
but it is more than the mere cosmetic change: By using the 
<tt>WITHOUT-INTERRUPTS</tt> construct, the user has freed himself
of the need to know how or where the interrupt-inhibiting flag is actually
stored.  It may be <i>possible</i> for him to obtain this information, 
but it is not <i>necessary</i>.
</p>

<h3>ABSTRACTION: A tool for modularity</h3>

<p>
The examples we have seen with <tt>LET</tt> and <tt>WITHOUT-INTERRUPTS</tt>
illustrate another motivation for the use of special forms: abstraction.
It may be that we don't <i>care</i> that <tt>LET</tt> is implemented via
a <tt>LAMBDA</tt> or that <tt>WITHOUT-INTERRUPTS</tt> is going to bind a 
magic variable.  We can abstract out a higher purpose for the form,
and as long as it accomplishes that high-level purpose, the details of its 
implementation can be left to vary as changes are introduced to the 
language or programming environment.
</p>

<h3>FLOW OF CONTROL: Conditional Evaluation</h3>

<p>
Special forms may also be desirable to affect flow of control.
Lisp built-in operators such as <tt>PROG</tt> and <tt>COND</tt>
fall into this category.  Suppose we would like to allow new, user-defined
control structures.
</p>

<p>
A simple example of this would be the creation of an <tt>IF</tt> special
form which had the same effect as a simple <tt>COND</tt>.  We might
want the <tt>IF</tt> to have the syntax
</p>

<blockquote>
<pre>
(IF <i>antecedent</i> <i>consequent</i> <i>alternative</i>)
</pre>
</blockquote>

<p>
which would have the same meaning as
</p>

<blockquote>
<pre>
(COND (<i>antecedent</i> <i>consequent</i>)
      (T <i>alternative</i>))
</pre>
</blockquote>

<p>
<A NAME="RETURN-POINT-3">In</a>
this example, we can see that not only must one of the arguments (the 
<i>antecedent</i>) be evaluated before the other arguments, but one of
the two other arguments will not be evaluated at all.  Here a normal
Lisp <tt>EXPR</tt> <a href="Special-Forms.html#FOOTNOTE-3">[3]</a> description such as
</p>

<blockquote>
<pre>
(DEFUN IF (CONDITION T-VAL NIL-VAL)
       (COND (CONDITION T-VAL)
             (T NIL-VAL)))
</pre>
</blockquote>

<p>
<i>is clearly wrong</i> because the user may wish to write code which
depends on being executed if and only if  <i>antecedent</i> is true.
Using the <tt>EXPR</tt> definition, code such as
</p>

<blockquote>
<pre>
(IF (ATOM X) X (CAR X))
</pre>
</blockquote>

<p>
which <i>depends</i> on <tt>(CAR X)</tt> not being evaluated if the value
of <tt>X</tt> turns out to be an atom, would be unable to run.
</p>
<p>
One might propose, then, that the expression
</p>

<blockquote>
<pre>
(IF (ATOM X) 'X '(CAR X))
</pre>
</blockquote>

<p>
is what we want, since neither the <i>consequent</i> nor the <i>alternative</i>
is executed in the original function call.  A definition of this <tt>IF</tt>
might look like
</p>

<blockquote>
<pre>
(DEFUN IF (CONDITION T-VAL NIL-VAL)
       (COND (CONDITION (EVAL T-VAL))
             (T (EVAL NIL-VAL))))
</pre>
</blockquote>

<p>
This is also inadequate, however, because of the scoping problem.
Most Lisps <FONT color="green">[in 1980]</FONT> 
are <b>dynamically scoped</B>--<i>i.e.</i>, the scoping 
of variables is determined by the dynamic, or runtime, environment
rather than by the lexically apparent environment in which they were
defined.  The following simple example should illustrate why this second
alternative to the <tt>IF</tt> problem will not work:
</p>

<blockquote>
<pre>
(SETQ T-VAL 0 NIL-VAL 1)
<img src="https://www.nhplace.com/kent/Papers/arrow-tr.gif" alt="=&gt;" WIDTH=12 height=12> 1
(IF T 'T-VAL 'NIL-VAL)
<img src="https://www.nhplace.com/kent/Papers/arrow-tr.gif" alt="=&gt;" WIDTH=12 height=12> T-VAL
</pre>
</blockquote>

<p>
The symbol <tt>T-VAL</tt> is returned, rather than 0, because at the time 
of the call to <tt>EVAL</tt>, <tt>T-VAL</tt> has been locally bound.
</p>


<blockquote>
<FONT color="green">
<p>
[Users of the <tt>SCHEME</tt> language might assume that the
solution of
</p>

<blockquote>
<pre>
(IF <i>antecedent</i>
    (LAMBDA () <i>consequent</i>)
    (LAMBDA () <i>alternative</i>))
</pre>
</blockquote>

<p>
would immediately present itself.  However, <tt>SCHEME</tt> was only 2 years old
at the time and did not have a very big following yet.  In fact, though
<tt>SCHEME</tt>'s idea of lexical scoping (which in turn derived from Algol's)
was used a few years later in Common Lisp (1984), even lexical scoping
was considered ``highly experimental'' by some in the Lisp community.
Those of us who believed lexical scoping safe pretty much had to force it
down some other people's throats.  So don't let ``20/20 hindsight'' allow
you to be confused into thinking that such a solution was obvious.  And,
in any case, even the <tt>SCHEME</tt> community doesn't think the solution to the
``<tt>IF</tt> problem'' is to have a function named <tt>IF</tt> that always 
takes closures as arguments.  So the global point being made by the paper
here is still true--that special forms are useful in controlling 
evaluation--is still true:  <tt>SCHEME</tt> does use functions and closures a lot where 
Common Lisp uses special syntax, but <tt>SCHEME</tt> <i>could</i> use functions and
closures more than it does, and chooses not to. <tt>IF</tt> itself does not
<i>need</i> to be a piece of primitive <tt>SCHEME</tt> syntax--it's offered that way
because it's syntactically convenient to do so.  In other words, the key
point being made here is not that special syntax is <i>needed</i> to do
conditional evaluation, but that special syntax allows and is routinely used
for this purpose.]
</p>
</FONT>
</blockquote>


<p>
<tt>QUOTE</tt>'ing code will also confuse the compiler,
since it will not realize that the objects are really to be
used as program text rather than as quoted list structure.
This will be discussed in more detail later.
</p>

<p>
It is also not adequate to use <tt>GENSYM</tt>'s as variable names in 
our definition because <tt>GENSYM</tt>'s are not visually distinguishable
from interned atoms with the same printname.  <FONT color="green">[This
also later changed slightly in Common Lisp (1984) with the introduction
of the ``<tt>#:</tt>'' syntax.]</FONT>  Hence, since Lisp's <tt>READ</tt>
works by analyzing  printed representation and creating interned symbols,
such a definition would work in the environment in which it was created,
but if saved via <tt>PRINT</tt> would not be functionally equivalent
upon reloading since all the symbols which were originally <tt>GENSYM</tt>'s
would now be interned.
</p>

<blockquote>
<FONT color="green">
<p>
[At the time, especially in 
the <tt>INTERLISP</tt> and somewhat also in <tt>MACLISP</tt>,
it was popular to spend a Lisp session typing expressions <tt>first</tt> 
to Lisp and only
later printing and saving them.  In more recent environments, it's more
common to see code typed to a text editor and saved independently, so this
role of <tt>PRINT</tt> has become deemphasized over time.]
</p>
</FONT>
</blockquote>

<p>
We are clearly going to a lot of work to guarantee the semantics of 
our proposed <tt>IF</tt> definition.  It will be shown in the next section
that there is a simple and elegant way of dealing with this problem 
which avoids these issues of quoting, invalid evaluation contexts, and
printed representation.  Something more powerful is required or the user
will have to resign himself to using <tt>COND</tt> or some other 
already-built-in special form for the rest of his life whenever he wants
to express the notion of conditional evaluation or flow of control.
</p>

<h3>SCOPE: Pointers and Side-Effects</h3>

<p>
Special forms can also achieve a very powerful type of <i>call by name</i>
functionality which affects the scope of variables.  For example, <tt>MACLISP</tt>
offers a very powerful primitive called <tt>SETF</tt> which acts as a sort
of generalized <tt>SETQ</tt>.  It allows the syntax
</p>

<blockquote>
<pre>
(SETF <i>form</i> <i>value</i>)
</pre>
</blockquote>

<p>
where if <i>form</i> is a symbol, it will be assigned as if <tt>SETQ</tt>
had been used, but if <i>form</i> is not a symbol, an appropriate side-effect
producing operation is selected to do the assignment.  An illustration will
make the functionality clearer:
</p>

<blockquote>
<pre>
(SETF (CAR <i>form</i>) <i>value</i>)
 <img src="https://www.nhplace.com/kent/Papers/arrow2-tr.gif" alt="&lt;=&gt;" WIDTH=12 height=12> (RPLACA <i>form</i> <i>value</i>)
(SETF (CADR <i>form</i>) <i>value</i>)
 <img src="https://www.nhplace.com/kent/Papers/arrow2-tr.gif" alt="&lt;=&gt;" WIDTH=12 height=12> (RPLACA (CDR <i>form</i>) <i>value</i>)
(SETF (NTH <i>index</i> <i>form</i>) <i>value</i>)
 <img src="https://www.nhplace.com/kent/Papers/arrow2-tr.gif" alt="&lt;=&gt;" WIDTH=12 height=12> (RPLACA (NTHCDR <i>index</i> <i>form</i>) <i>value</i>)
(SETF (PLIST <i>form</i>) <i>plist</i>)
 <img src="https://www.nhplace.com/kent/Papers/arrow2-tr.gif" alt="&lt;=&gt;" WIDTH=12 height=12> (SETPLIST <i>form</i> <i>plist</i>)
</pre>
</blockquote>

<p>
As with some of our previous examples, it simply is not possible for a normal
<tt>EXPR</tt>
function to achieve the desired effect while retaining this simple syntax.
Such expressiveness may be gained only through the use of special forms.
</p>

<h3>VARIABLE NUMBER OF ARGUMENTS</h3>

<p>
It may also be the case that there exists some function which is so often
used in composition with itself, that we may wish to construct an n-ary 
version of that function which behaves as if it were a composition of the
more primitive operator.  The earliest Lisps did not have facilities for 
defining functions of a variable number of arguments, so the need 
was more critical then than now.  However, for some applications, it may
still be desirable in a modern Lisp dialect to implement functions 
such as these as special forms.
</p>

<p> 
<A NAME="RETURN-POINT-4"><tt>MACLISP</tt></a>
and <tt>LISPMACHINE</tt> Lisp offer an operator named <tt>LIST*</tt>
which may be
thought of conceptually as being like a <tt>CONS</tt> function but allowing
a variable number of arguments.  In a Lisp dialect which did not have a 
primitive <tt>LIST*</tt> function, one might consider implementing the 
operation via a special form <a href="Special-Forms.html#FOOTNOTE-4">[4]</a>. <i>e.g.</i>,
</p>

<blockquote>
<pre>
(LIST* <i>form</i>)
 <img src="https://www.nhplace.com/kent/Papers/arrow2-tr.gif" alt="&lt;=&gt;" WIDTH=12 height=12> <i>form</i>
(LIST* <i>form1</i> <i>form2</i>)
 <img src="https://www.nhplace.com/kent/Papers/arrow2-tr.gif" alt="&lt;=&gt;" WIDTH=12 height=12> (CONS <i>form1</i> <i>form2</i>)
(LIST* <i>form1</i> <i>form2</i> <i>form3</i>)
 <img src="https://www.nhplace.com/kent/Papers/arrow2-tr.gif" alt="&lt;=&gt;" WIDTH=12 height=12> (CONS <i>form1</i> (CONS <i>form2</i> <i>form3</i>))
(LIST* <i>form1</i> <i>form2</i> ... <i>formN</i>)
 <img src="https://www.nhplace.com/kent/Papers/arrow2-tr.gif" alt="&lt;=&gt;" WIDTH=12 height=12> (CONS <i>form1</i> (LIST* <i>form2</i> ... <i>formN</i>))
</pre>
</blockquote>

<h3>EFFICIENCY: User-Tailored Optimization</h3>

<p>
In Lisp and other languages, there may be a desire to achieve a sense
of modularity without sacrificing efficiency.  A problem which results
from always doing function calling is that one may 
desire for the sake of style to separate out an operation and give it a name.
If the operation itself requires less code than the call to that function,
inefficiency will result.
</p>

<p>
For example, one may wish to speak in abstract terms, referring to 
<tt>NODE-NAME</tt> and <tt>NODE-DATA</tt> rather than <tt>CAR</tt>
and <tt>CDR</tt> for some application.  For example, creating the definitions
</p>  

<blockquote>
<pre>
(DEFUN NODE-NAME (X) (CAR X))
(DEFUN NODE-DATA (X) (CDR X))
</pre>
</blockquote>

<p>
and then substituting calls to these functions for calls to <tt>CAR</tt>
and <tt>CDR</tt> as appropriate, would result in a
great slowdown due to the indirection through a second function call.
What we would like is some way of specifying simple functional
equivalences without introducing a large amount of extra overhead
in terms of stack space and wasted instructions at execution time.
</p>

<H2 ALIGN=CENTER>Describing Special Forms</h2>

<p>
It should be clear, then, that special forms are useful in a wide variety
of circumstances.  The expressiveness which they offer can add much to the
clarity of an individual's coding style.  We can now approach the issue 
of how the definition of a special form should be specified.
</p>

<p>
<A NAME="RETURN-POINT-5">One</a>
solution would be for the semantics of special forms to be described
in some other language (<i>e.g.</i>, Midas <a href="Special-Forms.html#FOOTNOTE-5">[5]</a>).
Such a solution, however, does not facilitate user extension of the language.
It requires that a user of Lisp also be a user of whatever language his Lisp
is implemented in terms of.  It also makes for difficulty in terms of 
compilation--an issue which will be discussed in more detail later--because
the compiler must have a great deal of special-case code to deal with 
information about the compilation of each special form.
</p>

<p>
The obvious solution for a language such as Lisp, in which program
and data enjoy the same representation, is that special forms should
be specified in the language itself.  Unfortunately, the precise
manner in which the specification can be achieved is less obvious.
Several competing schemes for expressing the functionality of special
forms have been devised and implemented in the major Lisp dialects.
This section will present a brief overview of the essential features 
of those schemes.
</p>

<h3>FEXPR's</h3>

<p>
The syntax for specifying a <tt>FEXPR</tt> in <tt>MACLISP</tt> is:
</p>

<blockquote>
<pre>
(DEFUN <i>name</i> FEXPR (<i>variable</i>) . <i>body</i>)
</pre>
</blockquote>

<p>
Like a normal, <tt>EXPR</tt>-style <tt>DEFUN</tt>, this form associates
with the variable <i>name</i> a <tt>LAMBDA</tt> expression which
is constructed from information supplied by a <b>bound variable list</B>--in
this case, the one-length list containing <i>variable</i>--and a <b>body</B>.
The thing which makes <tt>FEXPR</tt>'s special is that additional 
information is stored with the symbol indicating that when the name
occurs as the operator in a form, no evaluation is to be done on any
part of the <tt>CDR</tt> of that form.  Instead, the entire <tt>CDR</tt>
is to be bound to <i>variable</i>, and then <i>body</i> is to be executed
according to the normal rules for evaluating the body of a <tt>LAMBDA</tt>
expression.  The value returned by the application of the <tt>FEXPR</tt>
definition to the <tt>CDR</tt> of the form is the value which is
returned by the <tt>FEXPR</tt>-form.
</p>

<p>
Using <tt>FEXPR</tt>'s to define our <tt>DESCRIBE</tt> example from before,
one might say
</p>

<blockquote>
<pre>
(DEFUN DESCRIBE FEXPR (TOPIC-INFO)
       (PRINC (LOOKUP-DOCUMENTATION
               (CAR TOPIC-INFO))))
</pre>
</blockquote>

<p>
and thereafter be able to invoke <tt>DESCRIBE</tt> with the syntax
<tt>(DESCRIBE <i>keyword</i>)</tt>--no quoting needed.
</p>

<blockquote>
<FONT color="green">
<p>
[Note: The reference to keyword here was not related to Common Lisp keywords.
 <tt>MACLISP</tt> had no keywords in that sense, nor in fact did it even have packages.
 This reference to a keyword was just about avoiding the
 quote in <tt>(DESCRIBE 'SOMETHING)</tt>.]
</p>
</FONT>
</blockquote>
</p>

<h3>NLAMBDA's</h3>

<p>
<tt>INTERLISP</tt> offers something similar to <tt>FEXPR</tt>'s with 
its <tt>NLAMBDA</tt> facility.  The essential notion here is that the
functional description itself should have information associated with it saying
whether or not the arguments to that function should be evaluated.
<tt>LAMBDA</tt> combinations involve the evaluation of each element in the
argument specification list prior to functional application, while
<tt>NLAMBDA</tt> combinations do not. <i>e.g.</i>,

<blockquote>
<pre>
(SETQ A 1 B 2 C 3)
 <img src="https://www.nhplace.com/kent/Papers/arrow-tr.gif" alt="=&gt;" WIDTH=12 height=12> 3
((LAMBDA (X Y Z) (LIST X Y Z)) A B C)
 <img src="https://www.nhplace.com/kent/Papers/arrow-tr.gif" alt="=&gt;" WIDTH=12 height=12> (1 2 3)
((NLAMBDA (X Y Z) (LIST X Y Z)) A B C)
 <img src="https://www.nhplace.com/kent/Papers/arrow-tr.gif" alt="=&gt;" WIDTH=12 height=12> (A B C)
</pre>
</blockquote>

<p>
<tt>LISPMACHINE</tt> Lisp offers a slightly more generalized syntax for achieving
this end via their ``<tt>&amp;QUOTE</tt>'' mechanism, which allows a marker
to be placed in the bound variable list of the function
saying which of the actual parameters should not be evaluated before 
application of the definition.
</p>

<h3>MACRO's</h3>

<p>
<tt>MACRO</tt>'s offer a way of defining a mapping between a special
form and an evaluable form--a transformation, written in the normal
primtiives of the language, between pieces of code.  These may be
either transformations between a macro form and a piece of evaluable
structure or between one macro form and another macro form.
</p>

<p>
<A NAME="RETURN-POINT-6">The</a>
Lisp interpreter handles <tt>MACRO</tt> forms much differently than 
it handles other types of forms <a href="Special-Forms.html#FOOTNOTE-6">[6]</a>.
When a form is encountered, 
the <tt>CAR</tt> of which is defined as a <tt>MACRO</tt>,
the <b>macro definition</B> (itself a function of one 
argument) is called with an argument which is the entire, unevaluated
macro form and the value returned by the macro definition  is then
evaluated to produce a value which will be returned as the value of the
<tt>MACRO</tt> form.
</p>

<p>
<tt>MACRO</tt>'s have the syntax
</p>

<blockquote>
<pre>
(DEFUN <i>name</i> MACRO (<i>variable</i>) . <i>body</i>)
</pre>
</blockquote>

<p>
A <tt>MACRO</tt> definition of our <tt>DESCRIBE</tt> special form
might look like this:
</p>

<blockquote>
<pre>
(DEFUN DESCRIBE MACRO (X)
       (LIST 'PRINC
             (LIST 'LOOKUP-DOCUMENTATION
                   (LIST 'QUOTE (CADR X)))))
</pre>
</blockquote>

<p>
or, perhaps, like this:
</p>

<blockquote>
<pre>
(DEFUN DESCRIBE MACRO (FORM)
       (SUBLIS (LIST (CONS 'X (CADR FORM)))
          '(PRINC (LOOKUP-DOCUMENTATION 'X))))
</pre>
</blockquote>

<p>
Lest the reader feel that this syntax is overly clumsy,
it should be noted that we are oversimplifying things here 
for the sake of clarity.  <tt>MACLISP</tt> and <tt>LISPMACHINE</tt> Lisp, employing the 
<tt>MACRO</tt> technology ideas advocated in this paper, allow the following
alternate syntax for <tt>DESCRIBE</tt>'s definition as a macro:
</p>

<blockquote>
<pre>
(DEFUN DESCRIBE MACRO (X)
   `(PRINC (LOOKUP-DOCUMENTATION ',(CADR X))))
</pre>
</blockquote>

<p>
How the <b>read macro characters</B> backquote and comma in this example
are defined is of tremendous importance, but is beyond the scope of this
paper.  The important fact is that it would be naive to condemn 
<tt>MACRO</tt>'s as overly complicated for practical use on the basis of
the difficulty involved in writing the long-form definition.
</p>

<blockquote>
<FONT color="green">
<p>
[Note also that by this time the more modern <tt>DEFMACRO</tt> syntax 
 later adopted by Common Lisp (1984), involving
 a multi-variable argument list with ``<tt>&amp;OPTIONAL</tt>'' 
 and ``<tt>&amp;REST</tt>'' and other lambda list keywords, was already 
 available even at the time this paper was written.  I knew and used that
 syntax at the time, but in consultation with others as I prepared the paper,
 it was decided that the new syntax was too complicated to present.
 As aesthetically painful
 as it is now to read the old-style <tt>MACRO</tt> definition syntax using a
 single <i>form</i> argument, it was really quite ordinary-looking at the time,
 and since many people hadn't seen macro definitions at all, I and my 
 paper's reviewers wanted to keep the paper simple by demonstrating only
 the minimal technology needed to illustrate the point.]
</p>
</FONT>
</blockquote>

<H2 ALIGN=CENTER>Advantages and Disadvantages</h2>

<h3>Definitional Consistency</h3>

<p>
In <tt>MACLISP</tt>, all operator definitions are of effectively the same
type--<tt>LAMBDA</tt> expressions.  The difference between them is where
the definition is stored.  For example,
</p>

<blockquote>
<pre>
(DEFUN <i>name</i> <i>bvl</i> . <i>body</i>)
 <img src="https://www.nhplace.com/kent/Papers/arrow2-tr.gif" alt="&lt;=&gt;" WIDTH=12 height=12> (DEFPROP <i>name</i> (LAMBDA <i>bvl</i> . <i>body</i>) EXPR)
(DEFUN <i>name</i> FEXPR <i>bvl</i> . <i>body</i>)
 <img src="https://www.nhplace.com/kent/Papers/arrow2-tr.gif" alt="&lt;=&gt;" WIDTH=12 height=12> (DEFPROP <i>name</i> (LAMBDA <i>bvl</i> . <i>body</i>) FEXPR)
(DEFUN <i>name</i> MACRO <i>bvl</i> . <i>body</i>)
 <img src="https://www.nhplace.com/kent/Papers/arrow2-tr.gif" alt="&lt;=&gt;" WIDTH=12 height=12> (DEFPROP <i>name</i> (LAMBDA <i>bvl</i> . <i>body</i>) MACRO)
</pre>
</blockquote>

<p>
What is interesting here is not the names of the properties in which
the expressions are stored--nor even the fact that the information is
stored on the property list at all.  The important thing is that all
definitions are simple <tt>LAMBDA</tt> expressions.  What has been
done is to associate information with the symbol, <i>name</i>,
describing any special treatment that is to be given its form before
and after the application of the definition--but the function which is
applied is just a garden variety function with no special information
information attached to it.
</p>

<p>
Suppose, for example, that there exists some <tt>FEXPR</tt> named <tt>FEX</tt>
which performs some useful function but which, because it is a <tt>FEXPR</tt>,
is very cumbersome to use--requiring that <tt>APPLY</tt> always be used
to call it in order to force the effect of argument evaluation.
In <tt>MACLISP</tt>, because of the general nature of functional
descriptions, it would be possible to borrow <tt>FEX</tt>'s definition for
a normal function, <tt>EX</tt>, by saying
</p>

<blockquote>
<pre>
(PUTPROP 'EX (GET 'FEX 'FEXPR) 'EXPR)
</pre>
</blockquote>

<p>
Having done so, the following equivalences would be true:
</p>

<blockquote>
<pre>
(FEX X Y Z)
 <img src="https://www.nhplace.com/kent/Papers/arrow2-tr.gif" alt="&lt;=&gt;" WIDTH=12 height=12> (EX '(X Y Z))
(APPLY 'FEX (LIST A B C))
 <img src="https://www.nhplace.com/kent/Papers/arrow2-tr.gif" alt="&lt;=&gt;" WIDTH=12 height=12> (EX (LIST A B C))
</pre>
</blockquote>

<p>
<A NAME="RETURN-POINT-7">In</a>
other words, the definition does exactly one thing.  It describes 
what to do with a set of formal parameters.  It puts
no restrictions on the process of how those formal parameters
are to become associated with their values <a href="Special-Forms.html#FOOTNOTE-7">[7]</a>.
Such a decision is left to the evaluator.  We shall see another very useful
example of this in a later section when we look in more detail at 
<tt>MACRO</tt>'s and macro expansion.
</p>

<p>
In <tt>INTERLISP</tt> and <tt>LISPMACHINE</tt> Lisp, which allow the use of <tt>NLAMBDA</tt>
style constructs, this is not the case.
Function descriptions attempt to enforce a specific type of evaluation of actual parameters.
In such a case, functional information is tightly coupled
with evaluation information and more difficult to separate.
It is the opinion of the author that performing this association is 
highly inappropriate and should be avoided.
<tt>LAMBDA</tt> definitions should remain trivially separable from argument
evaluation information.
This separation provides not only for a more elegant theory,
but is also more useful in practice, since in most practical cases
evaluation and functionality are most usefully varied independently of each
other.
</p>

<h3>Features of FEXPR's</h3>

<p>
<A NAME="RETURN-POINT-8">One</a>
advantage of <tt>FEXPR</tt>'s is that they are <b>applicable</B>
<a href="Special-Forms.html#FOOTNOTE-8">[8]</a>.
</p>

<blockquote>
<pre>
(APPLY <i>f</i> <i>form</i>)
</pre>
</blockquote>

<p>
where <i>f</i> is a <tt>FEXPR</tt>, is defined to look up the
definition of <i>f</i> and bind to its single 
<img height=12 WIDTH=12 src="https://www.nhplace.com/kent/Papers/lambda-tr.gif" alt="lambda">-variable, the
object which is the result of evaluating <i>form</i>.
Hence, if <tt>DESCRIBE</tt> had been defined to be a <tt>FEXPR</tt> and
we later realized that we wanted to hand it the value of some variable
rather than a constant token, we could still get the desired functionality
by saying
</p>

<blockquote>
<pre>
(APPLY 'DESCRIBE (LIST TOPIC))
</pre>
</blockquote>

<p>
<A NAME="RETURN-POINT-9">Another</a>
advantage of <tt>FEXPR</tt>'s is that they are easily supported  by
a Lisp <tt>TRACE</tt> facility.  Using <tt>TRACE</tt> with our 
<tt>DESCRIBE</tt> operator might produce the following 
<a href="Special-Forms.html#FOOTNOTE-9">[9]</a>:
</p>

<blockquote>
<pre>
(TRACE DESCRIBE)
 <img src="https://www.nhplace.com/kent/Papers/arrow-tr.gif" alt="=&gt;" WIDTH=12 height=12> (DESCRIBE)
(DESCRIBE CAR)
 (1. ENTER DESCRIBE (CAR))
CAR returns the 1st element of a list.
 (1. EXIT DESCRIBE T)
 <img src="https://www.nhplace.com/kent/Papers/arrow-tr.gif" alt="=&gt;" WIDTH=12 height=12> T
</pre>
</blockquote>

<p>
Debuggers that single-step the operation of <tt>FEXPR</tt>'s are similarly
trivial to write.
</p>

<h3>Features of MACRO's</h3>

<p>
Perhaps the most important reason why <tt>MACRO</tt>'s are important is that
they offer <b>transparency of functionality</B>.  It is possible, without
evaluating the macro form, to determine what the form will do in 
terms of primitive Lisp operations.  This is true because the 
macro definition need not be invoked only by the evaluator.
</p>

<p>
An interesting problem that one might face in writing programs 
that treat other programs as pieces of data is the desire to 
substitute some expression, <i>new</i>, for all evaluable occurrences
of some other expression, <i>old</i>, in some third expression, <i>form</i>.
It is not sufficient to use <tt>SUBST</tt> bevcause it may be that <i>form</i>
contains some occurrences of <i>old</i> in positions which are not evaluable
and for certain applications one would not want the substitution routine
to enter forms which were not to be evaluated.  For example,
</p>

<blockquote>
<pre>
(SUBST 'B 'A '(LAMBDA (A) (LIST 'A A)))
 <img src="https://www.nhplace.com/kent/Papers/arrow-tr.gif" alt="=&gt;" WIDTH=12 height=12> (LAMBDA (B) (LIST 'B B))
</pre>
</blockquote>

<p>
If the desired outcome had been
</p>

<blockquote>
<pre>
(LAMBDA (B) (LIST 'A B))
</pre>
</blockquote>

<p>
then <tt>SUBST</tt> would be inadequate.
</p>
<p>
One could imagine, therefore, writing a program, <tt>SMART-SUBST</tt>
which knew about all the primitive special forms in Lisp and how 
to deal with them.  Such a function could be made not to 
recurse inward upon encounter of a <tt>QUOTE</tt>-form.  But a problem
arises if a user-defined special form is encountered.  We would 
certainly want our program to understand and deal correctly with 
special forms and their particular semantics.  Now suppose we try our
<tt>SMART-SUBST</tt> on an expression which involves a user-defined <tt>IF</tt>
special form, as in
</p>

<blockquote>
<pre>
(SMART-SUBST 'B 'A '(LAMBDA (A) (IF A 'YES 'NO)))
</pre>
</blockquote>

<p>
A major drawback to the use of <tt>FEXPR</tt>'s is that there is no reliable
mechanism for determining which, if any, of the objects in the argument
position will in fact be evaluated at some point in the future.  Our 
<tt>SMART-SUBST</tt> program would have to infer here that <tt>A</tt>
was not to be evaluated and the return value would be
</p>

<blockquote>
<pre>
(LAMBDA (B) (IF A 'YES 'NO))
</pre>
</blockquote>

<p>
If on the other hand, we used the <tt>MACRO</tt> definition
</p>

<blockquote>
<pre>
(DEFUN IF MACRO (X)
       (LIST 'COND
             (LIST (CADR X) (CADDR X))
             (LIST 'T (CADDDR X)))),
</pre>
</blockquote>

<p>
we could define the following useful helping function
</p>

<blockquote>
<pre>
(DEFUN MACROEXPAND (X)
  (LET ((MACRO-DEFINITION (GET (CAR X) 'MACRO)))
       (COND (MACRO-DEFINITION
                 (FUNCALL MACRO-DEFINITION X))
             (T X))))
</pre>
</blockquote>

<p>
and pass the <tt>IF</tt>-form to <tt>MACROEXPAND</tt>.  The return value
would be a <tt>COND</tt>-form, which <tt>SMART-SUBST</tt> would presumably
know how to deal with since <tt>COND</tt> is a primitive special form.
</p>

<blockquote>
<pre>
(SMART-SUBST 'B 'A
             '(LAMBDA (A) (IF A 'YES 'NO)))

</pre>
</blockquote>

<blockquote>
<FONT color="green">
<p>
[The original paper doesn't say, but the return value intended is presumably:
</p>

<blockquote>
<pre>
 <img src="https://www.nhplace.com/kent/Papers/arrow-tr.gif" alt="=&gt;" WIDTH=12 height=12> (LAMBDA (B) (COND (B 'YES) (T 'NO)))
</pre>
</blockquote>

<p>
]
</p>
</FONT>
</blockquote>

<p>
An interesting feature of <tt>MACRO</tt>'s is their ability to run efficiently
in the interpreter.  Consider the definitions:
</p>

<blockquote>
<pre>
(DEFUN FIRST MACRO (X) (CONS 'CAR (CDR X)))
(DEFUN PRINT-FIRST (X) (PRINT (FIRST X)))
</pre>
</blockquote>

<p>
Each time a call to <tt>(PRINT-FIRST <i>expression</i>)</tt> is executed,
the computation of a transformation between <tt>(FIRST X)</tt> and 
<tt>(CAR X)</tt> would have to be recomputed.  For the case of interpreted
code, one might as well have defined <tt>FIRST</tt> by just
</p>

<blockquote>
<pre>
(DEFUN FIRST (X) (CAR X))
</pre>
</blockquote>

<p>
However, a trivial alteration to our macro definition will cause a large
speedup in time:
</p>

<blockquote>
<pre>
(DEFUN FIRST MACRO (X) (RPLACA X 'CAR) X)
</pre>
</blockquote>

<p>
<A NAME="RETURN-POINT-10">Note</a>
how upon the first call to <tt>PRINT-FIRST</tt>, 
the form <tt>(FIRST X)</tt> will be side-effected upon 
so that it is now just <tt>(CAR X)</tt>.  This means a later call to 
<tt>PRINT-FIRST</tt> will not invoke the macro at all, since the
definition of <tt>PRINT-FIRST</tt> has been altered in a way that
destroys any reference to the original call.  Note that this
sort of destructive effect may not be desirable if the code is being
debugged, but it is available in a flexible way--the user has 
the option of selecting it or not, as he desires 
<a href="Special-Forms.html#FOOTNOTE-10">[10]</a>.
</p>

<p>
<tt>MACRO</tt>'s have the unfortunate feature of being harder to trace
with conventional Lisp <tt>TRACE</tt> and single-stepping packages.
The reason for this is that what gets traced is the expansion, not the
execution of the expansion.  For example, if we trace our macro 
definition of <tt>DESCRIBE</tt> from the previous
section, we observe the following:
</p>

<blockquote>
<pre>
(TRACE DESCRIBE)
 <img src="https://www.nhplace.com/kent/Papers/arrow-tr.gif" alt="=&gt;" WIDTH=12 height=12> (DESCRIBE)
(DESCRIBE CAR)
 (1. ENTER DESCRIBE (DESCRIBE CAR))
 (1. EXIT DESCRIBE
     (PRINC (LOOKUP-DOCUMENTATION (QUOTE CAR))))
CAR returns the 1st element of a list.
 <img src="https://www.nhplace.com/kent/Papers/arrow-tr.gif" alt="=&gt;" WIDTH=12 height=12> T
</pre>
</blockquote>

<p>
This may or may not have been the desired result.  In some cases 
it is useful to see the expansion traced, while in others it is more useful 
to see a trace of the functionality of the form (<i>i.e.</i>, the sort of
thing we observed on entry to the <tt>DESCRIBE</tt> <tt>FEXPR</tt> earlier).

<h2>Compilation--Where FEXPR's Really Hurt</h2>

<h3>The Compiler's Contract</h3>

<p>
The question of whether to use <tt>FEXPR</tt>'s or <tt>MACRO</tt>'s to solve
a particular problem may seem purely an issue of style.  However, with the 
introduction of the concept of compilation, it becomes much more clear that
<tt>FEXPR</tt>'s and <tt>NLAMBDA</tt>'s are not only inadequate for handling
all of these cases correctly, but <i>actually make it impossible for</i> 
<tt>MACRO</tt><i>'s to do their job correctly in the general case</i>.
</p>

<p>
Compilation involves taking Lisp code and producing a sequence
of machine instructions which when executed will behave in a manner which
is functionally equivalent to that of the source program. 
Compilation is perhaps more well-defined in languages which do 
not support Lisp's powerful ``Program is Data--Data is Program''
feature.  In particular, it is not necessarily obvious what pieces
of a program may be ``compiled away'' and which must be 
retained in the interpreter-style format of list structure in order to
function correctly.
</p>

<blockquote>
<FONT color="green">
<p>
[In modern Lisps, such as Common Lisp, this issue no longer arises.
 Though never explicitly spoken about this way, I think the major shift is
 that when documentation and implementation did not agree in older Lisp
 dialects, the documentation was usually defined to be wrong and in need
 of repair.  Once in a while, the implementation didn't deliver what was
 promised, but more often than not, it was the other way around.
</p>

<p>
 In modern Lisps, when a dispute arises between documentation
 and implementation, the documentation is generally defined to be correct
 from the outset, and so it's the implementation that needs to be repaired 
 if a discrepancy between documentation and implementation arises.]
</p>
</FONT>
</blockquote>



<p>
<A NAME="RETURN-POINT-11">The</a>
job of the compiler <a href="Special-Forms.html#FOOTNOTE-11">[11]</a> is to
try to reduce Lisp code into a set of machine instructions which have 
equivalent functionality.  This may be harder than it sounds because to do this correctly
may require answers to questions which are not answerable by the compiler.
</p>

<p>
Consider the following sets of definitions:
</p>

<blockquote>
<pre>
(DEFUN F1 (X) (G1 X))
(DEFUN G1 (X) (+ X Y))

(DEFUN F2 (X) (G2 X))
(DEFUN G2 (Y) (+ Y X))
</pre>
</blockquote>

<p>
In the case of <tt>F1</tt>, there would be no loss of functionality 
for the compiler  to compile <tt>F1</tt> as simply a jump to <tt>G1</tt>,
without bothering to do any further binding.  It should be obvious,
however, that the compiler could not get away with just a jump to
<tt>G2</tt> from <tt>F2</tt>, despite the fact that their syntactic structure
is nearly identical.  This is called the problem of <b>special variables</B>
and is related to the issue of dynamic scoping which was addressed earlier.
Some <img height=12 WIDTH=12 src="https://www.nhplace.com/kent/Papers/lambda-tr.gif" alt="lambda">-variables 
are created just because it is necessary to have a name
to refer to a local variable while others are created for the purpose of 
communication between a given function and other functions which that
function calls.  Variables of the latter kind are called <tt>SPECIAL</tt>
and must be declared so in the <tt>MACLISP</tt> compiler in order to generate 
correct code.
</p>

<blockquote>
<FONT color="green">
<p>
[Note that in <tt>MACLISP</tt> there was not, as occurred in later dialects, 
 a language definition organized around the idea that ``interpreted semantics''
 and ``compiled semantics'' should be indistinguishable.  As a result,
 it was commonplace for certain code to ``only work in the compiler''.
 This misfeature of early Lisps is not present in more modern Lisps,
 such as Common Lisp, which have a semantics that is more uniform
 between interpreter and compiler.
</p>

<p>
Note further that <tt>MACLISP</tt> was defaultly dynamically scoped in the
interpreter, but was lexically scoped when compiled unless a <tt>SPECIAL</tt>
declaration was used to assure that the ``specialness'' of a variable was
preserved in compiled code.]
</p>
</FONT>
</blockquote>

<p>
The special variable problem is a good illustration of a whole class of
issues with which the compiler must deal in order to generate efficient code.
The Lisp compiler is constantly making decisions about what kind of machine
code would be an appropriate representation for a given specification
in normal Lisp notation.  Appropriate use of special forms may be able 
to greatly enhance the decision process as we shall see in this section.
</p>

<h3>Runtime Efficiency</h3>

<p>
In the compiler, <tt>MACRO</tt>'s are used to transform source code into 
compilable code which contains no <tt>MACRO</tt> forms.  Hence,
a <tt>MACRO</tt> definition can in some sense afford to use more time in its
transformation than any other type of operator can afford to do in 
similar case analysis at runtime.  This is because a macro form
will be expanded exactly once (at compile time) while any other type 
of operator may be called repeatedly at runtime and will have to make 
decisions anew each time it is called.
</p>

<p>
Since <tt>MACRO</tt>'s run in the compiler, there is no runtime overhead
in indirecting through their definition.  Additionally,
because the code into which a macro expands is placed inline at the point
of the macro call, rather than separated off by itself as occurs 
with functions, the compiler may be able to do very efficient coding
for any given usage of the macro.  If the operator had been an
applicable operator (<tt>EXPR</tt> or <tt>FEXPR</tt>, for example),
rather than a macro, the compiler might have to sacrifice efficiency
for generality, since it would not know what the actual intended 
use of the function was to be, and a less efficient compilation might result.
</p>

<p>
We should also keep in mind that functions have to be jumped to, macros
do not.
Very small functions may well spend more time in being called 
than in performing
the action for which they were called.  Function calling may 
involve shuffling accumulators into some standard configuration
or saving/restoring accumulators that may be clobbered in the call.
Rewriting short, frequently-called functions as macros may well provide an
increase in speed for this reason.
</p>

<h3>Space Efficiency</h3>

<p>
It has been argued that <tt>FEXPR</tt>'s are necessary to implement 
certain special forms because if the amount of code involved is large,
a <tt>FEXPR</tt>-style solution is apt to be more space-efficient
than one which employs <tt>MACRO</tt>'s.  The reason for supposing
this to be true is that every call to a <tt>MACRO</tt> will expand into that
large piece of code.
</p>

<p>
It is certainly possible to construct a <tt>MACRO</tt> definition which is
wasteful in this way, but if space limitation problems do arise, there is 
a standard formula for producing a macro which provides essentially the same functionality as any given <tt>FEXPR</tt>.
</p>

<blockquote>
<pre>
(DEFUN <i>f</i> FEXPR (<i>var</i>) . <i>body</i>)
</pre>

<TABLE>
<TR>
<TD WIDTH=50></TD>
<TD VALIGN=MIDDLE>
<img src="https://www.nhplace.com/kent/Papers/arrow-tr.gif" alt="=&gt;" WIDTH=12 height=12>
</TD>
<TD VALIGN=MIDDLE>
<img WIDTH=20 height=91 src="https://www.nhplace.com/kent/Papers/brace-tr.gif" alt="">
</TD>
<TD VALIGN=MIDDLE><pre>
(DEFUN <i>f</i> MACRO (FORM)
       (LIST 'EXPR-<i>f</i>
             (LIST 'QUOTE (CDR FORM))))

(DEFUN EXPR-<i>f</i> (<i>var</i>) . <i>body</i>)
</pre>
</TD>
</TR>
</TABLE>
</blockquote>

<p>
Having done this transformation, however, one will no longer be able 
to use the operator <tt>APPLY</tt> on <i>f</i>.  But since
the primary use of <tt>APPLY</tt> is to force evaluation of the <tt>FEXPR</tt>
arguments which would formerly not have evaluated, it would seem
reasonable to replace any calls to <tt>APPLY</tt> with direct references
to the function <tt>EXPR-</tt><i>f</i>.
</p>

<blockquote>
<pre>
(APPLY '<i>f</i> <i>expression</i>)

 <img src="https://www.nhplace.com/kent/Papers/arrow-tr.gif" alt="=&gt;" WIDTH=12 height=12>  (EXPR-<i>f</i> <i>expression</i>)
</pre>
</blockquote>

<p>
In other words, changing from <tt>FEXPR</tt>'s to <tt>MACRO</tt>'s cannot be
done by merely changing the definition;  some changes to source code may be 
necessary where operators like <tt>FUNCALL</tt> and <tt>APPLY</tt> have been
used.  But no major restructuring of the code is necessary.
</p>

<h3>Scope</h3>

<p>
<tt>MACRO</tt>'s are also powerful enough to provide extended scoping rules
that other types of function definitions cannot.  They can, for example, 
define a piece of code in terms of a variable which is local to another
operator without the use of special variables.  Consider the following
variation on our <tt>F1</tt>/<tt>G1</tt>-<tt>F2</tt>/<tt>G2</tt> examples
from before:
</p>

<blockquote>
<pre>
(DEFUN G3 MACRO (FORM)
       (LIST '+ (CADR FORM) 'X))
(DEFUN F3 (X) (G3 X))
</pre>
</blockquote>

<p>
Upon <tt>MACRO</tt> expansion, the <tt>F3</tt> definition will become
</p>

<blockquote>
<pre>
(DEFUN F3 (X) (+ X X))
</pre>
</blockquote>

<p>
Another example of this type of scoping power involves <tt>PROG</tt>
and <tt>RETURN</tt>.  Suppose we found it desirable to have a special
form named <tt>TRY</tt>, which when executed would evaluate the objects in 
its <tt>CDR</tt> sequentially, allowing early return by means of operators
<tt>FAIL</tt> and <tt>SUCCEED</tt>.  As it happens, definitions
of the form
</p>

<blockquote>
<pre>
(DEFUN FAIL (WHY?)
       (RETURN (CONS 'FAIL WHY?)))

(DEFUN SUCCEED (HOW?)
       (RETURN (CONS 'SUCCEED HOW?)))

(DEFUN MAIN ()
       (PROG () ... (FAIL 'ERROR)
                ... (SUCCEED <i>expression</i>)))
</pre>
</blockquote>

<p>
would succeed in the interpreter, but could not be compiled.
The compiler will turn
<tt>GO</tt>'s and <tt>RETURN</tt>'s into a single jump instruction which
jumps to the appropriate tag or to the return point of a <tt>PROG</tt>.
If an isolated program, such as <tt>FAIL</tt> or <tt>SUCCEED</tt>, does a
<tt>RETURN</tt> while not inside a <tt>PROG</tt>, no such jump instruction
can be created since there is no way of knowing where to jump to until runtime.
Hence, compilation of this code will fail.
</p>

<blockquote>
<FONT color="green">
<p>
[In the interpreter, <tt>MACLISP</tt> implemented <tt>GO</tt> and <tt>RETURN</tt>
 as if by a <tt>THROW</tt> to an internal tag in the innermost dynamically
 enclosing <tt>PROG</tt> so that the implementation accidentally permitted 
 <tt>GO</tt> and <tt>RETURN</tt> to work even through a function call in
 interpreted code.  This didn't ``work'' in compiled code.]
</p>
</FONT>
</blockquote>

<p>
However, a <tt>MACRO</tt> definition of this form will succeed.
The forms
</p>

<blockquote>
<pre>
(DEFUN FAIL MACRO (FORM)
       (LIST 'RETURN
             (LIST 'CONS ''FAIL (CADR FORM))))
(DEFUN SUCCEED MACRO (FORM)
       (LIST 'RETURN
             (LIST 'CONS ''SUCCEED (CADR FORM))))
</pre>
</blockquote>

<p>
would be macroexpanded by the compiler in the definition of <tt>MAIN</tt>
and the code resulting from the transformation would be within the 
scope of the <tt>PROG</tt>.

<h3>Declarations</h3>

<p>
Both <tt>FEXPR</tt>'s and <tt>MACRO</tt>'s suffer from the 
need for declaration in the compiler.  In the case of a <tt>FEXPR</tt>,
<i>f</i>, the declaration simply states that upon any references to <i>f</i>,
the compiler is not to generate code for evaluating the elements in the
<tt>CDR</tt> of <i>f</i>'s form.  While <tt>MACRO</tt>'s require no explicit
declaration, their definition must occur prior to reference to them in a
file, since the compiler will attempt to expand any macro as soon as it
is encountered.
</p>

<p>
Perhaps it is also a flaw in the specifications for <tt>FEXPR</tt>'s that
no declarations are required in the interpreter.  This makes dealing with
<tt>FEXPR</tt>'s in the interpreter exceedingly tricky because
programmers are taught that the definition need not be available until
the function is actually called.  The nature of <tt>MACRO</tt>'s,
on the other hand, effectively constrains them to be defined
in the environment earlier than the time at which they are
actually called.
</p>

<H2 ALIGN=CENTER>Conclusions</h2>

<p>
It should be clear from this discussion that <tt>FEXPR</tt>'s are only
safe if no part of their ``argument list'' is to be evaluated, and
even then only when there is a declaration available in the environment
in which they appear.
Using <tt>FEXPR</tt>'s to define control primitives will be prone to failure
due to problems of evaluation context and due to their
potential for confusing program-manipulating programs such as compilers and
macro packages.
</p>

<p>
<tt>MACRO</tt>'s on the other hand, offer a more straightforward and
reliable approach to all of the things which we have said should be 
required of a mechanism for defining special forms.
They can handle problems from implicit quoting to definition of control
structure in a very straightforward way because they are functionally
transparent; macro forms whose meaning is not understood may be expanded
to produce forms whose meaning can be understood.
</p>

<p>
It is widely held among members of the MIT Lisp community that
<tt>FEXPR</tt>, <tt>NLAMBDA</tt>, and related concepts could be omitted
from the Lisp language with no loss of generality and little loss of
expressive power,
and that doing so would make a general improvement in the quality and
reliability of program-manipulating programs.
</p>

<p>
<A NAME="RETURN-POINT-12">There</a>
are those who advocate the use of <tt>FEXPR</tt>'s, in the
interpreter for implementing control structure because they interface
better with certain kinds of debugging packages such as <tt>TRACE</tt>
and single-stepping packages.  Many of these people, however, will
admit that calls to <tt>FEXPR</tt>'s used as control structure are
bound to confuse compilers and macro packages, and that it is probably
a good idea, given that <tt>FEXPR</tt>'s do exist, to require
compatible <tt>MACRO</tt> definitions be provided by the user in any
environment in which <tt>FEXPR</tt>'s will be used.  This would mean
that a person could create a <tt>FEXPR</tt> named <tt>IF</tt>,
provided he also created an <tt>IF</tt> <tt>MACRO</tt> which described
its behavior; the <tt>FEXPR</tt> definition could <b>shadow</B>
<a href="Special-Forms.html#FOOTNOTE-12">[12]</a> the <tt>MACRO</tt> definition in
the interpreter, but programs other than the interpreter could
appeal to the <tt>MACRO</tt> definition for a description of the 
<tt>FEXPR</tt>'s functionality.
</p>

<p>
The <tt>NIL</tt> dialect will not support <tt>FEXPR</tt>'s, <tt>NLAMBDA</tt>'s or
<tt>&amp;QUOTE</tt>-like constructs at all.
The intent there is that there should be a minimal number of operators
like <tt>QUOTE</tt> and <tt>COND</tt> which must really
be treated specially.  All other primitives are not of this type.
This means that program-manipulating code can be written which special-cases
these basic primitives without fear that such code will later break due to the
implementation of other such forms by the user.  The functional transparency
provided by <tt>MACRO</tt>'s makes new control primitives automatically
compatible with pre-existing code-manipulating packages.
</p>

<p>
It would seem that <tt>NIL</tt> has taken the right step.
It would be naive to expect that <tt>FEXPR</tt>'s and <tt>NLAMBDA</tt>'s
will ever be flushed from existing dialects.  In spite of their problems,
much useful code has been written to depend on them and the job of
changing all of this code would be tremendous.  In looking
toward the future, however, serious thought should be given to whether or not
such constructs really have a place in the language.  If it is determined
that they do have a place, greater consideration should be given to the
declarations,
particularly the requirement of compatible macro definitions,
in order that other software may achieve higher reliability in an
environment in which <tt>FEXPR</tt>'s and <tt>NLAMBDA</tt>'s exist.
</p>


<H2 ALIGN=CENTER>References</h2>

<p>
<A NAME="JRA"><b>John R. Allen</B>:</a>
<i>Anatomy of Lisp</i>,
McGraw-Hill, Inc., 1978.
</p>

<p>
<A NAME="C-R-M"><b>Charniak, Riesbeck, and McDermott</B>:</a>
<i>Artificial Intelligence Programming</i>,
Lawrence Erlbaum Associates,
Hillsdale, NJ, 1980.
</p>

<p>
<A NAME="BSG"><b>Bernard Greenberg</B>:</a>
<i>Notes on the Programming Language Lisp</i>,
Student Information Processing Board,
MIT, 1978.
</p>

<p>
<A NAME="JMC"><b>John McCarthy</B>:</a>
<i>Lisp 1.5 Programmer's Manual</i>,
MIT Press, 
Cambridge, MA, August, 1962.
</p>

<p>
<A NAME="MOONUAL"><b>David A. Moon</B>:</a>
<i>Maclisp Reference Manual</i>,
Laboratory for Computer Science,
MIT,
March 1974.
</p>

<p>
<A NAME="RABBIT"><b>Guy L. Steele, Jr.</B>:</a>
<i>Rabbit: A Compiler for Scheme</i>,
AI-TR-474, Artificial Intelligence Laboratory,
MIT,
May, 1978.
</p>

<p>
<A NAME="SCHEME"><b>Guy L. Steele, Jr. and Gerald J. Sussman</B>:</a>
<i>The Revised Report on SCHEME, A Dialect of Lisp</i>,
AI Memo 452,
Artificial Intelligence Laboratory,
MIT,
January 1978.
</p>

<p>
<A NAME="INTERLISP"><b>Warren Teitelman</B>:</a>
<i>Interlisp Reference Manual</i>,
Xerox Palo Alto Research Center,
October 1978.
</p>

<p>
<A NAME="CHINEUAL"><b>Daniel Weinreb and David Moon</B>:</a>
<i>Lisp Machine Manual</i>,
Artificial Intelligence Laboratory,
MIT,
January 1979.
</p>

<p>
<b>Jon L. White</B>:
<I>``NIL--A Perspective''</i>,
1979 Macsyma Users' Conference Proceedings;
Washington, DC; June 20-22, 1979.
</p>

<p>
<b>Patrick Winston and Berthold K. P. Horn</B>:
<i>LISP</i>,
Addison Wesley, 1980.
</p>


<H2 ALIGN=CENTER>Acknowledgments</h2>

<p>
I would like to extend my thanks to 
Jonathan Rees,
Robert Kerns,
Ed Barton,
Guy Steele,
Alan Bawden,
Bill Dubuque, 
Robert Handsaker,
Richard Bryan,
Jonl White,
Barry Trager,
and Jim O'Dell
for their very useful comments and criticisms on developing
drafts of this paper.
</p>

<hr />

<P ALIGN=CENTER><FONT color="green"><b>[Footnotes]</B></FONT></p>

<DL COMPACT>
<DT><A NAME="FOOTNOTE-1">[1]</a></DT>
<DD>
The Lisp dialects in use for research at MIT include
<tt>MACLISP</tt> <a href="Special-Forms.html#MOONUAL">[Moon 74]</a>,
<tt>LISPMACHINE</tt> Lisp <a href="Special-Forms.html#CHINEUAL">[Weinreb, Moon 79]</a>,
and <tt>NIL</tt> (New Implementation of Lisp) [White 79].
<br /><a href="Special-Forms.html#RETURN-POINT-1">[Click here to return to point of reference]</a>
<p></p>
</DD>
<DT><A NAME="FOOTNOTE-2">[2]</a></DT>
<DD>
Some Lisp variants, 
such as <tt>SCHEME</tt> <a href="Special-Forms.html#SCHEME">[Steele, Sussman 78]</a> 
do not define the order of argument evaluation.
<tt>SCHEME</tt>, however, differs sufficiently from
other Lisp dialects that, for the sake of brevity, it will not be addressed
in this paper.
<br /><a href="Special-Forms.html#RETURN-POINT-2">[Click here to return to point of reference]</a>
<p></p>
</DD>
<DT><A NAME="FOOTNOTE-3">[3]</a></DT>
<DD>
<tt>EXPR</tt> is the <tt>MACLISP</tt> term for the class of normal functional operators.
<br /><a href="Special-Forms.html#RETURN-POINT-3">[Click here to return to point of reference]</a>
<p></p>
</DD>
<DT><A NAME="FOOTNOTE-4">[4]</a></DT>
<DD>
In general, the <tt>MACLISP</tt> <tt>LEXPR</tt> <tt>LAMBDA</tt>'s, <tt>LISPMACHINE</tt> Lisp's
``<tt>&amp;OPTIONAL</tt>'' and ``<tt>&amp;REST</tt>'' markers, and
<tt>INTERLISP</tt>'s nospread functions all offer a satisfactory solution to the
problem of functions which allow variable numbers of arguments.
Sometimes, especially when dealing with compilation,
it may still be desirable to define such operators as special forms instead.
<br /><a href="Special-Forms.html#RETURN-POINT-4">[Click here to return to point of reference]</a>
<p></p>
</DD>
<DT><A NAME="FOOTNOTE-5">[5]</a></DT>
<DD>
Midas is the PDP10 assembly language in which <tt>MACLISP</tt> is written.
<br /><a href="Special-Forms.html#RETURN-POINT-5">[Click here to return to point of reference]</a>
<p></p>
</DD>
<DT><A NAME="FOOTNOTE-6">[6]</a></DT>
<DD>
Here again we shall use <tt>MACLISP</tt>'s semantics rather than <tt>INTERLISP</tt>'s
for <tt>MACRO</tt>'s.  <tt>INTERLISP</tt> does not support macros in the interpreter
except in a very ad hoc way through its DWIM 
<a href="Special-Forms.html#INTERLISP">[Teitelman 78]</a> facility
that runs when an undefined function is seen and attempts to correct the
``error'' by invoking the <tt>MACRO</tt> definition.
<br /><a href="Special-Forms.html#RETURN-POINT-6">[Click here to return to point of reference]</a>
<p></p>
</DD>
<DT><A NAME="FOOTNOTE-7">[7]</a></DT>
<DD>
Adventurous readers with access to <tt>MACLISP</tt> might wish to try typing
<pre>
(PUTPROP 'QUOTE (GET 'CAR 'SUBR) 'FSUBR)
</pre>
for a striking illustration of this phenomenon.  Except for a slight reduction
in error checking, the Lisp should continue to function
correctly despite the seemingly drastic nature of this incantation.
<br /><a href="Special-Forms.html#RETURN-POINT-7">[Click here to return to point of reference]</a>
<p></p>
</DD>
<DT><A NAME="FOOTNOTE-8">[8]</a></DT>
<DD>
An applicable operator is one which can be used as a first argument 
to <tt>APPLY</tt> to obtain meaningful results.
<br /><a href="Special-Forms.html#RETURN-POINT-8">[Click here to return to point of reference]</a>
<p></p>
</DD>
<DT><A NAME="FOOTNOTE-9">[9]</a></DT>
<DD>
Note that the <tt>TRACE</tt> function illustrated here 
is itself a special form.
<br /><a href="Special-Forms.html#RETURN-POINT-9">[Click here to return to point of reference]</a>
<p></p>
</DD>
<DT><A NAME="FOOTNOTE-10">[10]</a></DT>
<DD>
<tt>MACLISP</tt>, <tt>INTERLISP</tt>, <tt>NIL</tt>, and <tt>LISPMACHINE</tt> Lisp all offer sophisticated
schemes for recording a previous macroexpansion in a way that
prevents the need of recalculating a <tt>MACRO</tt> expansion while
still retaining a pointer to the original form for pretty-printing purposes.
The <tt>LISPMACHINE</tt> Manual (pp 141-142) offers an explanation of how this
is accomplished.
<br /><a href="Special-Forms.html#RETURN-POINT-10">[Click here to return to point of reference]</a>
<p></p>
</DD>
<DT><A NAME="FOOTNOTE-11">[11]</a></DT>
<DD>
In this section ``the compiler'' will refer to the <tt>MACLISP</tt> compiler because
<FONT color="green">[in 1980]</FONT>
it is the only Lisp compiler with which the author has a good deal of 
familiarity.  The issues addressed should generalize to <tt>INTERLISP</tt> and
<tt>LISPMACHINE</tt> Lisp, although the way they are dealt with (if at all) in 
these other dialects  may be quite different in some cases.
<br /><a href="Special-Forms.html#RETURN-POINT-11">[Click here to return to point of reference]</a>
<p></p>
</DD>
<DT><A NAME="FOOTNOTE-12">[12]</a></DT>
<DD>
In <tt>MACLISP</tt>, since definitions live on the property list and symbols have
more than one definitional property, the definition closest to the head
of the property list has precedence.  Other definitions are said to be 
<b>shadowed</B>.
<br /><a href="Special-Forms.html#RETURN-POINT-12">[Click here to return to point of reference]</a>
<p></p>
</DD>
</DL>

<hr />

<FONT color="green">

<p>
<A NAME="COPYRIGHT">Original printed text document</a><br />
<b>Copyright 1980, Kent M. Pitman. All Rights Reserved.</B>
</p>

<p>
HTML hypertext version of document<br />
<b>Copyright 1998, Kent M. Pitman.  All rights reserved.</B><br />
The following limited, non-exclusive, 
revokable licenses are granted:
</p>

<blockquote>
<p>
Browsing of this document (that is, transmission and display of a temporary
copy of this document for the ordinary purpose of direct viewing by a 
human being in the usual manner that hypertext browsers permit such
viewing) is expressly permitted, provided that no recopying, 
redistribution, redisplay, or retransmission is made of any such copy.
</p>

<p>
Bookmarking of this document (that is, recording only the document's title and 
Uniform Resource Locator, or URL, but not its content,
for the purpose of remembering an association between the document's title
and the URL, and/or for the purpose of making a subsequent request 
for a fresh copy of the content named by that URL)
is also expressly permitted.
</p>
</blockquote>

<p>
All other uses require negotiated permission.
</p>


</FONT>

<hr />

<P ALIGN=CENTER>
<a href="https://www.nhplace.com/kent/Papers/index.html"><i>Click here for an index 
of other titles by Kent Pitman.</i></a>
</p>




</body>
</html>